// OCLADOCK: AUTOMATICALLY GENERATED FILE, DO NOT EDIT
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *calcenergy_ocl =
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"#ifndef DEFINES_H_\n"
"#define DEFINES_H_\n"
"\n"
"#if defined (N16WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 16\n"
"#elif defined (N32WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 32\n"
"#elif defined (N64WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 64\n"
"#elif defined (N128WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 128\n"
"#elif defined (N256WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 256\n"
"#else\n"
"	#define NUM_OF_THREADS_PER_BLOCK 64\n"
"#endif\n"
"\n"
"#define MAX_NUM_OF_ATOMS 				256\n"
"#define MAX_NUM_OF_ATYPES 			14\n"
"#define MAX_NUM_OF_ROTBONDS 		32\n"
"#define MAX_INTRAE_CONTRIBUTORS MAX_NUM_OF_ATOMS * MAX_NUM_OF_ATOMS\n"
"#define MAX_NUM_OF_ROTATIONS 		MAX_NUM_OF_ATOMS * MAX_NUM_OF_ROTBONDS\n"
"#define MAX_POPSIZE 						2048\n"
"#define MAX_NUM_OF_RUNS 				1000\n"
"\n"
"// Must be bigger than MAX_NUM_OF_ROTBONDS+6\n"
"#define GENOTYPE_LENGTH_IN_GLOBMEM 64\n"
"#define ACTUAL_GENOTYPE_LENGTH	(MAX_NUM_OF_ROTBONDS+6)\n"
"\n"
"#define LS_EXP_FACTOR 					2.0f\n"
"#define LS_CONT_FACTOR 					0.5f\n"
"\n"
"// Improvements over Pechan's implementation\n"
"#define NATIVE_PRECISION\n"
"#define ASYNC_COPY\n"
"#define IMPROVE_GRID\n"
"#define RESTRICT_ARGS\n"
"#define MAPPED_COPY\n"
"\n"
"#endif /* DEFINES_H_ */\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"#ifndef CALCENERGY_BASIC_H_\n"
"#define CALCENERGY_BASIC_H_\n"
"\n"
"\n"
"#define RLIST_ATOMID_MASK 	 0x000000FF\n"
"#define RLIST_RBONDID_MASK 	 0x0000FF00\n"
"#define RLIST_RBONDID_SHIFT  8\n"
"#define RLIST_FIRSTROT_MASK  0x00010000\n"
"#define RLIST_GENROT_MASK 	 0x00020000\n"
"#define RLIST_DUMMY_MASK 	 	 0x00040000\n"
"#define DEG_TO_RAD 					 0.0174533f\n"
"\n"
"// LCG: linear congruential generator constants\n"
"#define RAND_A 							1103515245u\n"
"#define RAND_C 							12345u\n"
"// WARNING: it is supposed that unsigned int is 32 bit long\n"
"#define MAX_UINT 						4294967296.0f\n"
"\n"
"// Macro for capturing grid values\n"
"	// Original\n"
"	#define GETGRIDVALUE(mempoi,gridsize_x,gridsize_y,gridsize_z,t,z,y,x)   *(mempoi + gridsize_x*(y + gridsize_y*(z + gridsize_z*t)) + x)\n"
"\n"
"	// Optimization 1\n"
"	// #define GETGRIDVALUE_OPT(mempoi,gridsize_x,gridsize_y,mul_tmp,z,y,x)   *(mempoi + gridsize_x*(y + gridsize_y*(z + mul_tmp)) + x)\n"
"\n"
"	// Optimization 2\n"
"	// Implemented direclty in the kernel code: calcenergy_fourkernels_intel.cl\n"
"\n"
"// Macro for trilinear interpolation\n"
"#define TRILININTERPOL(cube, weights) (cube[0][0][0]*weights[0][0][0] +cube[1][0][0]*weights[1][0][0] +	\\\n"
"				       cube[0][1][0]*weights[0][1][0] +cube[1][1][0]*weights[1][1][0] + \\\n"
"				       cube[0][0][1]*weights[0][0][1] +cube[1][0][1]*weights[1][0][1] + \\\n"
"				       cube[0][1][1]*weights[0][1][1] +cube[1][1][1]*weights[1][1][1])\n"
"\n"
"#endif /* CALCENERGY_BASIC_H_ */\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"\n"
"// All related pragmas are in defines.h (accesible by host and device code)\n"
"\n"
"void gpu_calc_energy(	    int    dockpars_rotbondlist_length,\n"
"			    char   dockpars_num_of_atoms,\n"
"			    char   dockpars_gridsize_x,\n"
"			    char   dockpars_gridsize_y,\n"
"			    char   dockpars_gridsize_z,\n"
"		#if defined (RESTRICT_ARGS)\n"
"			__global const float* restrict dockpars_fgrids, // cannot be allocated in __constant (too large)\n"
"		#else\n"
"			__global const float* dockpars_fgrids, // cannot be allocated in __constant (too large)\n"
"		#endif\n"
"		            char   dockpars_num_of_atypes,\n"
"		            int    dockpars_num_of_intraE_contributors,\n"
"			    float  dockpars_grid_spacing,\n"
"			    float  dockpars_coeff_elec,\n"
"			    float  dockpars_qasp,\n"
"			    float  dockpars_coeff_desolv,\n"
"\n"
"		    __local float* genotype,\n"
"		    __local float* energy,\n"
"		    __local int*   run_id,\n"
"\n"
"                    // Some OpenCL compilers don't allow local var outside kernels\n"
"		    // so this local vars are passed from a kernel\n"
"		    __local float* calc_coords_x,\n"
"		    __local float* calc_coords_y,\n"
"		    __local float* calc_coords_z,\n"
"		    __local float* partial_energies,\n"
"\n"
"	       __constant float* atom_charges_const,\n"
"               __constant char*  atom_types_const,\n"
"               __constant char*  intraE_contributors_const,\n"
"               __constant float* VWpars_AC_const,\n"
"               __constant float* VWpars_BD_const,\n"
"               __constant float* dspars_S_const,\n"
"               __constant float* dspars_V_const,\n"
"               __constant int*   rotlist_const,\n"
"               __constant float* ref_coords_x_const,\n"
"               __constant float* ref_coords_y_const,\n"
"               __constant float* ref_coords_z_const,\n"
"               __constant float* rotbonds_moving_vectors_const,\n"
"               __constant float* rotbonds_unit_vectors_const,\n"
"               __constant float* ref_orientation_quats_const\n"
")\n"
"\n"
"//The GPU device function calculates the energy of the entity described by genotype, dockpars and the liganddata\n"
"//arrays in constant memory and returns it in the energy parameter. The parameter run_id has to be equal to the ID\n"
"//of the run whose population includes the current entity (which can be determined with blockIdx.x), since this\n"
"//determines which reference orientation should be used.\n"
"{\n"
"	int contributor_counter;\n"
"	/*char*/uint atom1_id, atom2_id, atom1_typeid, atom2_typeid;\n"
"\n"
"	// Name changed to distance_leo to avoid\n"
"	// errors as \"distance\" is the name of OpenCL function\n"
"	//float subx, suby, subz, distance;\n"
"	float subx, suby, subz, distance_leo;\n"
"\n"
"	float x, y, z, dx, dy, dz, q;\n"
"	float cube[2][2][2];\n"
"	float weights[2][2][2];\n"
"	int x_low, x_high, y_low, y_high, z_low, z_high;\n"
"\n"
"	float phi, theta, genrotangle, rotation_angle, sin_angle;\n"
"	float genrot_unitvec[3], rotation_unitvec[3], rotation_movingvec[3];\n"
"	int rotation_counter, rotation_list_element;\n"
"	float atom_to_rotate[3];\n"
"	int atom_id, rotbond_id;\n"
"	float quatrot_left_x, quatrot_left_y, quatrot_left_z, quatrot_left_q;\n"
"	float quatrot_temp_x, quatrot_temp_y, quatrot_temp_z, quatrot_temp_q;\n"
"\n"
"        // Some OpenCL compilers don't allow local var outside kernels\n"
"	// so this local vars are passed from a kernel\n"
"	//__local float calc_coords_x[MAX_NUM_OF_ATOMS];\n"
"	//__local float calc_coords_y[MAX_NUM_OF_ATOMS];\n"
"	//__local float calc_coords_z[MAX_NUM_OF_ATOMS];\n"
"	//__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	partial_energies[get_local_id(0)] = 0.0f;\n"
"\n"
"	//CALCULATE CONFORMATION\n"
"\n"
"	//calculate vectors for general rotation\n"
"	phi         = genotype[3]*DEG_TO_RAD;\n"
"	theta       = genotype[4]*DEG_TO_RAD;\n"
"	genrotangle = genotype[5]*DEG_TO_RAD;\n"
"\n"
"#if defined (IMPROVE_GRID)\n"
"\n"
"	#if defined (NATIVE_PRECISION)\n"
"	sin_angle = native_sin(theta);\n"
"	genrot_unitvec [0] = sin_angle*native_cos(phi);\n"
"	genrot_unitvec [1] = sin_angle*native_sin(phi);\n"
"	genrot_unitvec [2] = native_cos(theta);\n"
"	#elif defined (HALF_PRECISION)\n"
"	sin_angle = half_sin(theta);\n"
"	genrot_unitvec [0] = sin_angle*half_cos(phi);\n"
"	genrot_unitvec [1] = sin_angle*half_sin(phi);\n"
"	genrot_unitvec [2] = half_cos(theta);\n"
"	#else	// Full precision\n"
"	sin_angle = sin(theta);\n"
"	genrot_unitvec [0] = sin_angle*cos(phi);\n"
"	genrot_unitvec [1] = sin_angle*sin(phi);\n"
"	genrot_unitvec [2] = cos(theta);\n"
"	#endif\n"
"\n"
"	// INTERMOLECULAR for-loop (intermediate results)\n"
"	// It stores a product of two chars\n"
"	unsigned int mul_tmp;\n"
"\n"
"	unsigned char g1 = dockpars_gridsize_x;\n"
"	unsigned int  g2 = dockpars_gridsize_x * dockpars_gridsize_y;\n"
"  unsigned int  g3 = dockpars_gridsize_x * dockpars_gridsize_y * dockpars_gridsize_z;\n"
"\n"
"	unsigned int ylow_times_g1, yhigh_times_g1;\n"
"	unsigned int zlow_times_g2, zhigh_times_g2;\n"
"\n"
"	unsigned int cube_000;\n"
"	unsigned int cube_100;\n"
"  unsigned int cube_010;\n"
"	unsigned int cube_110;\n"
"	unsigned int cube_001;\n"
"  unsigned int cube_101;\n"
"  unsigned int cube_011;\n"
"  unsigned int cube_111;\n"
"\n"
"#else\n"
"	sin_angle = sin(theta);\n"
"	genrot_unitvec [0] = sin_angle*cos(phi);\n"
"	genrot_unitvec [1] = sin_angle*sin(phi);\n"
"	genrot_unitvec [2] = cos(theta);\n"
"#endif\n"
"\n"
"	// ================================================\n"
"	// Iterating over elements of rotation list\n"
"	// ================================================\n"
"	for (rotation_counter = get_local_id(0);\n"
"	     rotation_counter < dockpars_rotbondlist_length;\n"
"	     rotation_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		rotation_list_element = rotlist_const[rotation_counter];\n"
"\n"
"		if ((rotation_list_element & RLIST_DUMMY_MASK) == 0)	//if not dummy rotation\n"
"		{\n"
"			atom_id = rotation_list_element & RLIST_ATOMID_MASK;\n"
"\n"
"			//capturing atom coordinates\n"
"			if ((rotation_list_element & RLIST_FIRSTROT_MASK) != 0)	//if firts rotation of this atom\n"
"			{\n"
"				atom_to_rotate[0] = ref_coords_x_const[atom_id];\n"
"				atom_to_rotate[1] = ref_coords_y_const[atom_id];\n"
"				atom_to_rotate[2] = ref_coords_z_const[atom_id];\n"
"			}\n"
"			else\n"
"			{\n"
"				atom_to_rotate[0] = calc_coords_x[atom_id];\n"
"				atom_to_rotate[1] = calc_coords_y[atom_id];\n"
"				atom_to_rotate[2] = calc_coords_z[atom_id];\n"
"			}\n"
"\n"
"			//capturing rotation vectors and angle\n"
"			if ((rotation_list_element & RLIST_GENROT_MASK) != 0)	//if general rotation\n"
"			{\n"
"				rotation_unitvec[0] = genrot_unitvec[0];\n"
"				rotation_unitvec[1] = genrot_unitvec[1];\n"
"				rotation_unitvec[2] = genrot_unitvec[2];\n"
"\n"
"				rotation_angle = genrotangle;\n"
"\n"
"				rotation_movingvec[0] = genotype[0];\n"
"				rotation_movingvec[1] = genotype[1];\n"
"				rotation_movingvec[2] = genotype[2];\n"
"			}\n"
"			else	//if rotating around rotatable bond\n"
"			{\n"
"				rotbond_id = (rotation_list_element & RLIST_RBONDID_MASK) >> RLIST_RBONDID_SHIFT;\n"
"\n"
"				rotation_unitvec[0] = rotbonds_unit_vectors_const[3*rotbond_id];\n"
"				rotation_unitvec[1] = rotbonds_unit_vectors_const[3*rotbond_id+1];\n"
"				rotation_unitvec[2] = rotbonds_unit_vectors_const[3*rotbond_id+2];\n"
"				rotation_angle = genotype[6+rotbond_id]*DEG_TO_RAD;\n"
"\n"
"				rotation_movingvec[0] = rotbonds_moving_vectors_const[3*rotbond_id];\n"
"				rotation_movingvec[1] = rotbonds_moving_vectors_const[3*rotbond_id+1];\n"
"				rotation_movingvec[2] = rotbonds_moving_vectors_const[3*rotbond_id+2];\n"
"\n"
"				//in addition, performing the first movement which is needed only if rotating around rotatable bond\n"
"				atom_to_rotate[0] -= rotation_movingvec[0];\n"
"				atom_to_rotate[1] -= rotation_movingvec[1];\n"
"				atom_to_rotate[2] -= rotation_movingvec[2];\n"
"			}\n"
"\n"
"			//performing rotation\n"
"\n"
"#if defined (NATIVE_PRECISION)\n"
"			rotation_angle = native_divide(rotation_angle,2);\n"
"			quatrot_left_q = native_cos(rotation_angle);\n"
"			sin_angle = native_sin(rotation_angle);\n"
"#elif defined (HALF_PRECISION)\n"
"			rotation_angle = half_divide(rotation_angle,2);\n"
"			quatrot_left_q = half_cos(rotation_angle);\n"
"			sin_angle = half_sin(rotation_angle);\n"
"#else	// Full precision\n"
"			rotation_angle = rotation_angle/2;\n"
"			quatrot_left_q = cos(rotation_angle);\n"
"			sin_angle = sin(rotation_angle);\n"
"#endif\n"
"			quatrot_left_x = sin_angle*rotation_unitvec[0];\n"
"			quatrot_left_y = sin_angle*rotation_unitvec[1];\n"
"			quatrot_left_z = sin_angle*rotation_unitvec[2];\n"
"\n"
"			if ((rotation_list_element & RLIST_GENROT_MASK) != 0)	// if general rotation,\n"
"																														// two rotations should be performed\n"
"																														// (multiplying the quaternions)\n"
"			{\n"
"				//calculating quatrot_left*ref_orientation_quats_const,\n"
"				//which means that reference orientation rotation is the first\n"
"				quatrot_temp_q = quatrot_left_q;\n"
"				quatrot_temp_x = quatrot_left_x;\n"
"				quatrot_temp_y = quatrot_left_y;\n"
"				quatrot_temp_z = quatrot_left_z;\n"
"\n"
"				quatrot_left_q = quatrot_temp_q*ref_orientation_quats_const[4*(*run_id)]-\n"
"						 						 quatrot_temp_x*ref_orientation_quats_const[4*(*run_id)+1]-\n"
"						 					 	 quatrot_temp_y*ref_orientation_quats_const[4*(*run_id)+2]-\n"
"						   			 	   quatrot_temp_z*ref_orientation_quats_const[4*(*run_id)+3];\n"
"				quatrot_left_x = quatrot_temp_q*ref_orientation_quats_const[4*(*run_id)+1]+\n"
"						 						 ref_orientation_quats_const[4*(*run_id)]*quatrot_temp_x+\n"
"						 					 	 quatrot_temp_y*ref_orientation_quats_const[4*(*run_id)+3]-\n"
"						 					 	 ref_orientation_quats_const[4*(*run_id)+2]*quatrot_temp_z;\n"
"				quatrot_left_y = quatrot_temp_q*ref_orientation_quats_const[4*(*run_id)+2]+\n"
"						 						 ref_orientation_quats_const[4*(*run_id)]*quatrot_temp_y+\n"
"						      			 ref_orientation_quats_const[4*(*run_id)+1]*quatrot_temp_z-\n"
"						 					 	 quatrot_temp_x*ref_orientation_quats_const[4*(*run_id)+3];\n"
"				quatrot_left_z = quatrot_temp_q*ref_orientation_quats_const[4*(*run_id)+3]+\n"
"						 						 ref_orientation_quats_const[4*(*run_id)]*quatrot_temp_z+\n"
"						 					 	 quatrot_temp_x*ref_orientation_quats_const[4*(*run_id)+2]-\n"
"						 					 	 ref_orientation_quats_const[4*(*run_id)+1]*quatrot_temp_y;\n"
"\n"
"			}\n"
"\n"
"			quatrot_temp_q = 0 -\n"
"					 						 quatrot_left_x*atom_to_rotate [0] -\n"
"					 					 	 quatrot_left_y*atom_to_rotate [1] -\n"
"					 					 	 quatrot_left_z*atom_to_rotate [2];\n"
"			quatrot_temp_x = quatrot_left_q*atom_to_rotate [0] +\n"
"					 					   quatrot_left_y*atom_to_rotate [2] -\n"
"					 					 	 quatrot_left_z*atom_to_rotate [1];\n"
"			quatrot_temp_y = quatrot_left_q*atom_to_rotate [1] -\n"
"					 					   quatrot_left_x*atom_to_rotate [2] +\n"
"					 					 	 quatrot_left_z*atom_to_rotate [0];\n"
"			quatrot_temp_z = quatrot_left_q*atom_to_rotate [2] +\n"
"					 						 quatrot_left_x*atom_to_rotate [1] -\n"
"					 					 	 quatrot_left_y*atom_to_rotate [0];\n"
"\n"
"			atom_to_rotate [0] = 0 -\n"
"					     						 quatrot_temp_q*quatrot_left_x +\n"
"					     			 			 quatrot_temp_x*quatrot_left_q -\n"
"					            		 quatrot_temp_y*quatrot_left_z +\n"
"					     			 	     quatrot_temp_z*quatrot_left_y;\n"
"			atom_to_rotate [1] = 0 -\n"
"					     					   quatrot_temp_q*quatrot_left_y +\n"
"					     			 			 quatrot_temp_x*quatrot_left_z +\n"
"					     			 			 quatrot_temp_y*quatrot_left_q -\n"
"					     			 			 quatrot_temp_z*quatrot_left_x;\n"
"			atom_to_rotate [2] = 0 -\n"
"					     					   quatrot_temp_q*quatrot_left_z -\n"
"					     			 			 quatrot_temp_x*quatrot_left_y +\n"
"					     			 			 quatrot_temp_y*quatrot_left_x +\n"
"					     			 			 quatrot_temp_z*quatrot_left_q;\n"
"\n"
"			//performing final movement and storing values\n"
"			calc_coords_x[atom_id] = atom_to_rotate [0] + rotation_movingvec[0];\n"
"			calc_coords_y[atom_id] = atom_to_rotate [1] + rotation_movingvec[1];\n"
"			calc_coords_z[atom_id] = atom_to_rotate [2] + rotation_movingvec[2];\n"
"\n"
"		} // End if-statement not dummy rotation\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	} // End rotation_counter for-loop\n"
"\n"
"	// ================================================\n"
"	// CALCULATE INTERMOLECULAR ENERGY\n"
"	// ================================================\n"
"	for (atom1_id = get_local_id(0);\n"
"	     atom1_id < dockpars_num_of_atoms;\n"
"	     atom1_id+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		atom1_typeid = atom_types_const[atom1_id];\n"
"		x = calc_coords_x[atom1_id];\n"
"		y = calc_coords_y[atom1_id];\n"
"		z = calc_coords_z[atom1_id];\n"
"		q = atom_charges_const[atom1_id];\n"
"\n"
"		if ((x < 0) || (y < 0) || (z < 0) || (x >= dockpars_gridsize_x-1)\n"
"				                  						|| (y >= dockpars_gridsize_y-1)\n"
"						  												|| (z >= dockpars_gridsize_z-1)){\n"
"			partial_energies[get_local_id(0)] += 16777216.0f; //100000.0f;\n"
"		}\n"
"		else\n"
"		{\n"
"			//get coordinates\n"
"			x_low = (int)floor(x); y_low = (int)floor(y); z_low = (int)floor(z);\n"
"			x_high = (int)ceil(x); y_high = (int)ceil(y); z_high = (int)ceil(z);\n"
"			dx = x - x_low; dy = y - y_low; dz = z - z_low;\n"
"\n"
"			//calculate interpolation weights\n"
"			weights [0][0][0] = (1-dx)*(1-dy)*(1-dz);\n"
"			weights [1][0][0] = dx*(1-dy)*(1-dz);\n"
"			weights [0][1][0] = (1-dx)*dy*(1-dz);\n"
"			weights [1][1][0] = dx*dy*(1-dz);\n"
"			weights [0][0][1] = (1-dx)*(1-dy)*dz;\n"
"			weights [1][0][1] = dx*(1-dy)*dz;\n"
"			weights [0][1][1] = (1-dx)*dy*dz;\n"
"			weights [1][1][1] = dx*dy*dz;\n"
"\n"
"			//capturing affinity values\n"
"#if defined (IMPROVE_GRID)\n"
"			ylow_times_g1  = y_low*g1;\n"
"			yhigh_times_g1 = y_high*g1;\n"
"		  zlow_times_g2  = z_low*g2;\n"
"			zhigh_times_g2 = z_high*g2;\n"
"\n"
"			cube_000 = x_low  + ylow_times_g1  + zlow_times_g2;\n"
"			cube_100 = x_high + ylow_times_g1  + zlow_times_g2;\n"
"			cube_010 = x_low  + yhigh_times_g1 + zlow_times_g2;\n"
"			cube_110 = x_high + yhigh_times_g1 + zlow_times_g2;\n"
"			cube_001 = x_low  + ylow_times_g1  + zhigh_times_g2;\n"
"			cube_101 = x_high + ylow_times_g1  + zhigh_times_g2;\n"
"			cube_011 = x_low  + yhigh_times_g1 + zhigh_times_g2;\n"
"			cube_111 = x_high + yhigh_times_g1 + zhigh_times_g2;\n"
"			mul_tmp = atom1_typeid*g3;\n"
"\n"
"			cube [0][0][0] = *(dockpars_fgrids + cube_000 + mul_tmp);\n"
"			cube [1][0][0] = *(dockpars_fgrids + cube_100 + mul_tmp);\n"
"      cube [0][1][0] = *(dockpars_fgrids + cube_010 + mul_tmp);\n"
"      cube [1][1][0] = *(dockpars_fgrids + cube_110 + mul_tmp);\n"
"      cube [0][0][1] = *(dockpars_fgrids + cube_001 + mul_tmp);\n"
"      cube [1][0][1] = *(dockpars_fgrids + cube_101 + mul_tmp);\n"
"      cube [0][1][1] = *(dockpars_fgrids + cube_011 + mul_tmp);\n"
"      cube [1][1][1] = *(dockpars_fgrids + cube_111 + mul_tmp);\n"
"\n"
"#else\n"
"			cube [0][0][0] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_low, y_low, x_low);\n"
"			cube [1][0][0] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_low, y_low, x_high);\n"
"			cube [0][1][0] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      								  dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_low, y_high, x_low);\n"
"			cube [1][1][0] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_low, y_high, x_high);\n"
"			cube [0][0][1] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_high, y_low, x_low);\n"
"			cube [1][0][1] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      								  atom1_typeid, z_high, y_low, x_high);\n"
"			cube [0][1][1] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_high, y_high, x_low);\n"
"			cube [1][1][1] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_high, y_high, x_high);\n"
"#endif\n"
"\n"
"			//calculating affinity energy\n"
"			partial_energies[get_local_id(0)] += TRILININTERPOL(cube, weights);\n"
"\n"
"			//capturing electrostatic values\n"
"			atom1_typeid = dockpars_num_of_atypes;\n"
"\n"
"#if defined (IMPROVE_GRID)\n"
"			mul_tmp = atom1_typeid*g3;\n"
"			cube [0][0][0] = *(dockpars_fgrids + cube_000 + mul_tmp);\n"
"			cube [1][0][0] = *(dockpars_fgrids + cube_100 + mul_tmp);\n"
"      cube [0][1][0] = *(dockpars_fgrids + cube_010 + mul_tmp);\n"
"      cube [1][1][0] = *(dockpars_fgrids + cube_110 + mul_tmp);\n"
"      cube [0][0][1] = *(dockpars_fgrids + cube_001 + mul_tmp);\n"
"      cube [1][0][1] = *(dockpars_fgrids + cube_101 + mul_tmp);\n"
"      cube [0][1][1] = *(dockpars_fgrids + cube_011 + mul_tmp);\n"
"      cube [1][1][1] = *(dockpars_fgrids + cube_111 + mul_tmp);\n"
"\n"
"#else\n"
"			cube [0][0][0] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      		 						  dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_low, y_low, x_low);\n"
"			cube [1][0][0] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_low, y_low, x_high);\n"
"			cube [0][1][0] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_low, y_high, x_low);\n"
"			cube [1][1][0] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_low, y_high, x_high);\n"
"			cube [0][0][1] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_high, y_low, x_low);\n"
"			cube [1][0][1] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_high, y_low, x_high);\n"
"			cube [0][1][1] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_high, y_high, x_low);\n"
"			cube [1][1][1] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_high, y_high, x_high);\n"
"#endif\n"
"\n"
"			//calculating electrosatic energy\n"
"			partial_energies[get_local_id(0)] += q * TRILININTERPOL(cube, weights);\n"
"\n"
"			//capturing desolvation values\n"
"			atom1_typeid = dockpars_num_of_atypes+1;\n"
"\n"
"#if defined (IMPROVE_GRID)\n"
"			mul_tmp = atom1_typeid*g3;\n"
"			cube [0][0][0] = *(dockpars_fgrids + cube_000 + mul_tmp);\n"
"			cube [1][0][0] = *(dockpars_fgrids + cube_100 + mul_tmp);\n"
"      cube [0][1][0] = *(dockpars_fgrids + cube_010 + mul_tmp);\n"
"      cube [1][1][0] = *(dockpars_fgrids + cube_110 + mul_tmp);\n"
"      cube [0][0][1] = *(dockpars_fgrids + cube_001 + mul_tmp);\n"
"      cube [1][0][1] = *(dockpars_fgrids + cube_101 + mul_tmp);\n"
"      cube [0][1][1] = *(dockpars_fgrids + cube_011 + mul_tmp);\n"
"      cube [1][1][1] = *(dockpars_fgrids + cube_111 + mul_tmp);\n"
"\n"
"#else\n"
"			cube [0][0][0] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_low, y_low, x_low);\n"
"			cube [1][0][0] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_low, y_low, x_high);\n"
"			cube [0][1][0] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_low, y_high, x_low);\n"
"			cube [1][1][0] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_low, y_high, x_high);\n"
"			cube [0][0][1] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_high, y_low, x_low);\n"
"			cube [1][0][1] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_high, y_low, x_high);\n"
"			cube [0][1][1] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_high, y_high, x_low);\n"
"			cube [1][1][1] = GETGRIDVALUE(dockpars_fgrids, dockpars_gridsize_x,\n"
"						      									dockpars_gridsize_y, dockpars_gridsize_z,\n"
"						      									atom1_typeid, z_high, y_high, x_high);\n"
"#endif\n"
"\n"
"			//calculating desolvation energy\n"
"			partial_energies[get_local_id(0)] += fabs(q) * TRILININTERPOL(cube, weights);\n"
"		}\n"
"\n"
"	} // End atom1_id for-loop\n"
"\n"
"	// In paper: intermolecular and internal energy calculation\n"
"	// are independent from each other, -> NO BARRIER NEEDED\n"
"  // but require different operations,\n"
"	// thus, they can be executed only sequentially on the GPU.\n"
"\n"
"	// ================================================\n"
"	// CALCULATE INTRAMOLECULAR ENERGY\n"
"	// ================================================\n"
"	for (contributor_counter = get_local_id(0);\n"
"	     contributor_counter < dockpars_num_of_intraE_contributors;\n"
"	     contributor_counter +=NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		//getting atom IDs\n"
"		atom1_id = intraE_contributors_const[3*contributor_counter];\n"
"		atom2_id = intraE_contributors_const[3*contributor_counter+1];\n"
"\n"
"		//calculating address of first atom's coordinates\n"
"		subx = calc_coords_x[atom1_id];\n"
"		suby = calc_coords_y[atom1_id];\n"
"		subz = calc_coords_z[atom1_id];\n"
"\n"
"		//calculating address of second atom's coordinates\n"
"		subx -= calc_coords_x[atom2_id];\n"
"		suby -= calc_coords_y[atom2_id];\n"
"		subz -= calc_coords_z[atom2_id];\n"
"\n"
"		//calculating distance (distance_leo)\n"
"#if defined (NATIVE_PRECISION)\n"
"		distance_leo = native_sqrt(subx*subx + suby*suby + subz*subz)*dockpars_grid_spacing;\n"
"#elif defined (HALF_PRECISION)\n"
"		distance_leo = half_sqrt(subx*subx + suby*suby + subz*subz)*dockpars_grid_spacing;\n"
"#else	// Full precision\n"
"		distance_leo = sqrt(subx*subx + suby*suby + subz*subz)*dockpars_grid_spacing;\n"
"#endif\n"
"\n"
"		if (distance_leo < 1.0f)\n"
"			distance_leo = 1.0f;\n"
"\n"
"		//calculating energy contributions\n"
"		if ((distance_leo < 8.0f) && (distance_leo < 20.48f))\n"
"		{\n"
"			//getting type IDs\n"
"			atom1_typeid = atom_types_const[atom1_id];\n"
"			atom2_typeid = atom_types_const[atom2_id];\n"
"\n"
"			//calculating van der Waals / hydrogen bond term\n"
"#if defined (NATIVE_PRECISION)\n"
"			partial_energies[get_local_id(0)] += native_divide(VWpars_AC_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],native_powr(distance_leo,12));\n"
"#elif defined (HALF_PRECISION)\n"
"			partial_energies[get_local_id(0)] += half_divide(VWpars_AC_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],half_powr(distance_leo,12));\n"
"#else	// Full precision\n"
"			partial_energies[get_local_id(0)] += VWpars_AC_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid]/powr(distance_leo,12);\n"
"#endif\n"
"\n"
"			if (intraE_contributors_const[3*contributor_counter+2] == 1)	//H-bond\n"
"#if defined (NATIVE_PRECISION)\n"
"				partial_energies[get_local_id(0)] -= native_divide(VWpars_BD_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],native_powr(distance_leo,10));\n"
"#elif defined (HALF_PRECISION)\n"
"				partial_energies[get_local_id(0)] -= half_divide(VWpars_BD_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],half_powr(distance_leo,10));\n"
"#else	// Full precision\n"
"				partial_energies[get_local_id(0)] -= VWpars_BD_const[atom1_typeid*dockpars_num_of_atypes+atom2_typeid]/powr(distance_leo,10);\n"
"#endif\n"
"\n"
"			else	//van der Waals\n"
"#if defined (NATIVE_PRECISION)\n"
"				partial_energies[get_local_id(0)] -= native_divide(VWpars_BD_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],native_powr(distance_leo,6));\n"
"#elif defined (HALF_PRECISION)\n"
"				partial_energies[get_local_id(0)] -= half_divide(VWpars_BD_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],half_powr(distance_leo,6));\n"
"#else	// Full precision\n"
"				partial_energies[get_local_id(0)] -= VWpars_BD_const[atom1_typeid*dockpars_num_of_atypes+atom2_typeid]/powr(distance_leo,6);\n"
"#endif\n"
"\n"
"			//calculating electrostatic term\n"
"#if defined (NATIVE_PRECISION)\n"
"        partial_energies[get_local_id(0)] += native_divide (\n"
"                                                             dockpars_coeff_elec * atom_charges_const[atom1_id] * atom_charges_const[atom2_id],\n"
"                                                             distance_leo * (-8.5525f + native_divide(86.9525f,(1.0f + 7.7839f*native_exp(-0.3154f*distance_leo))))\n"
"                                                             );\n"
"#elif defined (HALF_PRECISION)\n"
"        partial_energies[get_local_id(0)] += half_divide (\n"
"                                                             dockpars_coeff_elec * atom_charges_const[atom1_id] * atom_charges_const[atom2_id],\n"
"                                                             distance_leo * (-8.5525f + half_divide(86.9525f,(1.0f + 7.7839f*half_exp(-0.3154f*distance_leo))))\n"
"                                                             );\n"
"#else	// Full precision\n"
"				partial_energies[get_local_id(0)] += dockpars_coeff_elec*atom_charges_const[atom1_id]*atom_charges_const[atom2_id]/\n"
"			                                       (distance_leo*(-8.5525f + 86.9525f/(1.0f + 7.7839f*exp(-0.3154f*distance_leo))));\n"
"#endif\n"
"\n"
"			//calculating desolvation term\n"
"#if defined (NATIVE_PRECISION)\n"
"			partial_energies[get_local_id(0)] += ((dspars_S_const[atom1_typeid] +\n"
"							       											 dockpars_qasp*fabs(atom_charges_const[atom1_id]))*dspars_V_const[atom2_typeid] +\n"
"					                      					 (dspars_S_const[atom2_typeid] +\n"
"							       								 			 dockpars_qasp*fabs(atom_charges_const[atom2_id]))*dspars_V_const[atom1_typeid]) *\n"
"					                       					 dockpars_coeff_desolv*native_exp(-distance_leo*native_divide(distance_leo,25.92f));\n"
"#elif defined (HALF_PRECISION)\n"
"			partial_energies[get_local_id(0)] += ((dspars_S_const[atom1_typeid] +\n"
"							       											 dockpars_qasp*fabs(atom_charges_const[atom1_id]))*dspars_V_const[atom2_typeid] +\n"
"					                      					 (dspars_S_const[atom2_typeid] +\n"
"							       								 			 dockpars_qasp*fabs(atom_charges_const[atom2_id]))*dspars_V_const[atom1_typeid]) *\n"
"					                       					 dockpars_coeff_desolv*half_exp(-distance_leo*half_divide(distance_leo,25.92f));\n"
"#else	// Full precision\n"
"			partial_energies[get_local_id(0)] += ((dspars_S_const[atom1_typeid] +\n"
"							       									     dockpars_qasp*fabs(atom_charges_const[atom1_id]))*dspars_V_const[atom2_typeid] +\n"
"					                      				   (dspars_S_const[atom2_typeid] +\n"
"							       								 			 dockpars_qasp*fabs(atom_charges_const[atom2_id]))*dspars_V_const[atom1_typeid]) *\n"
"					                       					 dockpars_coeff_desolv*exp(-distance_leo*distance_leo/25.92f);\n"
"#endif\n"
"\n"
"		}\n"
"	} // End contributor_counter for-loop\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	if (get_local_id(0) == 0)\n"
"	{\n"
"		*energy = partial_energies[0];\n"
"\n"
"		for (contributor_counter=1;\n"
"		     contributor_counter<NUM_OF_THREADS_PER_BLOCK;\n"
"		     contributor_counter++)\n"
"		{\n"
"			*energy += partial_energies[contributor_counter];\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gpu_calc_initpop(	char   dockpars_num_of_atoms,\n"
"			char   dockpars_num_of_atypes,\n"
"			int    dockpars_num_of_intraE_contributors,\n"
"			char   dockpars_gridsize_x,\n"
"			char   dockpars_gridsize_y,\n"
"			char   dockpars_gridsize_z,\n"
"			float  dockpars_grid_spacing,\n"
"		#if defined (RESTRICT_ARGS)\n"
"		  __global const float* restrict dockpars_fgrids, // cannot be allocated in __constant (too large)\n"
"		#else\n"
"		  __global const float* dockpars_fgrids,          // cannot be allocated in __constant (too large)\n"
"		#endif\n"
"			int    dockpars_rotbondlist_length,\n"
"			float  dockpars_coeff_elec,\n"
"			float  dockpars_coeff_desolv,\n"
"\n"
"		#if defined (RESTRICT_ARGS)\n"
"			__global const float* restrict dockpars_conformations_current,\n"
"			__global float* restrict dockpars_energies_current,\n"
"		        __global int*   restrict dockpars_evals_of_new_entities,\n"
"		#else\n"
"			__global const float* dockpars_conformations_current,\n"
"			__global float* dockpars_energies_current,\n"
"		        __global int*   dockpars_evals_of_new_entities,\n"
"		#endif\n"
"\n"
"			int    dockpars_pop_size,\n"
"			float  dockpars_qasp,\n"
"\n"
"	   __constant float* atom_charges_const,\n"
"           __constant char*  atom_types_const,\n"
"	   __constant char*  intraE_contributors_const,\n"
"           __constant float* VWpars_AC_const,\n"
"           __constant float* VWpars_BD_const,\n"
"           __constant float* dspars_S_const,\n"
"           __constant float* dspars_V_const,\n"
"           __constant int*   rotlist_const,\n"
"           __constant float* ref_coords_x_const,\n"
"           __constant float* ref_coords_y_const,\n"
"           __constant float* ref_coords_z_const,\n"
"           __constant float* rotbonds_moving_vectors_const,\n"
"           __constant float* rotbonds_unit_vectors_const,\n"
"           __constant float* ref_orientation_quats_const\n"
"){\n"
"	__local float  genotype[GENOTYPE_LENGTH_IN_GLOBMEM];\n"
"	__local float  energy;\n"
"	__local int    run_id;\n"
"\n"
"        // Some OpenCL compilers don't allow local var outside kernels\n"
"        // so this local vars are passed from a kernel\n"
"	__local float calc_coords_x[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_y[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_z[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	event_t ev = async_work_group_copy(genotype,\n"
"			                   dockpars_conformations_current + GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0),\n"
"			                   GENOTYPE_LENGTH_IN_GLOBMEM, 0);\n"
"\n"
"	wait_group_events(1,&ev);\n"
"\n"
"	//determining run ID\n"
"	if (get_local_id(0) == 0)\n"
"		run_id = get_group_id(0) / dockpars_pop_size;\n"
"\n"
"	// =============================================================\n"
"	// WARNING: only energy of work-item=0 will be valid\n"
"	gpu_calc_energy(dockpars_rotbondlist_length,\n"
"			dockpars_num_of_atoms,\n"
"			dockpars_gridsize_x,\n"
"			dockpars_gridsize_y,\n"
"			dockpars_gridsize_z,\n"
"			dockpars_fgrids,\n"
"			dockpars_num_of_atypes,\n"
"			dockpars_num_of_intraE_contributors,\n"
"			dockpars_grid_spacing,\n"
"			dockpars_coeff_elec,\n"
"			dockpars_qasp,\n"
"			dockpars_coeff_desolv,\n"
"			genotype,\n"
"			&energy,\n"
"			&run_id,\n"
"			// Some OpenCL compilers don't allow local var outside kernels\n"
"			// so this local vars are passed from a kernel\n"
"			calc_coords_x,\n"
"			calc_coords_y,\n"
"			calc_coords_z,\n"
"			partial_energies,\n"
"\n"
"	                atom_charges_const,\n"
"		        atom_types_const,\n"
"			intraE_contributors_const,\n"
"			VWpars_AC_const,\n"
"			VWpars_BD_const,\n"
"			dspars_S_const,\n"
"			dspars_V_const,\n"
"			rotlist_const,\n"
"			ref_coords_x_const,\n"
"			ref_coords_y_const,\n"
"			ref_coords_z_const,\n"
"			rotbonds_moving_vectors_const,\n"
"			rotbonds_unit_vectors_const,\n"
"			ref_orientation_quats_const);\n"
"	// =============================================================\n"
"\n"
"	if (get_local_id(0) == 0) {\n"
"		dockpars_energies_current[get_group_id(0)] = energy;\n"
"		dockpars_evals_of_new_entities[get_group_id(0)] = 1;\n"
"	}\n"
"}\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gpu_sum_evals(/*unsigned long pop_size,*/\n"
"		unsigned int pop_size,\n"
"	      /*unsigned long num_of_runs,*/\n"
"#if defined (RESTRICT_ARGS)\n"
"	      __global int* restrict dockpars_evals_of_new_entities,\n"
"              __global int* restrict evals_of_runs\n"
"#else\n"
"	      __global int* dockpars_evals_of_new_entities,\n"
"              __global int* evals_of_runs\n"
"#endif\n"
")\n"
"//The GPU global function sums the evaluation counter states\n"
"//which are stored in evals_of_new_entities array foreach entity,\n"
"//calculates the sums for each run and stores it in evals_of_runs array.\n"
"//The number of blocks which should be started equals to num_of_runs,\n"
"//since each block performs the summation for one run.\n"
"{\n"
"  int entity_counter;\n"
"  int sum_evals;\n"
"  __local int partsum_evals[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"  partsum_evals[get_local_id(0)] = 0;\n"
"\n"
"#if defined (ASYNC_COPY)\n"
"  __local int local_evals_of_new_entities[MAX_POPSIZE];	// defined in defines.h\n"
"\n"
"  async_work_group_copy(local_evals_of_new_entities,\n"
"                        dockpars_evals_of_new_entities+get_group_id(0)*pop_size,\n"
"                        pop_size,0);\n"
"\n"
"  for (entity_counter=get_local_id(0);\n"
"	     entity_counter<pop_size;\n"
"	     entity_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"       partsum_evals[get_local_id(0)] += local_evals_of_new_entities[entity_counter];\n"
"\n"
"#else\n"
"  for (entity_counter=get_local_id(0);\n"
"	     entity_counter<pop_size;\n"
"	     entity_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"       partsum_evals[get_local_id(0)] += dockpars_evals_of_new_entities[get_group_id(0)*pop_size+entity_counter];\n"
"#endif\n"
"\n"
"  barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"  if (get_local_id(0) == 0) {\n"
"    sum_evals = partsum_evals[0];\n"
"    for (entity_counter=1;\n"
"	       entity_counter<NUM_OF_THREADS_PER_BLOCK;\n"
"	       entity_counter++) {\n"
"		     sum_evals += partsum_evals[entity_counter];\n"
"    }\n"
"\n"
"    evals_of_runs[get_group_id(0)] += sum_evals;\n"
"  }\n"
"}\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"// -------------------------------------------------------\n"
"//\n"
"// -------------------------------------------------------\n"
"unsigned int gpu_rand(\n"
"			#if defined (RESTRICT_ARGS)\n"
"			__global unsigned int* restrict prng_states\n"
"			#else\n"
"			__global unsigned int* prng_states\n"
"			#endif\n"
")\n"
"//The GPU device function generates a random int\n"
"//with a linear congruential generator.\n"
"//Each thread (supposing num_of_runs*pop_size blocks and NUM_OF_THREADS_PER_BLOCK threads per block)\n"
"//has its own state which is stored in the global memory area pointed by\n"
"//prng_states (thread with ID tx in block with ID bx stores its state in prng_states[bx*NUM_OF_THREADS_PER_BLOCK+$\n"
"//The random number generator uses the gcc linear congruential generator constants.\n"
"{\n"
"  unsigned int state;\n"
"\n"
"#if defined (REPRO)\n"
"	state = 1;\n"
"#else\n"
"  //current state of the threads own PRNG\n"
"  //state = prng_states[get_group_id(0)*NUM_OF_THREADS_PER_BLOCK + get_local_id(0)];\n"
"	state = prng_states[get_global_id(0)];\n"
"\n"
"  //calculating next state\n"
"  state = (RAND_A*state+RAND_C);\n"
"#endif\n"
"  //saving next state to memory\n"
"  //prng_states[get_group_id(0)*NUM_OF_THREADS_PER_BLOCK + get_local_id(0)] = state;\n"
"	prng_states[get_global_id(0)] = state;\n"
"\n"
"  return state;\n"
"}\n"
"\n"
"// -------------------------------------------------------\n"
"//\n"
"// -------------------------------------------------------\n"
"float gpu_randf(\n"
"		#if defined (RESTRICT_ARGS)\n"
"		__global unsigned int* restrict prng_states\n"
"		#else\n"
"		__global unsigned int* prng_states\n"
"		#endif\n"
")\n"
"//The GPU device function generates a\n"
"//random float greater than (or equal to) 0 and less than 1.\n"
"//It uses gpu_rand() function.\n"
"{\n"
"  float state;\n"
"\n"
"	//state will be between 0 and 1\n"
"#if defined (REPRO)\n"
"	state = 0.55f; //0.55f;\n"
"#else\n"
"	#if defined (NATIVE_PRECISION)\n"
"	state =  native_divide(gpu_rand(prng_states),MAX_UINT)*0.999999f;\n"
"	#elif defined (HALF_PRECISION)\n"
"	state =  half_divide(gpu_rand(prng_states),MAX_UINT)*0.999999f;\n"
"	#else	// Full precision\n"
"	state = (((float) gpu_rand(prng_states))/MAX_UINT)*0.999999f;\n"
"	#endif\n"
"#endif\n"
"\n"
"  return state;\n"
"}\n"
"\n"
"// -------------------------------------------------------\n"
"//\n"
"// -------------------------------------------------------\n"
"void map_angle(__local float* angle)\n"
"//The GPU device function maps\n"
"//the input parameter to the interval 0...360\n"
"//(supposing that it is an angle).\n"
"{\n"
"  while (*angle >= 360.0f)\n"
"    *angle -= 360.0f;\n"
"\n"
"  while (*angle < 0.0f)\n"
"    *angle += 360.0f;\n"
"}\n"
"\n"
"// -------------------------------------------------------\n"
"//\n"
"// -------------------------------------------------------\n"
"void gpu_perform_elitist_selection(int    dockpars_pop_size,\n"
"\n"
"	         #if defined (RESTRICT_ARGS)\n"
"				    __global float* restrict dockpars_energies_current,\n"
"				    __global float* restrict dockpars_energies_next,\n"
"				    __global int*   restrict dockpars_evals_of_new_entities,\n"
"					#else\n"
"				    __global float* dockpars_energies_current,\n"
"				    __global float* dockpars_energies_next,\n"
"				    __global int*   dockpars_evals_of_new_entities,\n"
"					#endif\n"
"\n"
"					     int    dockpars_num_of_genes,\n"
"\n"
"					#if defined (RESTRICT_ARGS)\n"
"				    __global float* restrict dockpars_conformations_next,\n"
"		        __global const float* restrict dockpars_conformations_current\n"
"					#else\n"
"				    __global float* dockpars_conformations_next,\n"
"		        __global const float* dockpars_conformations_current\n"
"					#endif\n"
"				\n"
"					,\n"
"                    // Some OpenCL compilers don't allow local var outside kernels\n"
"                    // so this local vars are passed from a kernel\n"
"				    __local float* best_energies,\n"
"				    __local int*   best_IDs,\n"
"				    __local int*   best_ID	\n"
"\n"
"\n"
")\n"
"//The GPU device function performs elitist selection,\n"
"//that is, it looks for the best entity in conformations_current and\n"
"//energies_current of the run that corresponds to the block ID,\n"
"//and copies it to the place of the first entity in\n"
"//conformations_next and energies_next.\n"
"{\n"
"\n"
"	int entity_counter;\n"
"	int gene_counter;\n"
"	float best_energy;\n"
"\n"
"        // Some OpenCL compilers don't allow local var outside kernels\n"
"        // so this local vars are passed from a kernel\n"
"	//__local float best_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"	//__local int best_IDs[NUM_OF_THREADS_PER_BLOCK];\n"
"	//__local int best_ID;\n"
"\n"
"	if (get_local_id(0) < dockpars_pop_size)\n"
"	{\n"
"		best_energies[get_local_id(0)] = dockpars_energies_current[get_group_id(0)+get_local_id(0)];\n"
"		best_IDs[get_local_id(0)] = get_local_id(0);\n"
"	}\n"
"\n"
"	for (entity_counter=NUM_OF_THREADS_PER_BLOCK+get_local_id(0);\n"
"	     entity_counter<dockpars_pop_size;\n"
"	     entity_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"\n"
"	     if (dockpars_energies_current[get_group_id(0)+entity_counter] < best_energies[get_local_id(0)])\n"
"	     {\n"
"		best_energies[get_local_id(0)] = dockpars_energies_current[get_group_id(0)+entity_counter];\n"
"		best_IDs[get_local_id(0)] = entity_counter;\n"
"	     }\n"
"\n"
"       barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	//this could be implemented with a tree-like structure\n"
"	//which may be slightly faster\n"
"	if (get_local_id(0) == 0)\n"
"	{\n"
"		best_energy = best_energies[0];\n"
"		//best_ID = best_IDs[0];\n"
"		best_ID[0] = best_IDs[0];\n"
"\n"
"		for (entity_counter=1;\n"
"		     entity_counter<NUM_OF_THREADS_PER_BLOCK;\n"
"		     entity_counter++)\n"
"\n"
"		     if ((best_energies[entity_counter] < best_energy) && (entity_counter < dockpars_pop_size))\n"
"		     {\n"
"			      best_energy = best_energies[entity_counter];\n"
"			      //best_ID = best_IDs[entity_counter];\n"
"			      best_ID[0] = best_IDs[entity_counter];\n"
"		     }\n"
"\n"
"		//setting energy value of new entity\n"
"		dockpars_energies_next[get_group_id(0)] = best_energy;\n"
"\n"
"		//0 evals were performed for entity selected with elitism (since it was copied only)\n"
"		dockpars_evals_of_new_entities[get_group_id(0)] = 0;\n"
"	}\n"
"\n"
"	//now best_id stores the id of the best entity in the population,\n"
"	//copying genotype and energy value to the first entity of new population\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	for (gene_counter=get_local_id(0);\n"
"	     gene_counter<dockpars_num_of_genes;\n"
"	     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"	     //dockpars_conformations_next[GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0)+gene_counter] = dockpars_conformations_current[GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0)+GENOTYPE_LENGTH_IN_GLOBMEM*best_ID+gene_counter];\n"
"	     dockpars_conformations_next[GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0)+gene_counter] = dockpars_conformations_current[GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0)+GENOTYPE_LENGTH_IN_GLOBMEM*best_ID[0]+gene_counter];\n"
"}\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"perform_LS(	char   dockpars_num_of_atoms,\n"
"		char   dockpars_num_of_atypes,\n"
"		int    dockpars_num_of_intraE_contributors,\n"
"		char   dockpars_gridsize_x,\n"
"		char   dockpars_gridsize_y,\n"
"		char   dockpars_gridsize_z,\n"
"		float  dockpars_grid_spacing,\n"
"\n"
"		#if defined (RESTRICT_ARGS)\n"
"  __global const float* restrict dockpars_fgrids, // cannot be allocated in __constant (too large)\n"
"		#else\n"
"  __global const float* dockpars_fgrids,          // cannot be allocated in __constant (too large)\n"
"		#endif\n"
"\n"
"	        int    dockpars_rotbondlist_length,\n"
"		float  dockpars_coeff_elec,\n"
"		float  dockpars_coeff_desolv,\n"
"\n"
"		#if defined (RESTRICT_ARGS)\n"
"  __global float* restrict dockpars_conformations_next,\n"
"  __global float* restrict dockpars_energies_next,\n"
"  __global int*   restrict dockpars_evals_of_new_entities,\n"
"  __global unsigned int* restrict dockpars_prng_states,\n"
"		#else\n"
"  __global float* dockpars_conformations_next,\n"
"  __global float* dockpars_energies_next,\n"
"  __global int*   dockpars_evals_of_new_entities,\n"
"  __global unsigned int* dockpars_prng_states,\n"
"		#endif\n"
"\n"
"		int    dockpars_pop_size,\n"
"		int    dockpars_num_of_genes,\n"
"		float  dockpars_lsearch_rate,\n"
"		unsigned int dockpars_num_of_lsentities,\n"
"		float  dockpars_rho_lower_bound,\n"
"		float  dockpars_base_dmov_mul_sqrt3,\n"
"		float  dockpars_base_dang_mul_sqrt3,\n"
"		unsigned int dockpars_cons_limit,\n"
"		unsigned int dockpars_max_num_of_iters,\n"
"		float  dockpars_qasp,\n"
"\n"
"	  __constant float* atom_charges_const,\n"
"          __constant char*  atom_types_const,\n"
"	  __constant char*  intraE_contributors_const,\n"
"          __constant float* VWpars_AC_const,\n"
"          __constant float* VWpars_BD_const,\n"
"          __constant float* dspars_S_const,\n"
"          __constant float* dspars_V_const,\n"
"          __constant int*   rotlist_const,\n"
"          __constant float* ref_coords_x_const,\n"
"          __constant float* ref_coords_y_const,\n"
"          __constant float* ref_coords_z_const,\n"
"          __constant float* rotbonds_moving_vectors_const,\n"
"          __constant float* rotbonds_unit_vectors_const,\n"
"          __constant float* ref_orientation_quats_const\n"
")\n"
"//The GPU global function performs local search on the pre-defined entities of conformations_next.\n"
"//The number of blocks which should be started equals to num_of_lsentities*num_of_runs.\n"
"//This way the first num_of_lsentities entity of each population will be subjected to local search\n"
"//(and each block carries out the algorithm for one entity).\n"
"//Since the first entity is always the best one in the current population,\n"
"//it is always tested according to the ls probability, and if it not to be\n"
"//subjected to local search, the entity with ID num_of_lsentities is selected instead of the first one (with ID 0).\n"
"{\n"
"	__local float genotype_candidate[ACTUAL_GENOTYPE_LENGTH];\n"
"	__local float genotype_deviate  [ACTUAL_GENOTYPE_LENGTH];\n"
"	__local float genotype_bias     [ACTUAL_GENOTYPE_LENGTH];\n"
"        __local float rho;\n"
"	__local int   cons_succ;\n"
"	__local int   cons_fail;\n"
"	__local int   iteration_cnt;\n"
"	__local float candidate_energy;\n"
"	__local int   evaluation_cnt;\n"
"	int gene_counter;\n"
"\n"
"	__local float offspring_genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"	__local int run_id;\n"
"	__local int entity_id;\n"
"	__local float offspring_energy;\n"
"\n"
"        // Some OpenCL compilers don't allow local var outside kernels\n"
"        // so this local vars are passed from a kernel\n"
"	__local float calc_coords_x[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_y[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_z[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	//determining run ID and entity ID, initializing\n"
"	if (get_local_id(0) == 0)\n"
"	{\n"
"		run_id = get_group_id(0) / dockpars_num_of_lsentities;\n"
"		entity_id = get_group_id(0) % dockpars_num_of_lsentities;\n"
"\n"
"		//since entity 0 is the best one due to elitism, should be subjected to random selection\n"
"		if (entity_id == 0)\n"
"			if (100.0f*gpu_randf(dockpars_prng_states) > dockpars_lsearch_rate)\n"
"				entity_id = dockpars_num_of_lsentities;	//if entity 0 is not selected according to LS rate,\n"
"									//choosing an other entity\n"
"\n"
"		offspring_energy = dockpars_energies_next[run_id*dockpars_pop_size+entity_id];\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"#if defined (ASYNC_COPY)\n"
"  async_work_group_copy(offspring_genotype,\n"
"			dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"                        dockpars_num_of_genes,0);\n"
"#else\n"
"	for (gene_counter=get_local_id(0);\n"
"	     gene_counter<dockpars_num_of_genes;\n"
"	     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"		   offspring_genotype[gene_counter] = dockpars_conformations_next[(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"#endif\n"
"\n"
"	for (gene_counter=get_local_id(0);\n"
"	     gene_counter<dockpars_num_of_genes;\n"
"	     gene_counter += NUM_OF_THREADS_PER_BLOCK)\n"
"		   genotype_bias[gene_counter] = 0.0f;\n"
"\n"
"	if (get_local_id(0) == 0) {\n"
"		rho = 1.0f;\n"
"		cons_succ = 0;\n"
"		cons_fail = 0;\n"
"		iteration_cnt = 0;\n"
"		evaluation_cnt = 0;\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	while ((iteration_cnt < dockpars_max_num_of_iters) && (rho > dockpars_rho_lower_bound))\n"
"	{\n"
"		//new random deviate\n"
"		for (gene_counter=get_local_id(0);\n"
"		     gene_counter<dockpars_num_of_genes;\n"
"		     gene_counter += NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			genotype_deviate[gene_counter] = rho*(2*gpu_randf(dockpars_prng_states)-1);\n"
"\n"
"			if (gene_counter < 3)\n"
"				genotype_deviate[gene_counter] *= dockpars_base_dmov_mul_sqrt3;\n"
"			else\n"
"				genotype_deviate[gene_counter] *= dockpars_base_dang_mul_sqrt3;\n"
"		}\n"
"\n"
"		//generating new genotype candidate\n"
"		for (gene_counter=get_local_id(0);\n"
"		     gene_counter<dockpars_num_of_genes;\n"
"		     gene_counter += NUM_OF_THREADS_PER_BLOCK)\n"
"			   genotype_candidate[gene_counter] = offspring_genotype[gene_counter] + genotype_deviate[gene_counter] + genotype_bias[gene_counter];\n"
"\n"
"		//evaluating candidate\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// ==================================================================\n"
"		gpu_calc_energy(dockpars_rotbondlist_length,\n"
"				dockpars_num_of_atoms,\n"
"				dockpars_gridsize_x,\n"
"				dockpars_gridsize_y,\n"
"				dockpars_gridsize_z,\n"
"				dockpars_fgrids,\n"
"				dockpars_num_of_atypes,\n"
"				dockpars_num_of_intraE_contributors,\n"
"				dockpars_grid_spacing,\n"
"				dockpars_coeff_elec,\n"
"				dockpars_qasp,\n"
"				dockpars_coeff_desolv,\n"
"				genotype_candidate,\n"
"				&candidate_energy,\n"
"				&run_id,\n"
"				// Some OpenCL compilers don't allow local var outside kernels\n"
"				// so this local vars are passed from a kernel\n"
"				calc_coords_x,\n"
"				calc_coords_y,\n"
"				calc_coords_z,\n"
"				partial_energies,\n"
"\n"
"				atom_charges_const,\n"
"				atom_types_const,\n"
"				intraE_contributors_const,\n"
"				VWpars_AC_const,\n"
"				VWpars_BD_const,\n"
"				dspars_S_const,\n"
"				dspars_V_const,\n"
"				rotlist_const,\n"
"				ref_coords_x_const,\n"
"				ref_coords_y_const,\n"
"				ref_coords_z_const,\n"
"				rotbonds_moving_vectors_const,\n"
"				rotbonds_unit_vectors_const,\n"
"				ref_orientation_quats_const);\n"
"		// =================================================================\n"
"\n"
"		if (get_local_id(0) == 0)\n"
"			evaluation_cnt++;\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (candidate_energy < offspring_energy)	//if candidate is better, success\n"
"		{\n"
"			for (gene_counter=get_local_id(0);\n"
"			     gene_counter<dockpars_num_of_genes;\n"
"			     gene_counter += NUM_OF_THREADS_PER_BLOCK)\n"
"			{\n"
"				//updating offspring_genotype\n"
"				offspring_genotype[gene_counter] = genotype_candidate[gene_counter];\n"
"\n"
"				//updating genotype_bias\n"
"				genotype_bias[gene_counter] = 0.6f*genotype_bias[gene_counter] + 0.4f*genotype_deviate[gene_counter];\n"
"			}\n"
"\n"
"			//thread 0 will overwrite the shared variables\n"
"			//used in the previous if condition,\n"
"			//all threads have to be after if\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			if (get_local_id(0) == 0)\n"
"			{\n"
"				offspring_energy = candidate_energy;\n"
"				cons_succ++;\n"
"				cons_fail = 0;\n"
"			}\n"
"		}\n"
"		else	//if candidate is worser, check the opposite direction\n"
"		{\n"
"			//generating the other genotype candidate\n"
"			for (gene_counter=get_local_id(0);\n"
"			     gene_counter<dockpars_num_of_genes;\n"
"			     gene_counter += NUM_OF_THREADS_PER_BLOCK)\n"
"				   genotype_candidate[gene_counter] = offspring_genotype[gene_counter] - genotype_deviate[gene_counter] - genotype_bias[gene_counter];\n"
"\n"
"			//evaluating candidate\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			// =================================================================\n"
"			gpu_calc_energy(dockpars_rotbondlist_length,\n"
"					dockpars_num_of_atoms,\n"
"					dockpars_gridsize_x,\n"
"					dockpars_gridsize_y,\n"
"					dockpars_gridsize_z,\n"
"					dockpars_fgrids,\n"
"					dockpars_num_of_atypes,\n"
"					dockpars_num_of_intraE_contributors,\n"
"					dockpars_grid_spacing,\n"
"					dockpars_coeff_elec,\n"
"				        dockpars_qasp,\n"
"					dockpars_coeff_desolv,\n"
"					genotype_candidate,\n"
"					&candidate_energy,\n"
"					&run_id,\n"
"		                        // Some OpenCL compilers don't allow local var outside kernels\n"
"					// so this local vars are passed from a kernel\n"
"					calc_coords_x,\n"
"					calc_coords_y,\n"
"					calc_coords_z,\n"
"					partial_energies,\n"
"\n"
"					atom_charges_const,\n"
"					atom_types_const,\n"
"					intraE_contributors_const,\n"
"					VWpars_AC_const,\n"
"					VWpars_BD_const,\n"
"					dspars_S_const,\n"
"					dspars_V_const,\n"
"					rotlist_const,\n"
"					ref_coords_x_const,\n"
"					ref_coords_y_const,\n"
"					ref_coords_z_const,\n"
"					rotbonds_moving_vectors_const,\n"
"					rotbonds_unit_vectors_const,\n"
"					ref_orientation_quats_const);\n"
"			// =================================================================\n"
"\n"
"			if (get_local_id(0) == 0)\n"
"				evaluation_cnt++;\n"
"\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			if (candidate_energy < offspring_energy)//if candidate is better, success\n"
"			{\n"
"				for (gene_counter=get_local_id(0);\n"
"				     gene_counter<dockpars_num_of_genes;\n"
"			       gene_counter += NUM_OF_THREADS_PER_BLOCK)\n"
"				{\n"
"					//updating offspring_genotype\n"
"					offspring_genotype[gene_counter] = genotype_candidate[gene_counter];\n"
"\n"
"					//updating genotype_bias\n"
"					genotype_bias[gene_counter] = 0.6f*genotype_bias[gene_counter] - 0.4f*genotype_deviate[gene_counter];\n"
"				}\n"
"\n"
"				//thread 0 will overwrite the shared variables\n"
"				//used in the previous if condition,\n"
"				//all threads have to be after if\n"
"				barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"				if (get_local_id(0) == 0)\n"
"				{\n"
"					offspring_energy = candidate_energy;\n"
"					cons_succ++;\n"
"					cons_fail = 0;\n"
"				}\n"
"			}\n"
"			else	//failure in both directions\n"
"			{\n"
"				for (gene_counter=get_local_id(0);\n"
"				     gene_counter<dockpars_num_of_genes;\n"
"				     gene_counter += NUM_OF_THREADS_PER_BLOCK)\n"
"					   //updating genotype_bias\n"
"					   genotype_bias[gene_counter] = 0.5f*genotype_bias[gene_counter];\n"
"\n"
"				if (get_local_id(0) == 0)\n"
"				{\n"
"					cons_succ = 0;\n"
"					cons_fail++;\n"
"				}\n"
"			}\n"
"		}\n"
"\n"
"		//changing rho if needed\n"
"		if (get_local_id(0) == 0)\n"
"		{\n"
"			iteration_cnt++;\n"
"\n"
"			if (cons_succ >= dockpars_cons_limit)\n"
"			{\n"
"				rho *= LS_EXP_FACTOR;\n"
"				cons_succ = 0;\n"
"			}\n"
"			else\n"
"				if (cons_fail >= dockpars_cons_limit)\n"
"				{\n"
"					rho *= LS_CONT_FACTOR;\n"
"					cons_fail = 0;\n"
"				}\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"	}\n"
"\n"
"	//updating eval counter and energy\n"
"	if (get_local_id(0) == 0)\n"
"	{\n"
"		dockpars_evals_of_new_entities[run_id*dockpars_pop_size+entity_id] += evaluation_cnt;\n"
"		dockpars_energies_next[run_id*dockpars_pop_size+entity_id] = offspring_energy;\n"
"	}\n"
"\n"
"	//mapping angles\n"
"	for (gene_counter=get_local_id(0);\n"
"	     gene_counter<dockpars_num_of_genes;\n"
"	     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"		   if (gene_counter >=  3)\n"
"			    map_angle(&(offspring_genotype[gene_counter]));\n"
"\n"
"	//updating old offspring in population\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"#if defined (ASYNC_COPY)\n"
"  async_work_group_copy(dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"                        offspring_genotype,\n"
"                        dockpars_num_of_genes,0);\n"
"#else\n"
"	for (gene_counter=get_local_id(0);\n"
"	     gene_counter<dockpars_num_of_genes;\n"
"       gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"		   dockpars_conformations_next[(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter] = offspring_genotype[gene_counter];\n"
"#endif\n"
"}\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gpu_gen_and_eval_newpops(char   dockpars_num_of_atoms,\n"
"			 char   dockpars_num_of_atypes,\n"
"			 int    dockpars_num_of_intraE_contributors,\n"
"			 char   dockpars_gridsize_x,\n"
"			 char   dockpars_gridsize_y,\n"
"			 char   dockpars_gridsize_z,\n"
"			 float  dockpars_grid_spacing,\n"
"\n"
"			#if defined (RESTRICT_ARGS)\n"
" __global const float* restrict dockpars_fgrids, // cannot be allocated in __constant (too large)\n"
"			#else\n"
" __global const float* dockpars_fgrids, // cannot be allocated in __constant (too large)\n"
"			#endif\n"
"\n"
"	                int    dockpars_rotbondlist_length,\n"
"			float  dockpars_coeff_elec,\n"
"			float  dockpars_coeff_desolv,\n"
"\n"
"			#if defined (RESTRICT_ARGS)\n"
" __global const float* restrict  dockpars_conformations_current,\n"
" __global float* restrict  dockpars_energies_current,\n"
" __global float* restrict  dockpars_conformations_next,\n"
" __global float* restrict  dockpars_energies_next,\n"
" __global int*   restrict  dockpars_evals_of_new_entities,\n"
" __global unsigned int* restrict dockpars_prng_states,\n"
"			#else\n"
" __global const float*  dockpars_conformations_current,\n"
" __global float*        dockpars_energies_current,\n"
" __global float*        dockpars_conformations_next,\n"
" __global float*        dockpars_energies_next,\n"
" __global int*          dockpars_evals_of_new_entities,\n"
" __global unsigned int* dockpars_prng_states,\n"
"			#endif\n"
"\n"
"	                int    dockpars_pop_size,\n"
"	                int    dockpars_num_of_genes,\n"
"		        float  dockpars_tournament_rate,\n"
"	                float  dockpars_crossover_rate,\n"
"		        float  dockpars_mutation_rate,\n"
"		        float  dockpars_abs_max_dmov,\n"
"		        float  dockpars_abs_max_dang,\n"
"		        float  dockpars_qasp,\n"
"\n"
"	      __constant float* atom_charges_const,\n"
"              __constant char*  atom_types_const,\n"
"	      __constant char*  intraE_contributors_const,\n"
"              __constant float* VWpars_AC_const,\n"
"              __constant float* VWpars_BD_const,\n"
"              __constant float* dspars_S_const,\n"
"              __constant float* dspars_V_const,\n"
"              __constant int*   rotlist_const,\n"
"              __constant float* ref_coords_x_const,\n"
"              __constant float* ref_coords_y_const,\n"
"              __constant float* ref_coords_z_const,\n"
"              __constant float* rotbonds_moving_vectors_const,\n"
"              __constant float* rotbonds_unit_vectors_const,\n"
"              __constant float* ref_orientation_quats_const\n"
")\n"
"//The GPU global function\n"
"{\n"
"	__local float offspring_genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"	__local int parent_candidates[4];\n"
"	__local float candidate_energies[4];\n"
"	__local int parents[2];\n"
"	__local int run_id;\n"
"	__local int covr_point[2];\n"
"	__local float randnums[10];\n"
"	int temp_covr_point;\n"
"	int gene_counter;\n"
"	__local float energy;	//could be shared since only thread 0 will use it\n"
"\n"
"\n"
"        // Some OpenCL compilers don't allow local var outside kernels\n"
"        // so this local vars are passed from a kernel\n"
"	__local float best_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"	__local int best_IDs[NUM_OF_THREADS_PER_BLOCK];\n"
"        __local int best_ID[1]; //__local int best_ID;\n"
"\n"
"        // Some OpenCL compilers don't allow local var outside kernels\n"
"        // so this local vars are passed from a kernel\n"
"	__local float calc_coords_x[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_y[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_z[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	//in this case this block is responsible for elitist selection\n"
"	if ((get_group_id(0) % dockpars_pop_size) == 0)\n"
"		gpu_perform_elitist_selection(dockpars_pop_size,\n"
"					      dockpars_energies_current,\n"
"					      dockpars_energies_next,\n"
"					      dockpars_evals_of_new_entities,\n"
"					      dockpars_num_of_genes,\n"
"					      dockpars_conformations_next,\n"
"				              dockpars_conformations_current\n"
"					      ,\n"
"					      best_energies,\n"
"					      best_IDs,\n"
"					      best_ID);\n"
"	else\n"
"	{\n"
"		//generating the following random numbers: [0..3] for parent candidates,\n"
"		//[4..5] for binary tournaments, [6] for deciding crossover,\n"
"		//[7..8] for crossover points, [9] for local search\n"
"\n"
"		for (gene_counter=get_local_id(0);\n"
"		     gene_counter<10;\n"
"		     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"			   randnums[gene_counter] = gpu_randf(dockpars_prng_states);\n"
"\n"
"		//determining run ID\n"
"		if (get_local_id(0) == 0)\n"
"			run_id = get_group_id(0) / dockpars_pop_size;\n"
"\n"
"		//performing binary tournament selection\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (get_local_id(0) < 4)	//it is not ensured that the four candidates will be different...\n"
"		{\n"
"			parent_candidates[get_local_id(0)] = (int) (dockpars_pop_size*randnums[get_local_id(0)]); //using randnums[0..3]\n"
"			candidate_energies[get_local_id(0)] = dockpars_energies_current[run_id*dockpars_pop_size+parent_candidates[get_local_id(0)]];\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (get_local_id(0) < 2)\n"
"		{\n"
"			if (candidate_energies[2*get_local_id(0)] < candidate_energies[2*get_local_id(0)+1])\n"
"				if (100.0f*randnums[4+get_local_id(0)] < dockpars_tournament_rate)		//using randnum[4..5]\n"
"					parents[get_local_id(0)] = parent_candidates[2*get_local_id(0)];\n"
"				else\n"
"					parents[get_local_id(0)] = parent_candidates[2*get_local_id(0)+1];\n"
"			else\n"
"				if (100.0f*randnums[4+get_local_id(0)] < dockpars_tournament_rate)\n"
"					parents[get_local_id(0)] = parent_candidates[2*get_local_id(0)+1];\n"
"				else\n"
"					parents[get_local_id(0)] = parent_candidates[2*get_local_id(0)];\n"
"		}\n"
"\n"
"		//performing crossover\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (100.0f*randnums[6] < dockpars_crossover_rate)	//using randnums[6]\n"
"		{\n"
"			if (get_local_id(0) < 2)\n"
"				//using randnum[7..8]\n"
"				covr_point[get_local_id(0)] = (int) ((dockpars_num_of_genes-1)*randnums[7+get_local_id(0)]);\n"
"\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"			if (get_local_id(0) == 0)	//covr_point[0] should store the lower crossover-point\n"
"				if (covr_point[1] < covr_point[0])\n"
"				{\n"
"					temp_covr_point = covr_point[1];\n"
"					covr_point[1] = covr_point[0];\n"
"					covr_point[0] = temp_covr_point;\n"
"				}\n"
"\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			for (gene_counter=get_local_id(0);\n"
"			     gene_counter<dockpars_num_of_genes;\n"
"			     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"			{\n"
"				if (covr_point[0] != covr_point[1])	//two-point crossover\n"
"					if ((gene_counter <= covr_point[0]) || (gene_counter > covr_point[1]))\n"
"						offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[0])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"					else\n"
"						offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[1])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"				else									             //single-point crossover\n"
"					if (gene_counter <= covr_point[0])\n"
"						offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[0])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"					else\n"
"						offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[1])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"			}\n"
"\n"
"		}\n"
"		else	//no crossover\n"
"		{\n"
"#if defined (ASYNC_COPY)\n"
"			async_work_group_copy(offspring_genotype,\n"
"					     dockpars_conformations_current+(run_id*dockpars_pop_size+parents[0])*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"					     dockpars_num_of_genes,0);\n"
"\n"
"#else\n"
"			for (gene_counter=get_local_id(0);\n"
"			     gene_counter<dockpars_num_of_genes;\n"
"			     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"				   offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[0])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"#endif\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		//performing mutation\n"
"		for (gene_counter=get_local_id(0);\n"
"		     gene_counter<dockpars_num_of_genes;\n"
"		     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			if (100.0f*gpu_randf(dockpars_prng_states) < dockpars_mutation_rate)\n"
"			{\n"
"				if (gene_counter < 3)\n"
"					offspring_genotype[gene_counter] += dockpars_abs_max_dmov*(2*gpu_randf(dockpars_prng_states)-1);\n"
"				else\n"
"				{\n"
"					offspring_genotype[gene_counter] += dockpars_abs_max_dang*(2*gpu_randf(dockpars_prng_states)-1);\n"
"					map_angle(&(offspring_genotype[gene_counter]));\n"
"				}\n"
"			}\n"
"		}\n"
"\n"
"		//calculating energy of new offspring\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// =============================================================\n"
"		//WARNING: only energy of work-item=0 will be valid\n"
"		gpu_calc_energy(dockpars_rotbondlist_length,\n"
"				dockpars_num_of_atoms,\n"
"				dockpars_gridsize_x,\n"
"				dockpars_gridsize_y,\n"
"	                        dockpars_gridsize_z,\n"
"				dockpars_fgrids,\n"
"				dockpars_num_of_atypes,\n"
"				dockpars_num_of_intraE_contributors,\n"
"				dockpars_grid_spacing,\n"
"				dockpars_coeff_elec,\n"
"                                dockpars_qasp,\n"
"				dockpars_coeff_desolv,\n"
"				offspring_genotype,\n"
"				&energy,\n"
"				&run_id,\n"
"				// Some OpenCL compilers don't allow local var outside kernels\n"
"				// so this local vars are passed from a kernel\n"
"				calc_coords_x,\n"
"				calc_coords_y,\n"
"				calc_coords_z,\n"
"				partial_energies,\n"
"		\n"
"                                atom_charges_const,\n"
"	                        atom_types_const,\n"
"				intraE_contributors_const,\n"
"				VWpars_AC_const,\n"
"				VWpars_BD_const,\n"
"				dspars_S_const,\n"
"				dspars_V_const,\n"
"				rotlist_const,\n"
"				ref_coords_x_const,\n"
"				ref_coords_y_const,\n"
"				ref_coords_z_const,\n"
"				rotbonds_moving_vectors_const,\n"
"				rotbonds_unit_vectors_const,\n"
"				ref_orientation_quats_const);\n"
"		// =============================================================\n"
"\n"
"		if (get_local_id(0) == 0) {\n"
"			dockpars_evals_of_new_entities[get_group_id(0)] = 1;\n"
"		}\n"
"\n"
"		if (get_local_id(0) == 0) {\n"
"			dockpars_energies_next[get_group_id(0)] = energy;\n"
"		}\n"
"\n"
"		//copying new offspring to next generation\n"
"#if defined (ASYNC_COPY)\n"
"		async_work_group_copy(dockpars_conformations_next + GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0),\n"
"				      offspring_genotype,\n"
"				      dockpars_num_of_genes,0);\n"
"#else\n"
"		for (gene_counter=get_local_id(0);\n"
"		     gene_counter<dockpars_num_of_genes;\n"
"		     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"			   dockpars_conformations_next[GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0)+gene_counter] = offspring_genotype[gene_counter];\n"
"#endif\n"
"  }\n"
"}\n"
;
#endif // End of STRINGIFY_H

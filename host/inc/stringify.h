// OCLADOCK: AUTOMATICALLY GENERATED FILE, DO NOT EDIT
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *calcenergy_ocl =
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"#ifndef DEFINES_H_\n"
"#define DEFINES_H_\n"
"\n"
"#if defined (N16WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 16\n"
"#elif defined (N32WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 32\n"
"#elif defined (N64WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 64\n"
"#elif defined (N128WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 128\n"
"#elif defined (N256WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 256\n"
"#else\n"
"	#define NUM_OF_THREADS_PER_BLOCK 64\n"
"#endif\n"
"\n"
"#define MAX_NUM_OF_ATOMS 	100 // TODO: optimize local arrays in gradient calc to increase this constant up to 256\n"
"#define MAX_NUM_OF_ATYPES 	14\n"
"#define MAX_NUM_OF_ROTBONDS 	32\n"
"#define MAX_INTRAE_CONTRIBUTORS (MAX_NUM_OF_ATOMS * MAX_NUM_OF_ATOMS)\n"
"#define MAX_NUM_OF_ROTATIONS 	(MAX_NUM_OF_ATOMS * MAX_NUM_OF_ROTBONDS)\n"
"#define MAX_POPSIZE 		2048\n"
"#define MAX_NUM_OF_RUNS 	1000\n"
"\n"
"// Must be bigger than MAX_NUM_OF_ROTBONDS+6\n"
"#define GENOTYPE_LENGTH_IN_GLOBMEM 64\n"
"#define ACTUAL_GENOTYPE_LENGTH	(MAX_NUM_OF_ROTBONDS+6)\n"
"\n"
"#define LS_EXP_FACTOR 		2.0f\n"
"#define LS_CONT_FACTOR 		0.5f\n"
"\n"
"// Improvements over Pechan's implementation\n"
"//#define NATIVE_PRECISION\n"
"#define MAPPED_COPY\n"
"\n"
"//#define GRADIENT_ENABLED\n"
"\n"
"#endif /* DEFINES_H_ */\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"#ifndef CALCENERGY_BASIC_H_\n"
"#define CALCENERGY_BASIC_H_\n"
"\n"
"\n"
"#define RLIST_ATOMID_MASK 	0x000000FF\n"
"#define RLIST_RBONDID_MASK 	0x0000FF00\n"
"#define RLIST_RBONDID_SHIFT  	8\n"
"#define RLIST_FIRSTROT_MASK  	0x00010000\n"
"#define RLIST_GENROT_MASK 	0x00020000\n"
"#define RLIST_DUMMY_MASK 	0x00040000\n"
"#define DEG_TO_RAD 		0.0174533f\n"
"\n"
"// LCG: linear congruential generator constants\n"
"#define RAND_A 			1103515245u\n"
"#define RAND_C 			12345u\n"
"// WARNING: it is supposed that unsigned int is 32 bit long\n"
"#define MAX_UINT 		4294967296.0f\n"
"\n"
"// Macro for capturing grid values\n"
"	// Original\n"
"	#define GETGRIDVALUE(mempoi,gridsize_x,gridsize_y,gridsize_z,t,z,y,x)   *(mempoi + gridsize_x*(y + gridsize_y*(z + gridsize_z*t)) + x)\n"
"\n"
"	// Optimization 1\n"
"	// #define GETGRIDVALUE_OPT(mempoi,gridsize_x,gridsize_y,mul_tmp,z,y,x)   *(mempoi + gridsize_x*(y + gridsize_y*(z + mul_tmp)) + x)\n"
"\n"
"	// Optimization 2\n"
"	// Implemented direclty in the kernel code: calcenergy_fourkernels_intel.cl\n"
"\n"
"// Macro for trilinear interpolation\n"
"#define TRILININTERPOL(cube, weights) (cube[0][0][0]*weights[0][0][0] +cube[1][0][0]*weights[1][0][0] +	\\\n"
"				       cube[0][1][0]*weights[0][1][0] +cube[1][1][0]*weights[1][1][0] + \\\n"
"				       cube[0][0][1]*weights[0][0][1] +cube[1][0][1]*weights[1][0][1] + \\\n"
"				       cube[0][1][1]*weights[0][1][1] +cube[1][1][1]*weights[1][1][1])\n"
"\n"
"// Constants for dielelectric term of the \n"
"// electrostatic component of the intramolecular energy/gradient\n"
"#define DIEL_A 			-8.5525f\n"
"#define DIEL_WAT 		78.4f\n"
"#define DIEL_B 			(DIEL_WAT - DIEL_A)\n"
"#define DIEL_LAMBDA		0.003627f\n"
"#define DIEL_H			DIEL_LAMBDA\n"
"#define DIEL_K			7.7839f\n"
"#define DIEL_B_TIMES_H		(DIEL_B*DIEL_H)\n"
"#define DIEL_B_TIMES_H_TIMES_K	(DIEL_B_TIMES_H*DIEL_K)\n"
"\n"
"// Used for Shoemake to quternion transformation\n"
"#define PI_TIMES_2 (float)(2.0f*M_PI)\n"
"\n"
"\n"
"\n"
"#endif /* CALCENERGY_BASIC_H_ */\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"//#define DEBUG_ENERGY_KERNEL1\n"
"//#define DEBUG_ENERGY_KERNEL4\n"
"//#define DEBUG_ENERGY_KERNEL3\n"
"\n"
"\n"
"// All related pragmas are in defines.h (accesible by host and device code)\n"
"\n"
"void gpu_calc_energy(	    \n"
"				int    dockpars_rotbondlist_length,\n"
"				char   dockpars_num_of_atoms,\n"
"			    	char   dockpars_gridsize_x,\n"
"			    	char   dockpars_gridsize_y,\n"
"			    	char   dockpars_gridsize_z,\n"
"		 __global const float* restrict dockpars_fgrids, // This is too large to be allocated in __constant \n"
"		            	char   dockpars_num_of_atypes,\n"
"		            	int    dockpars_num_of_intraE_contributors,\n"
"			    	float  dockpars_grid_spacing,\n"
"			    	float  dockpars_coeff_elec,\n"
"			    	float  dockpars_qasp,\n"
"			    	float  dockpars_coeff_desolv,\n"
"\n"
"                    // Some OpenCL compilers don't allow declaring \n"
"		    // local variables within non-kernel functions.\n"
"		    // These local variables must be declared in a kernel, \n"
"		    // and then passed to non-kernel functions.\n"
"		    	__local float* genotype,\n"
"		   	__local float* energy,\n"
"		    	__local int*   run_id,\n"
"\n"
"		    	__local float* calc_coords_x,\n"
"		    	__local float* calc_coords_y,\n"
"		    	__local float* calc_coords_z,\n"
"		    	__local float* partial_energies,\n"
"\n"
"			#if defined (DEBUG_ENERGY_KERNEL1) || defined (DEBUG_ENERGY_KERNEL4) || defined (DEBUG_ENERGY_KERNEL3)\n"
"			__local float* partial_interE,\n"
"			__local float* partial_intraE,\n"
"			#endif\n"
"\n"
"	             __constant float* atom_charges_const,\n"
"                     __constant char*  atom_types_const,\n"
"                     __constant char*  intraE_contributors_const,\n"
"                     __constant float* VWpars_AC_const,\n"
"                     __constant float* VWpars_BD_const,\n"
"                     __constant float* dspars_S_const,\n"
"                     __constant float* dspars_V_const,\n"
"                     __constant int*   rotlist_const,\n"
"                     __constant float* ref_coords_x_const,\n"
"                     __constant float* ref_coords_y_const,\n"
"                     __constant float* ref_coords_z_const,\n"
"                     __constant float* rotbonds_moving_vectors_const,\n"
"                     __constant float* rotbonds_unit_vectors_const,\n"
"                     __constant float* ref_orientation_quats_const\n"
")\n"
"\n"
"//The GPU device function calculates the energy of the entity described by genotype, dockpars and the liganddata\n"
"//arrays in constant memory and returns it in the energy parameter. The parameter run_id has to be equal to the ID\n"
"//of the run whose population includes the current entity (which can be determined with blockIdx.x), since this\n"
"//determines which reference orientation should be used.\n"
"{\n"
"	partial_energies[get_local_id(0)] = 0.0f;\n"
"\n"
"	#if defined (DEBUG_ENERGY_KERNEL1) || defined (DEBUG_ENERGY_KERNEL4) || defined (DEBUG_ENERGY_KERNEL3)\n"
"	partial_interE[get_local_id(0)] = 0.0f;\n"
"	partial_intraE[get_local_id(0)] = 0.0f;\n"
"	#endif\n"
"\n"
"	uchar g1 = dockpars_gridsize_x;\n"
"	uint  g2 = dockpars_gridsize_x * dockpars_gridsize_y;\n"
"  	uint  g3 = dockpars_gridsize_x * dockpars_gridsize_y * dockpars_gridsize_z;\n"
"\n"
"\n"
"	// ================================================\n"
"	// CALCULATING ATOMIC POSITIONS AFTER ROTATIONS\n"
"	// ================================================\n"
"	for (uint rotation_counter = get_local_id(0);\n"
"	          rotation_counter < dockpars_rotbondlist_length;\n"
"	          rotation_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		int rotation_list_element = rotlist_const[rotation_counter];\n"
"\n"
"		if ((rotation_list_element & RLIST_DUMMY_MASK) == 0)	// If not dummy rotation\n"
"		{\n"
"			uint atom_id = rotation_list_element & RLIST_ATOMID_MASK;\n"
"\n"
"			// Capturing atom coordinates\n"
"			float atom_to_rotate[3];\n"
"\n"
"			if ((rotation_list_element & RLIST_FIRSTROT_MASK) != 0)	// If first rotation of this atom\n"
"			{\n"
"				atom_to_rotate[0] = ref_coords_x_const[atom_id];\n"
"				atom_to_rotate[1] = ref_coords_y_const[atom_id];\n"
"				atom_to_rotate[2] = ref_coords_z_const[atom_id];\n"
"			}\n"
"			else\n"
"			{\n"
"				atom_to_rotate[0] = calc_coords_x[atom_id];\n"
"				atom_to_rotate[1] = calc_coords_y[atom_id];\n"
"				atom_to_rotate[2] = calc_coords_z[atom_id];\n"
"			}\n"
"\n"
"			// Capturing rotation vectors and angle\n"
"			float rotation_movingvec[3];\n"
"\n"
"			float quatrot_left_x, quatrot_left_y, quatrot_left_z, quatrot_left_q;\n"
"			float quatrot_temp_x, quatrot_temp_y, quatrot_temp_z, quatrot_temp_q;\n"
"\n"
"			if ((rotation_list_element & RLIST_GENROT_MASK) != 0)	// If general rotation\n"
"			{\n"
"				// Rotational genes in the Shoemake space expressed in radians\n"
"				float u1 = genotype[3];\n"
"				float u2 = genotype[4];\n"
"				float u3 = genotype[5];\n"
"\n"
"				// u1, u2, u3 should be within their valid range of [0,1]\n"
"				quatrot_left_q = native_sqrt(1 - u1) * native_sin(PI_TIMES_2*u2); \n"
"				quatrot_left_x = native_sqrt(1 - u1) * native_cos(PI_TIMES_2*u2);\n"
"				quatrot_left_y = native_sqrt(u1)     * native_sin(PI_TIMES_2*u3);\n"
"				quatrot_left_z = native_sqrt(u1)     * native_cos(PI_TIMES_2*u3);\n"
"\n"
"				rotation_movingvec[0] = genotype[0];\n"
"				rotation_movingvec[1] = genotype[1];\n"
"				rotation_movingvec[2] = genotype[2];\n"
"			}\n"
"			else	// If rotating around rotatable bond\n"
"			{\n"
"				uint rotbond_id = (rotation_list_element & RLIST_RBONDID_MASK) >> RLIST_RBONDID_SHIFT;\n"
"\n"
"				float rotation_unitvec[3];\n"
"				rotation_unitvec[0] = rotbonds_unit_vectors_const[3*rotbond_id];\n"
"				rotation_unitvec[1] = rotbonds_unit_vectors_const[3*rotbond_id+1];\n"
"				rotation_unitvec[2] = rotbonds_unit_vectors_const[3*rotbond_id+2];\n"
"				float rotation_angle = genotype[6+rotbond_id]*DEG_TO_RAD;\n"
"\n"
"				rotation_movingvec[0] = rotbonds_moving_vectors_const[3*rotbond_id];\n"
"				rotation_movingvec[1] = rotbonds_moving_vectors_const[3*rotbond_id+1];\n"
"				rotation_movingvec[2] = rotbonds_moving_vectors_const[3*rotbond_id+2];\n"
"\n"
"				// Performing additionally the first movement which \n"
"				// is needed only if rotating around rotatable bond\n"
"				atom_to_rotate[0] -= rotation_movingvec[0];\n"
"				atom_to_rotate[1] -= rotation_movingvec[1];\n"
"				atom_to_rotate[2] -= rotation_movingvec[2];\n"
"\n"
"				// Transforming torsion angles into quaternions\n"
"				rotation_angle  = native_divide(rotation_angle, 2.0f);\n"
"				float sin_angle = native_sin(rotation_angle);\n"
"				quatrot_left_q  = native_cos(rotation_angle);\n"
"				quatrot_left_x  = sin_angle*rotation_unitvec[0];\n"
"				quatrot_left_y  = sin_angle*rotation_unitvec[1];\n"
"				quatrot_left_z  = sin_angle*rotation_unitvec[2];\n"
"			}\n"
"\n"
"			// Performing rotation\n"
"			if ((rotation_list_element & RLIST_GENROT_MASK) != 0)	// If general rotation,\n"
"										// two rotations should be performed\n"
"										// (multiplying the quaternions)\n"
"			{\n"
"				// Calculating quatrot_left*ref_orientation_quats_const,\n"
"				// which means that reference orientation rotation is the first\n"
"				quatrot_temp_q = quatrot_left_q;\n"
"				quatrot_temp_x = quatrot_left_x;\n"
"				quatrot_temp_y = quatrot_left_y;\n"
"				quatrot_temp_z = quatrot_left_z;\n"
"\n"
"				quatrot_left_q = quatrot_temp_q*ref_orientation_quats_const[4*(*run_id)]-\n"
"						 quatrot_temp_x*ref_orientation_quats_const[4*(*run_id)+1]-\n"
"						 quatrot_temp_y*ref_orientation_quats_const[4*(*run_id)+2]-\n"
"						 quatrot_temp_z*ref_orientation_quats_const[4*(*run_id)+3];\n"
"				quatrot_left_x = quatrot_temp_q*ref_orientation_quats_const[4*(*run_id)+1]+\n"
"						 ref_orientation_quats_const[4*(*run_id)]*quatrot_temp_x+\n"
"						 quatrot_temp_y*ref_orientation_quats_const[4*(*run_id)+3]-\n"
"						 ref_orientation_quats_const[4*(*run_id)+2]*quatrot_temp_z;\n"
"				quatrot_left_y = quatrot_temp_q*ref_orientation_quats_const[4*(*run_id)+2]+\n"
"						 ref_orientation_quats_const[4*(*run_id)]*quatrot_temp_y+\n"
"						 ref_orientation_quats_const[4*(*run_id)+1]*quatrot_temp_z-\n"
"						 quatrot_temp_x*ref_orientation_quats_const[4*(*run_id)+3];\n"
"				quatrot_left_z = quatrot_temp_q*ref_orientation_quats_const[4*(*run_id)+3]+\n"
"						 ref_orientation_quats_const[4*(*run_id)]*quatrot_temp_z+\n"
"						 quatrot_temp_x*ref_orientation_quats_const[4*(*run_id)+2]-\n"
"						 ref_orientation_quats_const[4*(*run_id)+1]*quatrot_temp_y;\n"
"			}\n"
"\n"
"			quatrot_temp_q = 0 -\n"
"					 quatrot_left_x*atom_to_rotate [0] -\n"
"					 quatrot_left_y*atom_to_rotate [1] -\n"
"					 quatrot_left_z*atom_to_rotate [2];\n"
"			quatrot_temp_x = quatrot_left_q*atom_to_rotate [0] +\n"
"					 quatrot_left_y*atom_to_rotate [2] -\n"
"					 quatrot_left_z*atom_to_rotate [1];\n"
"			quatrot_temp_y = quatrot_left_q*atom_to_rotate [1] -\n"
"					 quatrot_left_x*atom_to_rotate [2] +\n"
"					 quatrot_left_z*atom_to_rotate [0];\n"
"			quatrot_temp_z = quatrot_left_q*atom_to_rotate [2] +\n"
"					 quatrot_left_x*atom_to_rotate [1] -\n"
"					 quatrot_left_y*atom_to_rotate [0];\n"
"\n"
"			atom_to_rotate [0] = 0 -\n"
"					  quatrot_temp_q*quatrot_left_x +\n"
"					  quatrot_temp_x*quatrot_left_q -\n"
"					  quatrot_temp_y*quatrot_left_z +\n"
"					  quatrot_temp_z*quatrot_left_y;\n"
"			atom_to_rotate [1] = 0 -\n"
"					  quatrot_temp_q*quatrot_left_y +\n"
"					  quatrot_temp_x*quatrot_left_z +\n"
"					  quatrot_temp_y*quatrot_left_q -\n"
"					  quatrot_temp_z*quatrot_left_x;\n"
"			atom_to_rotate [2] = 0 -\n"
"					  quatrot_temp_q*quatrot_left_z -\n"
"					  quatrot_temp_x*quatrot_left_y +\n"
"					  quatrot_temp_y*quatrot_left_x +\n"
"					  quatrot_temp_z*quatrot_left_q;\n"
"\n"
"			// Performing final movement and storing values\n"
"			calc_coords_x[atom_id] = atom_to_rotate [0] + rotation_movingvec[0];\n"
"			calc_coords_y[atom_id] = atom_to_rotate [1] + rotation_movingvec[1];\n"
"			calc_coords_z[atom_id] = atom_to_rotate [2] + rotation_movingvec[2];\n"
"\n"
"		} // End if-statement not dummy rotation\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	} // End rotation_counter for-loop\n"
"\n"
"	// ================================================\n"
"	// CALCULATING INTERMOLECULAR ENERGY\n"
"	// ================================================\n"
"	for (uint atom_id = get_local_id(0);\n"
"	          atom_id < dockpars_num_of_atoms;\n"
"	          atom_id+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		uint atom_typeid = atom_types_const[atom_id];\n"
"		float x = calc_coords_x[atom_id];\n"
"		float y = calc_coords_y[atom_id];\n"
"		float z = calc_coords_z[atom_id];\n"
"		float q = atom_charges_const[atom_id];\n"
"\n"
"		if ((x < 0) || (y < 0) || (z < 0) || (x >= dockpars_gridsize_x-1)\n"
"				                  || (y >= dockpars_gridsize_y-1)\n"
"						  || (z >= dockpars_gridsize_z-1)){\n"
"			partial_energies[get_local_id(0)] += 16777216.0f; //100000.0f;\n"
"	\n"
"			#if defined (DEBUG_ENERGY_KERNEL1) || defined (DEBUG_ENERGY_KERNEL4) || defined (DEBUG_ENERGY_KERNEL3)\n"
"			partial_interE[get_local_id(0)] += 16777216.0f;\n"
"			#endif\n"
"		}\n"
"		else\n"
"		{\n"
"			// Getting coordinates\n"
"			int x_low  = (int)floor(x); \n"
"			int y_low  = (int)floor(y); \n"
"			int z_low  = (int)floor(z);\n"
"			int x_high = (int)ceil(x); \n"
"			int y_high = (int)ceil(y); \n"
"			int z_high = (int)ceil(z);\n"
"			float dx = x - x_low; \n"
"			float dy = y - y_low; \n"
"			float dz = z - z_low;\n"
"\n"
"			// Calculating interpolation weights\n"
"			float weights[2][2][2];\n"
"			weights [0][0][0] = (1-dx)*(1-dy)*(1-dz);\n"
"			weights [1][0][0] = dx*(1-dy)*(1-dz);\n"
"			weights [0][1][0] = (1-dx)*dy*(1-dz);\n"
"			weights [1][1][0] = dx*dy*(1-dz);\n"
"			weights [0][0][1] = (1-dx)*(1-dy)*dz;\n"
"			weights [1][0][1] = dx*(1-dy)*dz;\n"
"			weights [0][1][1] = (1-dx)*dy*dz;\n"
"			weights [1][1][1] = dx*dy*dz;\n"
"\n"
"			// Capturing affinity values\n"
"			uint ylow_times_g1  = y_low*g1;\n"
"			uint yhigh_times_g1 = y_high*g1;\n"
"		  	uint zlow_times_g2  = z_low*g2;\n"
"			uint zhigh_times_g2 = z_high*g2;\n"
"\n"
"			// Grid offset\n"
"			uint offset_cube_000 = x_low  + ylow_times_g1  + zlow_times_g2;\n"
"			uint offset_cube_100 = x_high + ylow_times_g1  + zlow_times_g2;\n"
"			uint offset_cube_010 = x_low  + yhigh_times_g1 + zlow_times_g2;\n"
"			uint offset_cube_110 = x_high + yhigh_times_g1 + zlow_times_g2;\n"
"			uint offset_cube_001 = x_low  + ylow_times_g1  + zhigh_times_g2;\n"
"			uint offset_cube_101 = x_high + ylow_times_g1  + zhigh_times_g2;\n"
"			uint offset_cube_011 = x_low  + yhigh_times_g1 + zhigh_times_g2;\n"
"			uint offset_cube_111 = x_high + yhigh_times_g1 + zhigh_times_g2;\n"
"\n"
"			uint mul_tmp = atom_typeid*g3;\n"
"\n"
"			float cube[2][2][2];\n"
"			cube [0][0][0] = *(dockpars_fgrids + offset_cube_000 + mul_tmp);\n"
"			cube [1][0][0] = *(dockpars_fgrids + offset_cube_100 + mul_tmp);\n"
"			cube [0][1][0] = *(dockpars_fgrids + offset_cube_010 + mul_tmp);\n"
"		        cube [1][1][0] = *(dockpars_fgrids + offset_cube_110 + mul_tmp);\n"
"		        cube [0][0][1] = *(dockpars_fgrids + offset_cube_001 + mul_tmp);\n"
"			cube [1][0][1] = *(dockpars_fgrids + offset_cube_101 + mul_tmp);\n"
"                        cube [0][1][1] = *(dockpars_fgrids + offset_cube_011 + mul_tmp);\n"
"                        cube [1][1][1] = *(dockpars_fgrids + offset_cube_111 + mul_tmp);\n"
"\n"
"			// Calculating affinity energy\n"
"			partial_energies[get_local_id(0)] += TRILININTERPOL(cube, weights);\n"
"\n"
"			#if defined (DEBUG_ENERGY_KERNEL1) || defined (DEBUG_ENERGY_KERNEL4) || defined (DEBUG_ENERGY_KERNEL3)\n"
"			partial_interE[get_local_id(0)] += TRILININTERPOL(cube, weights);\n"
"			#endif\n"
"\n"
"			// Capturing electrostatic values\n"
"			atom_typeid = dockpars_num_of_atypes;\n"
"\n"
"			mul_tmp = atom_typeid*g3;\n"
"			cube [0][0][0] = *(dockpars_fgrids + offset_cube_000 + mul_tmp);\n"
"			cube [1][0][0] = *(dockpars_fgrids + offset_cube_100 + mul_tmp);\n"
"      			cube [0][1][0] = *(dockpars_fgrids + offset_cube_010 + mul_tmp);\n"
"      			cube [1][1][0] = *(dockpars_fgrids + offset_cube_110 + mul_tmp);\n"
"		       	cube [0][0][1] = *(dockpars_fgrids + offset_cube_001 + mul_tmp);\n"
"		        cube [1][0][1] = *(dockpars_fgrids + offset_cube_101 + mul_tmp);\n"
"		        cube [0][1][1] = *(dockpars_fgrids + offset_cube_011 + mul_tmp);\n"
"		        cube [1][1][1] = *(dockpars_fgrids + offset_cube_111 + mul_tmp);\n"
"\n"
"			// Calculating electrostatic energy\n"
"			partial_energies[get_local_id(0)] += q * TRILININTERPOL(cube, weights);\n"
"\n"
"			#if defined (DEBUG_ENERGY_KERNEL1) || defined (DEBUG_ENERGY_KERNEL4) || defined (DEBUG_ENERGY_KERNEL3)\n"
"			partial_interE[get_local_id(0)] += q * TRILININTERPOL(cube, weights);\n"
"			#endif\n"
"\n"
"			// Capturing desolvation values\n"
"			atom_typeid = dockpars_num_of_atypes+1;\n"
"\n"
"			mul_tmp = atom_typeid*g3;\n"
"			cube [0][0][0] = *(dockpars_fgrids + offset_cube_000 + mul_tmp);\n"
"			cube [1][0][0] = *(dockpars_fgrids + offset_cube_100 + mul_tmp);\n"
"      			cube [0][1][0] = *(dockpars_fgrids + offset_cube_010 + mul_tmp);\n"
"      			cube [1][1][0] = *(dockpars_fgrids + offset_cube_110 + mul_tmp);\n"
"      			cube [0][0][1] = *(dockpars_fgrids + offset_cube_001 + mul_tmp);\n"
"      			cube [1][0][1] = *(dockpars_fgrids + offset_cube_101 + mul_tmp);\n"
"      			cube [0][1][1] = *(dockpars_fgrids + offset_cube_011 + mul_tmp);\n"
"      			cube [1][1][1] = *(dockpars_fgrids + offset_cube_111 + mul_tmp);\n"
"\n"
"			// Calculating desolvation energy\n"
"			partial_energies[get_local_id(0)] += fabs(q) * TRILININTERPOL(cube, weights);\n"
"\n"
"			#if defined (DEBUG_ENERGY_KERNEL1) || defined (DEBUG_ENERGY_KERNEL4) || defined (DEBUG_ENERGY_KERNEL3)\n"
"			partial_interE[get_local_id(0)] += fabs(q) * TRILININTERPOL(cube, weights);\n"
"			#endif\n"
"		}\n"
"\n"
"	} // End atom_id for-loop (INTERMOLECULAR ENERGY)\n"
"\n"
"\n"
"	#if defined (DEBUG_ENERGY_KERNEL1) || defined (DEBUG_ENERGY_KERNEL4) || defined (DEBUG_ENERGY_KERNEL3)\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	if (get_local_id(0) == 0)\n"
"	{\n"
"		float energy_interE = partial_interE[0];\n"
"\n"
"		for (uint contributor_counter=1;\n"
"		          contributor_counter<NUM_OF_THREADS_PER_BLOCK;\n"
"		          contributor_counter++)\n"
"		{\n"
"			energy_interE += partial_interE[contributor_counter];\n"
"		}\n"
"		partial_interE[0] = energy_interE;\n"
"		//printf(\"%-20s %-10.8f\\n\", \"energy_interE: \", energy_interE);\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	#endif\n"
"\n"
"\n"
"	// In paper: intermolecular and internal energy calculation\n"
"	// are independent from each other, -> NO BARRIER NEEDED\n"
"  	// but require different operations,\n"
"	// thus, they can be executed only sequentially on the GPU.\n"
"\n"
"	// ================================================\n"
"	// CALCULATING INTRAMOLECULAR ENERGY\n"
"	// ================================================\n"
"	for (uint contributor_counter = get_local_id(0);\n"
"	          contributor_counter < dockpars_num_of_intraE_contributors;\n"
"	          contributor_counter +=NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		// Getting atom IDs\n"
"		uint atom1_id = intraE_contributors_const[3*contributor_counter];\n"
"		uint atom2_id = intraE_contributors_const[3*contributor_counter+1];\n"
"\n"
"		// Calculating vector components of vector going\n"
"		// from first atom's to second atom's coordinates\n"
"		float subx = calc_coords_x[atom1_id] - calc_coords_x[atom2_id];\n"
"		float suby = calc_coords_y[atom1_id] - calc_coords_y[atom2_id];\n"
"		float subz = calc_coords_z[atom1_id] - calc_coords_z[atom2_id];\n"
"\n"
"		// Calculating atomic_distance\n"
"		float atomic_distance = native_sqrt(subx*subx + suby*suby + subz*subz)*dockpars_grid_spacing;\n"
"\n"
"		if (atomic_distance < 1.0f)\n"
"			atomic_distance = 1.0f;\n"
"\n"
"		// Calculating energy contributions\n"
"		if ((atomic_distance < 8.0f) && (atomic_distance < 20.48f))\n"
"		{\n"
"			// Getting type IDs\n"
"			uint atom1_typeid = atom_types_const[atom1_id];\n"
"			uint atom2_typeid = atom_types_const[atom2_id];\n"
"\n"
"			// Calculating van der Waals / hydrogen bond term\n"
"			partial_energies[get_local_id(0)] += native_divide(VWpars_AC_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],native_powr(atomic_distance,12));\n"
"\n"
"			#if defined (DEBUG_ENERGY_KERNEL1) || defined (DEBUG_ENERGY_KERNEL4) || defined (DEBUG_ENERGY_KERNEL3)\n"
"			partial_intraE[get_local_id(0)] += native_divide(VWpars_AC_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],native_powr(atomic_distance,12));\n"
"			#endif\n"
"\n"
"			if (intraE_contributors_const[3*contributor_counter+2] == 1) {	//H-bond\n"
"				partial_energies[get_local_id(0)] -= native_divide(VWpars_BD_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],native_powr(atomic_distance,10));\n"
"				#if defined (DEBUG_ENERGY_KERNEL1) || defined (DEBUG_ENERGY_KERNEL4) || defined (DEBUG_ENERGY_KERNEL3)\n"
"				partial_intraE[get_local_id(0)] -= native_divide(VWpars_BD_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],native_powr(atomic_distance,10));\n"
"				#endif\n"
"			}\n"
"			else {	//van der Waals\n"
"				partial_energies[get_local_id(0)] -= native_divide(VWpars_BD_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],native_powr(atomic_distance,6));\n"
"\n"
"				#if defined (DEBUG_ENERGY_KERNEL1) || defined (DEBUG_ENERGY_KERNEL4) || defined (DEBUG_ENERGY_KERNEL3)\n"
"				partial_intraE[get_local_id(0)] -= native_divide(VWpars_BD_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],native_powr(atomic_distance,6));\n"
"				#endif\n"
"			}\n"
"			// Calculating electrostatic term\n"
"\n"
"        		partial_energies[get_local_id(0)] += native_divide (\n"
"                                                             dockpars_coeff_elec * atom_charges_const[atom1_id] * atom_charges_const[atom2_id],\n"
"                                                             atomic_distance * (DIEL_A + native_divide(DIEL_B,(1.0f + DIEL_K*native_exp(-DIEL_B_TIMES_H*atomic_distance))))\n"
"                                                             );\n"
"\n"
"			#if defined (DEBUG_ENERGY_KERNEL1) || defined (DEBUG_ENERGY_KERNEL4) || defined (DEBUG_ENERGY_KERNEL3)\n"
"			partial_intraE[get_local_id(0)] += native_divide (\n"
"                                                             dockpars_coeff_elec * atom_charges_const[atom1_id] * atom_charges_const[atom2_id],\n"
"                                                             atomic_distance * (DIEL_A + native_divide(DIEL_B,(1.0f + DIEL_K*native_exp(-DIEL_B_TIMES_H*atomic_distance))))\n"
"                                                             );\n"
"			#endif\n"
"\n"
"			// Calculating desolvation term\n"
"			partial_energies[get_local_id(0)] += ((dspars_S_const[atom1_typeid] +\n"
"							       dockpars_qasp*fabs(atom_charges_const[atom1_id]))*dspars_V_const[atom2_typeid] +\n"
"					                       (dspars_S_const[atom2_typeid] +\n"
"							       dockpars_qasp*fabs(atom_charges_const[atom2_id]))*dspars_V_const[atom1_typeid]) *\n"
"					                       dockpars_coeff_desolv*native_exp(-atomic_distance*native_divide(atomic_distance,25.92f));\n"
"\n"
"			#if defined (DEBUG_ENERGY_KERNEL1) || defined (DEBUG_ENERGY_KERNEL4) || defined (DEBUG_ENERGY_KERNEL3)\n"
"			partial_intraE[get_local_id(0)] += ((dspars_S_const[atom1_typeid] +\n"
"							       dockpars_qasp*fabs(atom_charges_const[atom1_id]))*dspars_V_const[atom2_typeid] +\n"
"					                       (dspars_S_const[atom2_typeid] +\n"
"							       dockpars_qasp*fabs(atom_charges_const[atom2_id]))*dspars_V_const[atom1_typeid]) *\n"
"					                       dockpars_coeff_desolv*native_exp(-atomic_distance*native_divide(atomic_distance,25.92f));\n"
"			#endif\n"
"\n"
"\n"
"\n"
"		}\n"
"	} // End contributor_counter for-loop (INTRAMOLECULAR ENERGY)\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	if (get_local_id(0) == 0)\n"
"	{\n"
"		*energy = partial_energies[0];\n"
"\n"
"		for (uint contributor_counter=1;\n"
"		          contributor_counter<NUM_OF_THREADS_PER_BLOCK;\n"
"		          contributor_counter++)\n"
"		{\n"
"			*energy += partial_energies[contributor_counter];\n"
"		}\n"
"	}\n"
"\n"
"	#if defined (DEBUG_ENERGY_KERNEL1) || defined (DEBUG_ENERGY_KERNEL4) || defined (DEBUG_ENERGY_KERNEL3)\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	if (get_local_id(0) == 0)\n"
"	{\n"
"		float energy_intraE = partial_intraE[0];\n"
"\n"
"		for (uint contributor_counter=1;\n"
"		          contributor_counter<NUM_OF_THREADS_PER_BLOCK;\n"
"		          contributor_counter++)\n"
"		{\n"
"			energy_intraE += partial_intraE[contributor_counter];\n"
"		}\n"
"		partial_intraE[0] = energy_intraE;\n"
"		//printf(\"%-20s %-10.8f\\n\", \"energy_intraE: \", energy_intraE);\n"
"\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	#endif\n"
"\n"
"}\n"
"\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gpu_calc_initpop(	\n"
"			char   dockpars_num_of_atoms,\n"
"			char   dockpars_num_of_atypes,\n"
"			int    dockpars_num_of_intraE_contributors,\n"
"			char   dockpars_gridsize_x,\n"
"			char   dockpars_gridsize_y,\n"
"			char   dockpars_gridsize_z,\n"
"			float  dockpars_grid_spacing,\n"
"	 __global const float* restrict dockpars_fgrids, // This is too large to be allocated in __constant \n"
"			int    dockpars_rotbondlist_length,\n"
"			float  dockpars_coeff_elec,\n"
"			float  dockpars_coeff_desolv,\n"
"	 __global const float* restrict dockpars_conformations_current,\n"
"	 __global       float* restrict dockpars_energies_current,\n"
"	 __global       int*   restrict dockpars_evals_of_new_entities,\n"
"			int    dockpars_pop_size,\n"
"			float  dockpars_qasp,\n"
"	     __constant float* atom_charges_const,\n"
"             __constant char*  atom_types_const,\n"
"	     __constant char*  intraE_contributors_const,\n"
"             __constant float* VWpars_AC_const,\n"
"             __constant float* VWpars_BD_const,\n"
"             __constant float* dspars_S_const,\n"
"             __constant float* dspars_V_const,\n"
"             __constant int*   rotlist_const,\n"
"             __constant float* ref_coords_x_const,\n"
"             __constant float* ref_coords_y_const,\n"
"             __constant float* ref_coords_z_const,\n"
"             __constant float* rotbonds_moving_vectors_const,\n"
"             __constant float* rotbonds_unit_vectors_const,\n"
"             __constant float* ref_orientation_quats_const\n"
"){\n"
"        // Some OpenCL compilers don't allow declaring \n"
"	// local variables within non-kernel functions.\n"
"	// These local variables must be declared in a kernel, \n"
"	// and then passed to non-kernel functions.\n"
"	__local float  genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"	__local float  energy;\n"
"	__local int    run_id;\n"
"\n"
"	__local float calc_coords_x[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_y[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_z[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"	#if defined (DEBUG_ENERGY_KERNEL1)\n"
"	__local float partial_interE[NUM_OF_THREADS_PER_BLOCK];\n"
"	__local float partial_intraE[NUM_OF_THREADS_PER_BLOCK];\n"
"	#endif\n"
"\n"
"	// Copying genotype from global memory\n"
"	event_t ev = async_work_group_copy(genotype,\n"
"			                   dockpars_conformations_current + GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0),\n"
"			                   GENOTYPE_LENGTH_IN_GLOBMEM, 0);\n"
"\n"
"	wait_group_events(1,&ev);\n"
"\n"
"	// Determining run-ID\n"
"	if (get_local_id(0) == 0) {\n"
"		run_id = get_group_id(0) / dockpars_pop_size;\n"
"	}\n"
"\n"
"	// =============================================================\n"
"	// WARNING: only energy of work-item=0 will be valid\n"
"	gpu_calc_energy(dockpars_rotbondlist_length,\n"
"			dockpars_num_of_atoms,\n"
"			dockpars_gridsize_x,\n"
"			dockpars_gridsize_y,\n"
"			dockpars_gridsize_z,\n"
"			dockpars_fgrids,\n"
"			dockpars_num_of_atypes,\n"
"			dockpars_num_of_intraE_contributors,\n"
"			dockpars_grid_spacing,\n"
"			dockpars_coeff_elec,\n"
"			dockpars_qasp,\n"
"			dockpars_coeff_desolv,\n"
"			genotype,\n"
"			&energy,\n"
"			&run_id,\n"
"			// Some OpenCL compilers don't allow declaring \n"
"			// local variables within non-kernel functions.\n"
"			// These local variables must be declared in a kernel, \n"
"			// and then passed to non-kernel functions.\n"
"			calc_coords_x,\n"
"			calc_coords_y,\n"
"			calc_coords_z,\n"
"			partial_energies,\n"
"			#if defined (DEBUG_ENERGY_KERNEL1)\n"
"			partial_interE,\n"
"			partial_intraE,\n"
"			#endif\n"
"\n"
"	                atom_charges_const,\n"
"		        atom_types_const,\n"
"			intraE_contributors_const,\n"
"			VWpars_AC_const,\n"
"			VWpars_BD_const,\n"
"			dspars_S_const,\n"
"			dspars_V_const,\n"
"			rotlist_const,\n"
"			ref_coords_x_const,\n"
"			ref_coords_y_const,\n"
"			ref_coords_z_const,\n"
"			rotbonds_moving_vectors_const,\n"
"			rotbonds_unit_vectors_const,\n"
"			ref_orientation_quats_const\n"
"			);\n"
"	// =============================================================\n"
"\n"
"	if (get_local_id(0) == 0) {\n"
"		dockpars_energies_current[get_group_id(0)] = energy;\n"
"		dockpars_evals_of_new_entities[get_group_id(0)] = 1;\n"
"\n"
"		#if defined (DEBUG_ENERGY_KERNEL1)\n"
"		printf(\"%-18s [%-5s]---{%-5s}   [%-10.8f]---{%-10.8f}\\n\", \"-ENERGY-KERNEL1-\", \"GRIDS\", \"INTRA\", partial_interE[0], partial_intraE[0]);\n"
"		#endif\n"
"	}\n"
"}\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gpu_sum_evals(	       \n"
"		       uint pop_size,\n"
"	      __global int* restrict dockpars_evals_of_new_entities,\n"
"              __global int* restrict evals_of_runs\n"
")\n"
"//The GPU global function sums the evaluation counter states\n"
"//which are stored in evals_of_new_entities array foreach entity,\n"
"//calculates the sums for each run and stores it in evals_of_runs array.\n"
"//The number of blocks which should be started equals to num_of_runs,\n"
"//since each block performs the summation for one run.\n"
"{\n"
"	int entity_counter;\n"
"	int sum_evals;\n"
"	__local int partsum_evals[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	partsum_evals[get_local_id(0)] = 0;\n"
"\n"
"	// Maximum size defined in ../common/defines.h\n"
"	__local int local_evals_of_new_entities[MAX_POPSIZE];\n"
"\n"
"	async_work_group_copy(local_evals_of_new_entities,\n"
"                              dockpars_evals_of_new_entities+get_group_id(0)*pop_size,\n"
"                              pop_size, 0);\n"
"\n"
"\n"
"  	for (entity_counter = get_local_id(0);\n"
"	     entity_counter < pop_size;\n"
"	     entity_counter+= NUM_OF_THREADS_PER_BLOCK) {\n"
"		partsum_evals[get_local_id(0)] += local_evals_of_new_entities[entity_counter];\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	if (get_local_id(0) == 0) {\n"
"		sum_evals = partsum_evals[0];\n"
"\n"
"		for (entity_counter = 1;\n"
"		     entity_counter < NUM_OF_THREADS_PER_BLOCK;\n"
"		     entity_counter++) {\n"
"			sum_evals += partsum_evals[entity_counter];\n"
"		}\n"
"\n"
"		evals_of_runs[get_group_id(0)] += sum_evals;\n"
"	}\n"
"}\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"// -------------------------------------------------------\n"
"//\n"
"// -------------------------------------------------------\n"
"uint gpu_rand(\n"
"		__global uint* restrict prng_states\n"
")\n"
"//The GPU device function generates a random int\n"
"//with a linear congruential generator.\n"
"//Each thread (supposing num_of_runs*pop_size blocks and NUM_OF_THREADS_PER_BLOCK threads per block)\n"
"//has its own state which is stored in the global memory area pointed by\n"
"//prng_states (thread with ID tx in block with ID bx stores its state in prng_states[bx*NUM_OF_THREADS_PER_BLOCK+$\n"
"//The random number generator uses the gcc linear congruential generator constants.\n"
"{\n"
"	uint state;\n"
"\n"
"#if defined (REPRO)\n"
"	state = 1;\n"
"#else\n"
"  	// Current state of the threads own PRNG\n"
"  	// state = prng_states[get_group_id(0)*NUM_OF_THREADS_PER_BLOCK + get_local_id(0)];\n"
"	state = prng_states[get_global_id(0)];\n"
"\n"
"	// Calculating next state\n"
"  	state = (RAND_A*state+RAND_C);\n"
"#endif\n"
"  	// Saving next state to memory\n"
"  	// prng_states[get_group_id(0)*NUM_OF_THREADS_PER_BLOCK + get_local_id(0)] = state;\n"
"	prng_states[get_global_id(0)] = state;\n"
"\n"
"  return state;\n"
"}\n"
"\n"
"// -------------------------------------------------------\n"
"//\n"
"// -------------------------------------------------------\n"
"float gpu_randf(\n"
"		__global uint* restrict prng_states\n"
")\n"
"//The GPU device function generates a\n"
"//random float greater than (or equal to) 0 and less than 1.\n"
"//It uses gpu_rand() function.\n"
"{\n"
"  	float state;\n"
"\n"
"	// State will be between 0 and 1\n"
"#if defined (REPRO)\n"
"	state = 0.55f; //0.55f;\n"
"#else\n"
"	state =  native_divide(gpu_rand(prng_states),MAX_UINT)*0.999999f;\n"
"#endif\n"
"\n"
"  return state;\n"
"}\n"
"\n"
"// -------------------------------------------------------\n"
"//\n"
"// -------------------------------------------------------\n"
"void map_angle(__local float* angle)\n"
"// The GPU device function maps\n"
"// the input parameter to the interval 0...360\n"
"// (supposing that it is an angle).\n"
"{\n"
"	while (*angle >= 360.0f) {\n"
"		*angle -= 360.0f;\n"
"	}\n"
"\n"
"	while (*angle < 0.0f) {\n"
"		*angle += 360.0f;\n"
"	}\n"
"}\n"
"\n"
"// -------------------------------------------------------\n"
"//\n"
"// -------------------------------------------------------\n"
"void gpu_perform_elitist_selection(\n"
"					     int    dockpars_pop_size,\n"
"				    __global float* restrict dockpars_energies_current,\n"
"				    __global float* restrict dockpars_energies_next,\n"
"				    __global int*   restrict dockpars_evals_of_new_entities,\n"
"					     int    dockpars_num_of_genes,\n"
"				    __global float* restrict dockpars_conformations_next,\n"
"		       		    __global const float* restrict dockpars_conformations_current,\n"
"				    __local  float* best_energies,\n"
"				    __local  int*   best_IDs,\n"
"				    __local  int*   best_ID\n"
")\n"
"//The GPU device function performs elitist selection,\n"
"//that is, it looks for the best entity in conformations_current and\n"
"//energies_current of the run that corresponds to the block ID,\n"
"//and copies it to the place of the first entity in\n"
"//conformations_next and energies_next.\n"
"{\n"
"	int entity_counter;\n"
"	int gene_counter;\n"
"	float best_energy;\n"
"\n"
"	if (get_local_id(0) < dockpars_pop_size) {\n"
"		best_energies[get_local_id(0)] = dockpars_energies_current[get_group_id(0)+get_local_id(0)];\n"
"		best_IDs[get_local_id(0)] = get_local_id(0);\n"
"	}\n"
"\n"
"	for (entity_counter = NUM_OF_THREADS_PER_BLOCK+get_local_id(0);\n"
"	     entity_counter < dockpars_pop_size;\n"
"	     entity_counter+= NUM_OF_THREADS_PER_BLOCK) {\n"
"\n"
"	     if (dockpars_energies_current[get_group_id(0)+entity_counter] < best_energies[get_local_id(0)]) {\n"
"		best_energies[get_local_id(0)] = dockpars_energies_current[get_group_id(0)+entity_counter];\n"
"		best_IDs[get_local_id(0)] = entity_counter;\n"
"	     }\n"
"	}\n"
"\n"
"       barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// This could be implemented with a tree-like structure\n"
"	// which may be slightly faster\n"
"	if (get_local_id(0) == 0)\n"
"	{\n"
"		best_energy = best_energies[0];\n"
"		best_ID[0] = best_IDs[0];\n"
"\n"
"		for (entity_counter = 1;\n"
"		     entity_counter < NUM_OF_THREADS_PER_BLOCK;\n"
"		     entity_counter++) {\n"
"\n"
"		     if ((best_energies[entity_counter] < best_energy) && (entity_counter < dockpars_pop_size)) {\n"
"			      best_energy = best_energies[entity_counter];\n"
"			      best_ID[0] = best_IDs[entity_counter];\n"
"		     }\n"
"		}\n"
"\n"
"		// Setting energy value of new entity\n"
"		dockpars_energies_next[get_group_id(0)] = best_energy;\n"
"\n"
"		// Zero (0) evals were performed for entity selected with elitism (since it was copied only)\n"
"		dockpars_evals_of_new_entities[get_group_id(0)] = 0;\n"
"	}\n"
"\n"
"	// \"best_id\" stores the id of the best entity in the population,\n"
"	// Copying genotype and energy value to the first entity of new population\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	for (gene_counter = get_local_id(0);\n"
"	     gene_counter < dockpars_num_of_genes;\n"
"	     gene_counter+= NUM_OF_THREADS_PER_BLOCK) {\n"
"	     dockpars_conformations_next[GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0)+gene_counter] = dockpars_conformations_current[GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0) + GENOTYPE_LENGTH_IN_GLOBMEM*best_ID[0]+gene_counter];\n"
"	}\n"
"}\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"perform_LS(		\n"
"			char   dockpars_num_of_atoms,\n"
"			char   dockpars_num_of_atypes,\n"
"			int    dockpars_num_of_intraE_contributors,\n"
"			char   dockpars_gridsize_x,\n"
"			char   dockpars_gridsize_y,\n"
"			char   dockpars_gridsize_z,\n"
"			float  dockpars_grid_spacing,\n"
"         __global const float* restrict dockpars_fgrids, // This is too large to be allocated in __constant \n"
"	        	int    dockpars_rotbondlist_length,\n"
"			float  dockpars_coeff_elec,\n"
"			float  dockpars_coeff_desolv,\n"
"  	 __global       float* restrict dockpars_conformations_next,\n"
"  	 __global 	float* restrict dockpars_energies_next,\n"
"  	 __global 	int*   restrict dockpars_evals_of_new_entities,\n"
"  	 __global 	uint*  restrict dockpars_prng_states,\n"
"			int    dockpars_pop_size,\n"
"			int    dockpars_num_of_genes,\n"
"			float  dockpars_lsearch_rate,\n"
"			uint   dockpars_num_of_lsentities,\n"
"			float  dockpars_rho_lower_bound,\n"
"			float  dockpars_base_dmov_mul_sqrt3,\n"
"			float  dockpars_base_dang_mul_sqrt3,\n"
"			uint   dockpars_cons_limit,\n"
"			uint   dockpars_max_num_of_iters,\n"
"			float  dockpars_qasp,\n"
"	     __constant float* atom_charges_const,\n"
"             __constant char*  atom_types_const,\n"
"	     __constant char*  intraE_contributors_const,\n"
"             __constant float* VWpars_AC_const,\n"
"             __constant float* VWpars_BD_const,\n"
"             __constant float* dspars_S_const,\n"
"             __constant float* dspars_V_const,\n"
"             __constant int*   rotlist_const,\n"
"             __constant float* ref_coords_x_const,\n"
"             __constant float* ref_coords_y_const,\n"
"             __constant float* ref_coords_z_const,\n"
"             __constant float* rotbonds_moving_vectors_const,\n"
"             __constant float* rotbonds_unit_vectors_const,\n"
"             __constant float* ref_orientation_quats_const\n"
")\n"
"//The GPU global function performs local search on the pre-defined entities of conformations_next.\n"
"//The number of blocks which should be started equals to num_of_lsentities*num_of_runs.\n"
"//This way the first num_of_lsentities entity of each population will be subjected to local search\n"
"//(and each block carries out the algorithm for one entity).\n"
"//Since the first entity is always the best one in the current population,\n"
"//it is always tested according to the ls probability, and if it not to be\n"
"//subjected to local search, the entity with ID num_of_lsentities is selected instead of the first one (with ID 0).\n"
"{\n"
"	// Some OpenCL compilers don't allow declaring \n"
"	// local variables within non-kernel functions.\n"
"	// These local variables must be declared in a kernel, \n"
"	// and then passed to non-kernel functions.\n"
"	__local float genotype_candidate[ACTUAL_GENOTYPE_LENGTH];\n"
"	__local float genotype_deviate  [ACTUAL_GENOTYPE_LENGTH];\n"
"	__local float genotype_bias     [ACTUAL_GENOTYPE_LENGTH];\n"
"        __local float rho;\n"
"	__local int   cons_succ;\n"
"	__local int   cons_fail;\n"
"	__local int   iteration_cnt;\n"
"	__local float candidate_energy;\n"
"	__local int   evaluation_cnt;\n"
"	int gene_counter;\n"
"\n"
"	__local float offspring_genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"	__local int run_id;\n"
"	__local int entity_id;\n"
"	__local float offspring_energy;\n"
"\n"
"	__local float calc_coords_x[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_y[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_z[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	#if defined (DEBUG_ENERGY_KERNEL3)\n"
"	__local float partial_interE [NUM_OF_THREADS_PER_BLOCK];\n"
"	__local float partial_intraE [NUM_OF_THREADS_PER_BLOCK];\n"
"	#endif\n"
"\n"
"	// Determining run ID and entity ID\n"
"	// Initializing offspring genotype\n"
"	if (get_local_id(0) == 0)\n"
"	{\n"
"		run_id = get_group_id(0) / dockpars_num_of_lsentities;\n"
"		entity_id = get_group_id(0) % dockpars_num_of_lsentities;\n"
"\n"
"		// Since entity 0 is the best one due to elitism,\n"
"		// it should be subjected to random selection\n"
"		if (entity_id == 0) {\n"
"			// If entity 0 is not selected according to LS-rate,\n"
"			// choosing an other entity\n"
"			if (100.0f*gpu_randf(dockpars_prng_states) > dockpars_lsearch_rate) {\n"
"				entity_id = dockpars_num_of_lsentities;					\n"
"			}\n"
"		}\n"
"\n"
"		offspring_energy = dockpars_energies_next[run_id*dockpars_pop_size+entity_id];\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"  	async_work_group_copy(offspring_genotype,\n"
"			      dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"                              dockpars_num_of_genes, 0);\n"
"\n"
"	for (gene_counter = get_local_id(0);\n"
"	     gene_counter < dockpars_num_of_genes;\n"
"	     gene_counter+= NUM_OF_THREADS_PER_BLOCK) {\n"
"		   genotype_bias[gene_counter] = 0.0f;\n"
"	}\n"
"\n"
"	if (get_local_id(0) == 0) {\n"
"		rho = 1.0f;\n"
"		cons_succ = 0;\n"
"		cons_fail = 0;\n"
"		iteration_cnt = 0;\n"
"		evaluation_cnt = 0;\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	while ((iteration_cnt < dockpars_max_num_of_iters) && (rho > dockpars_rho_lower_bound))\n"
"	{\n"
"		// New random deviate\n"
"		for (gene_counter = get_local_id(0);\n"
"		     gene_counter < dockpars_num_of_genes;\n"
"		     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			genotype_deviate[gene_counter] = rho*(2*gpu_randf(dockpars_prng_states)-1);\n"
"\n"
"			// Translation genes\n"
"			if (gene_counter <= 2)\n"
"				genotype_deviate[gene_counter] *= dockpars_base_dmov_mul_sqrt3;\n"
"			\n"
"			// Shoemake orientation-genes do not use initial deviation\n"
"\n"
"			// Torsion genes\n"
"			else if (gene_counter >= 6) \n"
"				genotype_deviate[gene_counter] *= dockpars_base_dang_mul_sqrt3;\n"
"\n"
"		}\n"
"\n"
"		// Generating new genotype candidate\n"
"		for (gene_counter = get_local_id(0);\n"
"		     gene_counter < dockpars_num_of_genes;\n"
"		     gene_counter+= NUM_OF_THREADS_PER_BLOCK) {\n"
"\n"
"			// Shoemake genes (u1, u2, u3) ranges between [0,1]\n"
"			if ((gene_counter >= 3) && (gene_counter <= 5)) { \n"
"			   genotype_candidate[gene_counter] = gpu_randf(dockpars_prng_states);\n"
"			}\n"
"			// Other genes: translation and torsions\n"
"			else {\n"
"			   genotype_candidate[gene_counter] = offspring_genotype[gene_counter] + \n"
"							      genotype_deviate[gene_counter]   + \n"
"							      genotype_bias[gene_counter];\n"
"			}\n"
"		}\n"
"\n"
"		// Evaluating candidate\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// ==================================================================\n"
"		gpu_calc_energy(dockpars_rotbondlist_length,\n"
"				dockpars_num_of_atoms,\n"
"				dockpars_gridsize_x,\n"
"				dockpars_gridsize_y,\n"
"				dockpars_gridsize_z,\n"
"				dockpars_fgrids,\n"
"				dockpars_num_of_atypes,\n"
"				dockpars_num_of_intraE_contributors,\n"
"				dockpars_grid_spacing,\n"
"				dockpars_coeff_elec,\n"
"				dockpars_qasp,\n"
"				dockpars_coeff_desolv,\n"
"				genotype_candidate,\n"
"				&candidate_energy,\n"
"				&run_id,\n"
"				// Some OpenCL compilers don't allow declaring \n"
"				// local variables within non-kernel functions.\n"
"				// These local variables must be declared in a kernel, \n"
"				// and then passed to non-kernel functions.\n"
"				calc_coords_x,\n"
"				calc_coords_y,\n"
"				calc_coords_z,\n"
"				partial_energies,\n"
"				#if defined (DEBUG_ENERGY_KERNEL3)\n"
"				partial_interE,\n"
"				partial_intraE,\n"
"				#endif\n"
"\n"
"				atom_charges_const,\n"
"				atom_types_const,\n"
"				intraE_contributors_const,\n"
"				VWpars_AC_const,\n"
"				VWpars_BD_const,\n"
"				dspars_S_const,\n"
"				dspars_V_const,\n"
"				rotlist_const,\n"
"				ref_coords_x_const,\n"
"				ref_coords_y_const,\n"
"				ref_coords_z_const,\n"
"				rotbonds_moving_vectors_const,\n"
"				rotbonds_unit_vectors_const,\n"
"				ref_orientation_quats_const\n"
"				);\n"
"		// =================================================================\n"
"\n"
"		if (get_local_id(0) == 0) {\n"
"			evaluation_cnt++;\n"
"\n"
"			#if defined (DEBUG_ENERGY_KERNEL3)\n"
"			printf(\"%-18s [%-5s]---{%-5s}   [%-10.8f]---{%-10.8f}\\n\", \"-ENERGY-KERNEL3-\", \"GRIDS\", \"INTRA\", partial_interE[0], partial_intraE[0]);\n"
"			#endif\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (candidate_energy < offspring_energy)	// If candidate is better, success\n"
"		{\n"
"			for (gene_counter = get_local_id(0);\n"
"			     gene_counter < dockpars_num_of_genes;\n"
"			     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"			{\n"
"				// Updating offspring_genotype\n"
"				offspring_genotype[gene_counter] = genotype_candidate[gene_counter];\n"
"\n"
"				// Updating genotype_bias\n"
"				genotype_bias[gene_counter] = 0.6f*genotype_bias[gene_counter] + 0.4f*genotype_deviate[gene_counter];\n"
"			}\n"
"\n"
"			// Work-item 0 will overwrite the shared variables\n"
"			// used in the previous if condition\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			if (get_local_id(0) == 0)\n"
"			{\n"
"				offspring_energy = candidate_energy;\n"
"				cons_succ++;\n"
"				cons_fail = 0;\n"
"			}\n"
"		}\n"
"		else	// If candidate is worser, check the opposite direction\n"
"		{\n"
"			// Generating the other genotype candidate\n"
"			for (gene_counter = get_local_id(0);\n"
"			     gene_counter < dockpars_num_of_genes;\n"
"			     gene_counter+= NUM_OF_THREADS_PER_BLOCK) {\n"
"\n"
"				// Shoemake genes (u1, u2, u3) ranges between [0,1]\n"
"				if ((gene_counter >= 3) && (gene_counter <= 5)) {\n"
"				   genotype_candidate[gene_counter] = gpu_randf(dockpars_prng_states);\n"
"				}\n"
"				// Other genes: translation and torsions\n"
"				else {\n"
"				   genotype_candidate[gene_counter] = offspring_genotype[gene_counter] - \n"
"								      genotype_deviate[gene_counter] - \n"
"								      genotype_bias[gene_counter];\n"
"				}\n"
"			}\n"
"\n"
"			//evaluating candidate\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			// =================================================================\n"
"			gpu_calc_energy(dockpars_rotbondlist_length,\n"
"					dockpars_num_of_atoms,\n"
"					dockpars_gridsize_x,\n"
"					dockpars_gridsize_y,\n"
"					dockpars_gridsize_z,\n"
"					dockpars_fgrids,\n"
"					dockpars_num_of_atypes,\n"
"					dockpars_num_of_intraE_contributors,\n"
"					dockpars_grid_spacing,\n"
"					dockpars_coeff_elec,\n"
"				        dockpars_qasp,\n"
"					dockpars_coeff_desolv,\n"
"					genotype_candidate,\n"
"					&candidate_energy,\n"
"					&run_id,\n"
"					// Some OpenCL compilers don't allow declaring \n"
"					// local variables within non-kernel functions.\n"
"					// These local variables must be declared in a kernel, \n"
"					// and then passed to non-kernel functions.\n"
"					calc_coords_x,\n"
"					calc_coords_y,\n"
"					calc_coords_z,\n"
"					partial_energies,\n"
"					#if defined (DEBUG_ENERGY_KERNEL3)\n"
"					partial_interE,\n"
"					partial_intraE,\n"
"					#endif\n"
"\n"
"					atom_charges_const,\n"
"					atom_types_const,\n"
"					intraE_contributors_const,\n"
"					VWpars_AC_const,\n"
"					VWpars_BD_const,\n"
"					dspars_S_const,\n"
"					dspars_V_const,\n"
"					rotlist_const,\n"
"					ref_coords_x_const,\n"
"					ref_coords_y_const,\n"
"					ref_coords_z_const,\n"
"					rotbonds_moving_vectors_const,\n"
"					rotbonds_unit_vectors_const,\n"
"					ref_orientation_quats_const\n"
"					);\n"
"			// =================================================================\n"
"\n"
"			if (get_local_id(0) == 0) {\n"
"				evaluation_cnt++;\n"
"\n"
"				#if defined (DEBUG_ENERGY_KERNEL3)\n"
"				printf(\"%-18s [%-5s]---{%-5s}   [%-10.8f]---{%-10.8f}\\n\", \"-ENERGY-KERNEL3-\", \"GRIDS\", \"INTRA\", partial_interE[0], partial_intraE[0]);\n"
"				#endif\n"
"			}\n"
"\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			if (candidate_energy < offspring_energy) // If candidate is better, success\n"
"			{\n"
"				for (gene_counter = get_local_id(0);\n"
"				     gene_counter < dockpars_num_of_genes;\n"
"			       	     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"				{\n"
"					// Updating offspring_genotype\n"
"					offspring_genotype[gene_counter] = genotype_candidate[gene_counter];\n"
"\n"
"					// Updating genotype_bias\n"
"					genotype_bias[gene_counter] = 0.6f*genotype_bias[gene_counter] - 0.4f*genotype_deviate[gene_counter];\n"
"				}\n"
"\n"
"				// Work-item 0 will overwrite the shared variables\n"
"				// used in the previous if condition\n"
"				barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"				if (get_local_id(0) == 0)\n"
"				{\n"
"					offspring_energy = candidate_energy;\n"
"					cons_succ++;\n"
"					cons_fail = 0;\n"
"				}\n"
"			}\n"
"			else	// Failure in both directions\n"
"			{\n"
"				for (gene_counter = get_local_id(0);\n"
"				     gene_counter < dockpars_num_of_genes;\n"
"				     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"					   // Updating genotype_bias\n"
"					   genotype_bias[gene_counter] = 0.5f*genotype_bias[gene_counter];\n"
"\n"
"				if (get_local_id(0) == 0)\n"
"				{\n"
"					cons_succ = 0;\n"
"					cons_fail++;\n"
"				}\n"
"			}\n"
"		}\n"
"\n"
"		// Changing rho if needed\n"
"		if (get_local_id(0) == 0)\n"
"		{\n"
"			iteration_cnt++;\n"
"\n"
"			if (cons_succ >= dockpars_cons_limit)\n"
"			{\n"
"				rho *= LS_EXP_FACTOR;\n"
"				cons_succ = 0;\n"
"			}\n"
"			else\n"
"				if (cons_fail >= dockpars_cons_limit)\n"
"				{\n"
"					rho *= LS_CONT_FACTOR;\n"
"					cons_fail = 0;\n"
"				}\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"	}\n"
"\n"
"	// Updating eval counter and energy\n"
"	if (get_local_id(0) == 0) {\n"
"		dockpars_evals_of_new_entities[run_id*dockpars_pop_size+entity_id] += evaluation_cnt;\n"
"		dockpars_energies_next[run_id*dockpars_pop_size+entity_id] = offspring_energy;\n"
"	}\n"
"\n"
"	// Mapping torsion angles\n"
"	for (gene_counter = get_local_id(0);\n"
"	     gene_counter < dockpars_num_of_genes;\n"
"	     gene_counter+= NUM_OF_THREADS_PER_BLOCK) {\n"
"		   if (gene_counter >= 6) {\n"
"			    map_angle(&(offspring_genotype[gene_counter]));\n"
"		   }\n"
"	}\n"
"\n"
"	// Updating old offspring in population\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"  	async_work_group_copy(dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"        	              offspring_genotype,\n"
"        	              dockpars_num_of_genes,0);\n"
"}\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gpu_gen_and_eval_newpops(\n"
"			 char   dockpars_num_of_atoms,\n"
"			 char   dockpars_num_of_atypes,\n"
"			 int    dockpars_num_of_intraE_contributors,\n"
"			 char   dockpars_gridsize_x,\n"
"			 char   dockpars_gridsize_y,\n"
"			 char   dockpars_gridsize_z,\n"
"			 float  dockpars_grid_spacing,\n"
"          __global const float* restrict dockpars_fgrids, // This is too large to be allocated in __constant \n"
"	                 int    dockpars_rotbondlist_length,\n"
" 			 float  dockpars_coeff_elec,\n"
"			 float  dockpars_coeff_desolv,\n"
"          __global const float* restrict  dockpars_conformations_current,\n"
"          __global       float* restrict  dockpars_energies_current,\n"
"          __global       float* restrict  dockpars_conformations_next,\n"
"          __global       float* restrict  dockpars_energies_next,\n"
"          __global       int*   restrict  dockpars_evals_of_new_entities,\n"
"          __global       uint*  restrict dockpars_prng_states,\n"
"	                 int    dockpars_pop_size,\n"
"	                 int    dockpars_num_of_genes,\n"
"		         float  dockpars_tournament_rate,\n"
"	                 float  dockpars_crossover_rate,\n"
"		         float  dockpars_mutation_rate,\n"
"		         float  dockpars_abs_max_dmov,\n"
"		         float  dockpars_abs_max_dang,\n"
"		         float  dockpars_qasp,\n"
"	      __constant float* atom_charges_const,\n"
"              __constant char*  atom_types_const,\n"
"	      __constant char*  intraE_contributors_const,\n"
"              __constant float* VWpars_AC_const,\n"
"              __constant float* VWpars_BD_const,\n"
"              __constant float* dspars_S_const,\n"
"              __constant float* dspars_V_const,\n"
"              __constant int*   rotlist_const,\n"
"              __constant float* ref_coords_x_const,\n"
"              __constant float* ref_coords_y_const,\n"
"              __constant float* ref_coords_z_const,\n"
"              __constant float* rotbonds_moving_vectors_const,\n"
"              __constant float* rotbonds_unit_vectors_const,\n"
"              __constant float* ref_orientation_quats_const\n"
")\n"
"//The GPU global function\n"
"{\n"
"	// Some OpenCL compilers don't allow declaring \n"
"	// local variables within non-kernel functions.\n"
"	// These local variables must be declared in a kernel, \n"
"	// and then passed to non-kernel functions.\n"
"	__local float offspring_genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"	__local int parent_candidates[4];\n"
"	__local float candidate_energies[4];\n"
"	__local int parents[2];\n"
"	__local int run_id;\n"
"	__local int covr_point[2];\n"
"	__local float randnums[10];\n"
"	int temp_covr_point;\n"
"	int gene_counter;\n"
"	__local float energy;	//could be shared since only thread 0 will use it\n"
"\n"
"	__local float best_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"	__local int best_IDs[NUM_OF_THREADS_PER_BLOCK];\n"
"        __local int best_ID[1]; //__local int best_ID;\n"
"\n"
"	__local float calc_coords_x[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_y[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_z[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"	#if defined (DEBUG_ENERGY_KERNEL4)\n"
"	__local float partial_interE [NUM_OF_THREADS_PER_BLOCK];\n"
"	__local float partial_intraE [NUM_OF_THREADS_PER_BLOCK];\n"
"	#endif\n"
"\n"
"	// In this case this compute-unit is responsible for elitist selection\n"
"	if ((get_group_id(0) % dockpars_pop_size) == 0) {\n"
"		gpu_perform_elitist_selection(dockpars_pop_size,\n"
"					      dockpars_energies_current,\n"
"					      dockpars_energies_next,\n"
"					      dockpars_evals_of_new_entities,\n"
"					      dockpars_num_of_genes,\n"
"					      dockpars_conformations_next,\n"
"				              dockpars_conformations_current,\n"
"					      best_energies,\n"
"					      best_IDs,\n"
"					      best_ID);\n"
"	}\n"
"	else\n"
"	{\n"
"		// Generating the following random numbers: \n"
"		// [0..3] for parent candidates,\n"
"		// [4..5] for binary tournaments, [6] for deciding crossover,\n"
"		// [7..8] for crossover points, [9] for local search\n"
"		for (gene_counter = get_local_id(0);\n"
"		     gene_counter < 10;\n"
"		     gene_counter+= NUM_OF_THREADS_PER_BLOCK) {\n"
"			randnums[gene_counter] = gpu_randf(dockpars_prng_states);\n"
"		}\n"
"\n"
"		// Determining run ID\n"
"		if (get_local_id(0) == 0) {\n"
"			run_id = get_group_id(0) / dockpars_pop_size;\n"
"		}\n"
"\n"
"		// Performing binary tournament selection\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (get_local_id(0) < 4)	//it is not ensured that the four candidates will be different...\n"
"		{\n"
"			parent_candidates[get_local_id(0)]  = (int) (dockpars_pop_size*randnums[get_local_id(0)]); //using randnums[0..3]\n"
"			candidate_energies[get_local_id(0)] = dockpars_energies_current[run_id*dockpars_pop_size+parent_candidates[get_local_id(0)]];\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (get_local_id(0) < 2) \n"
"		{\n"
"			if (candidate_energies[2*get_local_id(0)] < candidate_energies[2*get_local_id(0)+1])\n"
"				if (100.0f*randnums[4+get_local_id(0)] < dockpars_tournament_rate) {		//using randnum[4..5]\n"
"					parents[get_local_id(0)] = parent_candidates[2*get_local_id(0)];\n"
"				}\n"
"				else {\n"
"					parents[get_local_id(0)] = parent_candidates[2*get_local_id(0)+1];\n"
"				}\n"
"			else\n"
"				if (100.0f*randnums[4+get_local_id(0)] < dockpars_tournament_rate) {\n"
"					parents[get_local_id(0)] = parent_candidates[2*get_local_id(0)+1];\n"
"				}\n"
"				else {\n"
"					parents[get_local_id(0)] = parent_candidates[2*get_local_id(0)];\n"
"				}\n"
"		}\n"
"\n"
"		// Performing crossover\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (100.0f*randnums[6] < dockpars_crossover_rate)	// Using randnums[6]\n"
"		{\n"
"			if (get_local_id(0) < 2) {\n"
"				// Using randnum[7..8]\n"
"				covr_point[get_local_id(0)] = (int) ((dockpars_num_of_genes-1)*randnums[7+get_local_id(0)]);\n"
"			}\n"
"\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"			\n"
"			// covr_point[0] should store the lower crossover-point\n"
"			if (get_local_id(0) == 0) {\n"
"				if (covr_point[1] < covr_point[0]) {\n"
"					temp_covr_point = covr_point[1];\n"
"					covr_point[1]   = covr_point[0];\n"
"					covr_point[0]   = temp_covr_point;\n"
"				}\n"
"			}\n"
"\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			for (gene_counter = get_local_id(0);\n"
"			     gene_counter < dockpars_num_of_genes;\n"
"			     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"			{\n"
"				// Two-point crossover\n"
"				if (covr_point[0] != covr_point[1]) \n"
"				{\n"
"					if ((gene_counter <= covr_point[0]) || (gene_counter > covr_point[1]))\n"
"						offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[0])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"					else\n"
"						offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[1])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"				}\n"
"				// Single-point crossover\n"
"				else\n"
"				{									             \n"
"					if (gene_counter <= covr_point[0])\n"
"						offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[0])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"					else\n"
"						offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[1])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"				}\n"
"			}\n"
"\n"
"		}\n"
"		else	//no crossover\n"
"		{\n"
"			async_work_group_copy(offspring_genotype,\n"
"					     dockpars_conformations_current+(run_id*dockpars_pop_size+parents[0])*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"					     dockpars_num_of_genes, 0);\n"
"		} // End of crossover\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// Performing mutation\n"
"		for (gene_counter = get_local_id(0);\n"
"		     gene_counter < dockpars_num_of_genes;\n"
"		     gene_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			if (100.0f*gpu_randf(dockpars_prng_states) < dockpars_mutation_rate)\n"
"			{\n"
"				// Translation genes\n"
"				if (gene_counter <= 2) {\n"
"					offspring_genotype[gene_counter] += dockpars_abs_max_dmov*(2*gpu_randf(dockpars_prng_states)-1);\n"
"				}\n"
"				// Shoemake genes (u1, u2, u3) ranges between [0,1]\n"
"				else if (gene_counter <= 5) {\n"
"					offspring_genotype[gene_counter] = gpu_randf(dockpars_prng_states);\n"
"				}\n"
"				// Torsion genes\n"
"				else {\n"
"					offspring_genotype[gene_counter] += dockpars_abs_max_dang*(2*gpu_randf(dockpars_prng_states)-1);\n"
"					map_angle(&(offspring_genotype[gene_counter]));\n"
"				}\n"
"\n"
"			}\n"
"		} // End of mutation\n"
"\n"
"		// Calculating energy of new offspring\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// =============================================================\n"
"		gpu_calc_energy(dockpars_rotbondlist_length,\n"
"				dockpars_num_of_atoms,\n"
"				dockpars_gridsize_x,\n"
"				dockpars_gridsize_y,\n"
"	                        dockpars_gridsize_z,\n"
"				dockpars_fgrids,\n"
"				dockpars_num_of_atypes,\n"
"				dockpars_num_of_intraE_contributors,\n"
"				dockpars_grid_spacing,\n"
"				dockpars_coeff_elec,\n"
"                                dockpars_qasp,\n"
"				dockpars_coeff_desolv,\n"
"				offspring_genotype,\n"
"				&energy,\n"
"				&run_id,\n"
"				// Some OpenCL compilers don't allow declaring \n"
"				// local variables within non-kernel functions.\n"
"				// These local variables must be declared in a kernel, \n"
"				// and then passed to non-kernel functions.\n"
"				calc_coords_x,\n"
"				calc_coords_y,\n"
"				calc_coords_z,\n"
"				partial_energies,\n"
"				#if defined (DEBUG_ENERGY_KERNEL4)\n"
"				partial_interE,\n"
"				partial_intraE,\n"
"				#endif\n"
"		\n"
"                                atom_charges_const,\n"
"	                        atom_types_const,\n"
"				intraE_contributors_const,\n"
"				VWpars_AC_const,\n"
"				VWpars_BD_const,\n"
"				dspars_S_const,\n"
"				dspars_V_const,\n"
"				rotlist_const,\n"
"				ref_coords_x_const,\n"
"				ref_coords_y_const,\n"
"				ref_coords_z_const,\n"
"				rotbonds_moving_vectors_const,\n"
"				rotbonds_unit_vectors_const,\n"
"				ref_orientation_quats_const\n"
"				);\n"
"		// =============================================================\n"
"\n"
"		if (get_local_id(0) == 0) {\n"
"			dockpars_evals_of_new_entities[get_group_id(0)] = 1;\n"
"			dockpars_energies_next[get_group_id(0)] = energy;\n"
"\n"
"			#if defined (DEBUG_ENERGY_KERNEL4)\n"
"			printf(\"%-18s [%-5s]---{%-5s}   [%-10.8f]---{%-10.8f}\\n\", \"-ENERGY-KERNEL4-\", \"GRIDS\", \"INTRA\", partial_interE[0], partial_intraE[0]);\n"
"			#endif\n"
"		}\n"
"\n"
"		// Copying new offspring to next generation\n"
"		async_work_group_copy(dockpars_conformations_next + GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0),\n"
"				      offspring_genotype,\n"
"				      dockpars_num_of_genes, 0);\n"
"  }\n"
"}\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"/*\n"
"*/\n"
"// All related pragmas are in defines.h (accesible by host and device code)\n"
"\n"
"\n"
"// The GPU device function calculates the energy's gradient (forces or derivatives) \n"
"// of the entity described by genotype, dockpars and the ligand-data\n"
"// arrays in constant memory and returns it in the \"gradient_genotype\" parameter. \n"
"// The parameter \"run_id\" has to be equal to the ID of the run \n"
"// whose population includes the current entity (which can be determined with get_group_id(0)), \n"
"// since this determines which reference orientation should be used.\n"
"\n"
"\n"
"//#define DEBUG_GRAD_TRANSLATION_GENES\n"
"//#define DEBUG_GRAD_ROTATION_GENES\n"
"//#define DEBUG_GRAD_TORSION_GENES\n"
"//#define DEBUG_ENERGY_KERNEL5\n"
"\n"
"void gpu_calc_gradient(	    \n"
"				int    dockpars_rotbondlist_length,\n"
"				char   dockpars_num_of_atoms,\n"
"			    	char   dockpars_gridsize_x,\n"
"			    	char   dockpars_gridsize_y,\n"
"			    	char   dockpars_gridsize_z,\n"
"		 __global const float* restrict dockpars_fgrids, // This is too large to be allocated in __constant \n"
"		            	char   dockpars_num_of_atypes,\n"
"		            	int    dockpars_num_of_intraE_contributors,\n"
"			    	float  dockpars_grid_spacing,\n"
"			    	float  dockpars_coeff_elec,\n"
"			    	float  dockpars_qasp,\n"
"			    	float  dockpars_coeff_desolv,\n"
"\n"
"				// Some OpenCL compilers don't allow declaring \n"
"				// local variables within non-kernel functions.\n"
"				// These local variables must be declared in a kernel, \n"
"				// and then passed to non-kernel functions.\n"
"		    	__local float* genotype,\n"
"			__local float* energy,\n"
"		    	__local int*   run_id,\n"
"\n"
"		    	__local float* calc_coords_x,\n"
"		    	__local float* calc_coords_y,\n"
"		    	__local float* calc_coords_z,\n"
"\n"
"	             __constant float* atom_charges_const,\n"
"                     __constant char*  atom_types_const,\n"
"                     __constant char*  intraE_contributors_const,\n"
"                     __constant float* VWpars_AC_const,\n"
"                     __constant float* VWpars_BD_const,\n"
"                     __constant float* dspars_S_const,\n"
"                     __constant float* dspars_V_const,\n"
"                     __constant int*   rotlist_const,\n"
"                     __constant float* ref_coords_x_const,\n"
"                     __constant float* ref_coords_y_const,\n"
"                     __constant float* ref_coords_z_const,\n"
"                     __constant float* rotbonds_moving_vectors_const,\n"
"                     __constant float* rotbonds_unit_vectors_const,\n"
"                     __constant float* ref_orientation_quats_const,\n"
"		     __constant int*   rotbonds_const,\n"
"		     __constant int*   rotbonds_atoms_const,\n"
"		     __constant int*   num_rotating_atoms_per_rotbond_const\n"
"\n"
"		    // Gradient-related arguments\n"
"		    // Calculate gradients (forces) for intermolecular energy\n"
"		    // Derived from autodockdev/maps.py\n"
"		    // \"is_enabled_gradient_calc\": enables gradient calculation.\n"
"		    // In Genetic-Generation: no need for gradients\n"
"		    // In Gradient-Minimizer: must calculate gradients\n"
"			,\n"
"			    int    dockpars_num_of_genes,\n"
"	    	    __local float* gradient_inter_x,\n"
"	            __local float* gradient_inter_y,\n"
"	            __local float* gradient_inter_z,\n"
"		    __local float* gradient_intra_x,\n"
"		    __local float* gradient_intra_y,\n"
"		    __local float* gradient_intra_z,\n"
"		    __local float* gradient_x,\n"
"		    __local float* gradient_y,\n"
"		    __local float* gradient_z,\n"
"	            __local float* gradient_per_intracontributor,\n"
"		    __local float* gradient_genotype			\n"
")\n"
"{\n"
"	// Initializing gradients (forces) \n"
"	// Derived from autodockdev/maps.py\n"
"	for (uint atom_id = get_local_id(0);\n"
"		  atom_id < dockpars_num_of_atoms;\n"
"		  atom_id+= NUM_OF_THREADS_PER_BLOCK) {\n"
"		// Intermolecular gradients\n"
"		gradient_inter_x[atom_id] = 0.0f;\n"
"		gradient_inter_y[atom_id] = 0.0f;\n"
"		gradient_inter_z[atom_id] = 0.0f;\n"
"		// Intramolecular gradients\n"
"		gradient_intra_x[atom_id] = 0.0f;\n"
"		gradient_intra_y[atom_id] = 0.0f;\n"
"		gradient_intra_z[atom_id] = 0.0f;\n"
"	}\n"
"\n"
"	// Initializing gradients per intramolecular contributor pairs \n"
"	for (uint intracontrib_atompair_id = get_local_id(0);\n"
"		  intracontrib_atompair_id < dockpars_num_of_intraE_contributors;\n"
"		  intracontrib_atompair_id+= NUM_OF_THREADS_PER_BLOCK) {\n"
"		gradient_per_intracontributor[intracontrib_atompair_id] = 0.0f;\n"
"	}\n"
"\n"
"	// Initializing gradient genotypes\n"
"	for (uint gene_cnt = get_local_id(0);\n"
"		  gene_cnt < dockpars_num_of_genes;\n"
"		  gene_cnt+= NUM_OF_THREADS_PER_BLOCK) {\n"
"		gradient_genotype[gene_cnt] = 0.0f;\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	uchar g1 = dockpars_gridsize_x;\n"
"	uint  g2 = dockpars_gridsize_x * dockpars_gridsize_y;\n"
"  	uint  g3 = dockpars_gridsize_x * dockpars_gridsize_y * dockpars_gridsize_z;\n"
"\n"
"\n"
"	// ================================================\n"
"	// CALCULATING ATOMIC POSITIONS AFTER ROTATIONS\n"
"	// ================================================\n"
"	for (uint rotation_counter = get_local_id(0);\n"
"	          rotation_counter < dockpars_rotbondlist_length;\n"
"	          rotation_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		int rotation_list_element = rotlist_const[rotation_counter];\n"
"\n"
"		if ((rotation_list_element & RLIST_DUMMY_MASK) == 0)	// If not dummy rotation\n"
"		{\n"
"			uint atom_id = rotation_list_element & RLIST_ATOMID_MASK;\n"
"\n"
"			// Capturing atom coordinates\n"
"			float atom_to_rotate[3];\n"
"\n"
"			if ((rotation_list_element & RLIST_FIRSTROT_MASK) != 0)	// If first rotation of this atom\n"
"			{\n"
"				atom_to_rotate[0] = ref_coords_x_const[atom_id];\n"
"				atom_to_rotate[1] = ref_coords_y_const[atom_id];\n"
"				atom_to_rotate[2] = ref_coords_z_const[atom_id];\n"
"			}\n"
"			else\n"
"			{\n"
"				atom_to_rotate[0] = calc_coords_x[atom_id];\n"
"				atom_to_rotate[1] = calc_coords_y[atom_id];\n"
"				atom_to_rotate[2] = calc_coords_z[atom_id];\n"
"			}\n"
"\n"
"			// Capturing rotation vectors and angle\n"
"			float rotation_movingvec[3];\n"
"\n"
"			float quatrot_left_x, quatrot_left_y, quatrot_left_z, quatrot_left_q;\n"
"			float quatrot_temp_x, quatrot_temp_y, quatrot_temp_z, quatrot_temp_q;\n"
"\n"
"			if ((rotation_list_element & RLIST_GENROT_MASK) != 0)	// If general rotation\n"
"			{\n"
"				// Rotational genes in the Shoemake space are expressed in radians\n"
"				float u1 = genotype[3];\n"
"				float u2 = genotype[4];\n"
"				float u3 = genotype[5];\n"
"\n"
"				// u1, u2, u3 should be within their valid range of [0,1]\n"
"				quatrot_left_q = native_sqrt(1 - u1) * native_sin(PI_TIMES_2*u2); \n"
"				quatrot_left_x = native_sqrt(1 - u1) * native_cos(PI_TIMES_2*u2);\n"
"				quatrot_left_y = native_sqrt(u1)     * native_sin(PI_TIMES_2*u3);\n"
"				quatrot_left_z = native_sqrt(u1)     * native_cos(PI_TIMES_2*u3);\n"
"\n"
"				rotation_movingvec[0] = genotype[0];\n"
"				rotation_movingvec[1] = genotype[1];\n"
"				rotation_movingvec[2] = genotype[2];\n"
"			}\n"
"			else	// If rotating around rotatable bond\n"
"			{\n"
"				uint rotbond_id = (rotation_list_element & RLIST_RBONDID_MASK) >> RLIST_RBONDID_SHIFT;\n"
"\n"
"				float rotation_unitvec[3];\n"
"				rotation_unitvec[0] = rotbonds_unit_vectors_const[3*rotbond_id];\n"
"				rotation_unitvec[1] = rotbonds_unit_vectors_const[3*rotbond_id+1];\n"
"				rotation_unitvec[2] = rotbonds_unit_vectors_const[3*rotbond_id+2];\n"
"				float rotation_angle = genotype[6+rotbond_id]*DEG_TO_RAD;\n"
"\n"
"				rotation_movingvec[0] = rotbonds_moving_vectors_const[3*rotbond_id];\n"
"				rotation_movingvec[1] = rotbonds_moving_vectors_const[3*rotbond_id+1];\n"
"				rotation_movingvec[2] = rotbonds_moving_vectors_const[3*rotbond_id+2];\n"
"\n"
"				// Performing additionally the first movement which \n"
"				// is needed only if rotating around rotatable bond\n"
"				atom_to_rotate[0] -= rotation_movingvec[0];\n"
"				atom_to_rotate[1] -= rotation_movingvec[1];\n"
"				atom_to_rotate[2] -= rotation_movingvec[2];\n"
"\n"
"				// Transforming torsion angles into quaternions\n"
"				rotation_angle  = native_divide(rotation_angle, 2.0f);\n"
"				float sin_angle = native_sin(rotation_angle);\n"
"				quatrot_left_q  = native_cos(rotation_angle);\n"
"				quatrot_left_x  = sin_angle*rotation_unitvec[0];\n"
"				quatrot_left_y  = sin_angle*rotation_unitvec[1];\n"
"				quatrot_left_z  = sin_angle*rotation_unitvec[2];\n"
"			}\n"
"\n"
"			// Performing rotation\n"
"			if ((rotation_list_element & RLIST_GENROT_MASK) != 0)	// If general rotation,\n"
"										// two rotations should be performed\n"
"										// (multiplying the quaternions)\n"
"			{\n"
"				// Calculating quatrot_left*ref_orientation_quats_const,\n"
"				// which means that reference orientation rotation is the first\n"
"				quatrot_temp_q = quatrot_left_q;\n"
"				quatrot_temp_x = quatrot_left_x;\n"
"				quatrot_temp_y = quatrot_left_y;\n"
"				quatrot_temp_z = quatrot_left_z;\n"
"\n"
"				quatrot_left_q = quatrot_temp_q*ref_orientation_quats_const[4*(*run_id)]-\n"
"						 quatrot_temp_x*ref_orientation_quats_const[4*(*run_id)+1]-\n"
"						 quatrot_temp_y*ref_orientation_quats_const[4*(*run_id)+2]-\n"
"						 quatrot_temp_z*ref_orientation_quats_const[4*(*run_id)+3];\n"
"				quatrot_left_x = quatrot_temp_q*ref_orientation_quats_const[4*(*run_id)+1]+\n"
"						 ref_orientation_quats_const[4*(*run_id)]*quatrot_temp_x+\n"
"						 quatrot_temp_y*ref_orientation_quats_const[4*(*run_id)+3]-\n"
"						 ref_orientation_quats_const[4*(*run_id)+2]*quatrot_temp_z;\n"
"				quatrot_left_y = quatrot_temp_q*ref_orientation_quats_const[4*(*run_id)+2]+\n"
"						 ref_orientation_quats_const[4*(*run_id)]*quatrot_temp_y+\n"
"						 ref_orientation_quats_const[4*(*run_id)+1]*quatrot_temp_z-\n"
"						 quatrot_temp_x*ref_orientation_quats_const[4*(*run_id)+3];\n"
"				quatrot_left_z = quatrot_temp_q*ref_orientation_quats_const[4*(*run_id)+3]+\n"
"						 ref_orientation_quats_const[4*(*run_id)]*quatrot_temp_z+\n"
"						 quatrot_temp_x*ref_orientation_quats_const[4*(*run_id)+2]-\n"
"						 ref_orientation_quats_const[4*(*run_id)+1]*quatrot_temp_y;\n"
"			}\n"
"\n"
"			quatrot_temp_q = 0 -\n"
"					 quatrot_left_x*atom_to_rotate [0] -\n"
"					 quatrot_left_y*atom_to_rotate [1] -\n"
"					 quatrot_left_z*atom_to_rotate [2];\n"
"			quatrot_temp_x = quatrot_left_q*atom_to_rotate [0] +\n"
"					 quatrot_left_y*atom_to_rotate [2] -\n"
"					 quatrot_left_z*atom_to_rotate [1];\n"
"			quatrot_temp_y = quatrot_left_q*atom_to_rotate [1] -\n"
"					 quatrot_left_x*atom_to_rotate [2] +\n"
"					 quatrot_left_z*atom_to_rotate [0];\n"
"			quatrot_temp_z = quatrot_left_q*atom_to_rotate [2] +\n"
"					 quatrot_left_x*atom_to_rotate [1] -\n"
"					 quatrot_left_y*atom_to_rotate [0];\n"
"\n"
"			atom_to_rotate [0] = 0 -\n"
"					  quatrot_temp_q*quatrot_left_x +\n"
"					  quatrot_temp_x*quatrot_left_q -\n"
"					  quatrot_temp_y*quatrot_left_z +\n"
"					  quatrot_temp_z*quatrot_left_y;\n"
"			atom_to_rotate [1] = 0 -\n"
"					  quatrot_temp_q*quatrot_left_y +\n"
"					  quatrot_temp_x*quatrot_left_z +\n"
"					  quatrot_temp_y*quatrot_left_q -\n"
"					  quatrot_temp_z*quatrot_left_x;\n"
"			atom_to_rotate [2] = 0 -\n"
"					  quatrot_temp_q*quatrot_left_z -\n"
"					  quatrot_temp_x*quatrot_left_y +\n"
"					  quatrot_temp_y*quatrot_left_x +\n"
"					  quatrot_temp_z*quatrot_left_q;\n"
"\n"
"			// Performing final movement and storing values\n"
"			calc_coords_x[atom_id] = atom_to_rotate [0] + rotation_movingvec[0];\n"
"			calc_coords_y[atom_id] = atom_to_rotate [1] + rotation_movingvec[1];\n"
"			calc_coords_z[atom_id] = atom_to_rotate [2] + rotation_movingvec[2];\n"
"\n"
"		} // End if-statement not dummy rotation\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	} // End rotation_counter for-loop\n"
"\n"
"	// ================================================\n"
"	// CALCULATING INTERMOLECULAR GRADIENTS\n"
"	// ================================================\n"
"	for (uint atom_id = get_local_id(0);\n"
"	          atom_id < dockpars_num_of_atoms;\n"
"	          atom_id+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		uint atom_typeid = atom_types_const[atom_id];\n"
"		float x = calc_coords_x[atom_id];\n"
"		float y = calc_coords_y[atom_id];\n"
"		float z = calc_coords_z[atom_id];\n"
"		float q = atom_charges_const[atom_id];\n"
"\n"
"		if ((x < 0) || (y < 0) || (z < 0) || (x >= dockpars_gridsize_x-1)\n"
"				                  || (y >= dockpars_gridsize_y-1)\n"
"						  || (z >= dockpars_gridsize_z-1)){\n"
"			\n"
"			// Setting gradients (forces) penalties.\n"
"			// These are valid as long as they are high\n"
"			gradient_inter_x[atom_id] += 16777216.0f;\n"
"			gradient_inter_y[atom_id] += 16777216.0f;\n"
"			gradient_inter_z[atom_id] += 16777216.0f;\n"
"		}\n"
"		else\n"
"		{\n"
"			// Getting coordinates\n"
"			int x_low  = (int)floor(x); \n"
"			int y_low  = (int)floor(y); \n"
"			int z_low  = (int)floor(z);\n"
"			int x_high = (int)ceil(x); \n"
"			int y_high = (int)ceil(y); \n"
"			int z_high = (int)ceil(z);\n"
"			float dx = x - x_low; \n"
"			float dy = y - y_low; \n"
"			float dz = z - z_low;\n"
"\n"
"			//printf(\"%-15s %-5u %-10.8f %-10.8f %-10.8f\\n\", \"dx,dy,dz\", atom_id, dx, dy, dz);\n"
"\n"
"			// Calculating interpolation weights\n"
"			float weights[2][2][2];\n"
"			weights [0][0][0] = (1-dx)*(1-dy)*(1-dz);\n"
"			weights [1][0][0] = dx*(1-dy)*(1-dz);\n"
"			weights [0][1][0] = (1-dx)*dy*(1-dz);\n"
"			weights [1][1][0] = dx*dy*(1-dz);\n"
"			weights [0][0][1] = (1-dx)*(1-dy)*dz;\n"
"			weights [1][0][1] = dx*(1-dy)*dz;\n"
"			weights [0][1][1] = (1-dx)*dy*dz;\n"
"			weights [1][1][1] = dx*dy*dz;\n"
"\n"
"			// Capturing affinity values\n"
"			uint ylow_times_g1  = y_low*g1;\n"
"			uint yhigh_times_g1 = y_high*g1;\n"
"		  	uint zlow_times_g2  = z_low*g2;\n"
"			uint zhigh_times_g2 = z_high*g2;\n"
"\n"
"			// Grid offset\n"
"			uint offset_cube_000 = x_low  + ylow_times_g1  + zlow_times_g2;\n"
"			uint offset_cube_100 = x_high + ylow_times_g1  + zlow_times_g2;\n"
"			uint offset_cube_010 = x_low  + yhigh_times_g1 + zlow_times_g2;\n"
"			uint offset_cube_110 = x_high + yhigh_times_g1 + zlow_times_g2;\n"
"			uint offset_cube_001 = x_low  + ylow_times_g1  + zhigh_times_g2;\n"
"			uint offset_cube_101 = x_high + ylow_times_g1  + zhigh_times_g2;\n"
"			uint offset_cube_011 = x_low  + yhigh_times_g1 + zhigh_times_g2;\n"
"			uint offset_cube_111 = x_high + yhigh_times_g1 + zhigh_times_g2;\n"
"\n"
"			uint mul_tmp = atom_typeid*g3;\n"
"\n"
"			float cube[2][2][2];\n"
"			cube [0][0][0] = *(dockpars_fgrids + offset_cube_000 + mul_tmp);\n"
"			cube [1][0][0] = *(dockpars_fgrids + offset_cube_100 + mul_tmp);\n"
"			cube [0][1][0] = *(dockpars_fgrids + offset_cube_010 + mul_tmp);\n"
"		        cube [1][1][0] = *(dockpars_fgrids + offset_cube_110 + mul_tmp);\n"
"		        cube [0][0][1] = *(dockpars_fgrids + offset_cube_001 + mul_tmp);\n"
"			cube [1][0][1] = *(dockpars_fgrids + offset_cube_101 + mul_tmp);\n"
"                        cube [0][1][1] = *(dockpars_fgrids + offset_cube_011 + mul_tmp);\n"
"                        cube [1][1][1] = *(dockpars_fgrids + offset_cube_111 + mul_tmp);\n"
"\n"
"			// -------------------------------------------------------------------\n"
"			// Deltas dx, dy, dz are already normalized \n"
"			// (by host/src/getparameters.cpp) in OCLaDock.\n"
"			// The correspondance between vertices in xyz axes is:\n"
"			// 0, 1, 2, 3, 4, 5, 6, 7  and  000, 100, 010, 001, 101, 110, 011, 111\n"
"			// -------------------------------------------------------------------\n"
"			/*\n"
"			    deltas: (x-x0)/(x1-x0), (y-y0...\n"
"			    vertices: (000, 100, 010, 001, 101, 110, 011, 111)        \n"
"\n"
"				  Z\n"
"				  '\n"
"				  3 - - - - 6\n"
"				 /.        /|\n"
"				4 - - - - 7 |\n"
"				| '       | |\n"
"				| 0 - - - + 2 -- Y\n"
"				'/        |/\n"
"				1 - - - - 5\n"
"			       /\n"
"			      X\n"
"			*/\n"
"\n"
"			// Intermediate values for vectors in x-direction\n"
"			float x10, x52, x43, x76;\n"
"			float vx_z0, vx_z1;\n"
"\n"
"			// Intermediate values for vectors in y-direction\n"
"			float y20, y51, y63, y74;\n"
"			float vy_z0, vy_z1;\n"
"\n"
"			// Intermediate values for vectors in z-direction\n"
"			float z30, z41, z62, z75;\n"
"			float vz_y0, vz_y1;\n"
"\n"
"			// -------------------------------------------------------------------\n"
"			// Calculating gradients (forces) corresponding to \n"
"			// \"atype\" intermolecular energy\n"
"			// Derived from autodockdev/maps.py\n"
"			// -------------------------------------------------------------------\n"
"\n"
"			// Vector in x-direction\n"
"			x10 = cube [1][0][0] - cube [0][0][0]; // z = 0\n"
"			x52 = cube [1][1][0] - cube [0][1][0]; // z = 0\n"
"			x43 = cube [1][0][1] - cube [0][0][1]; // z = 1\n"
"			x76 = cube [1][1][1] - cube [0][1][1]; // z = 1\n"
"			vx_z0 = (1 - dy) * x10 + dy * x52;     // z = 0\n"
"			vx_z1 = (1 - dy) * x43 + dy * x76;     // z = 1\n"
"			gradient_inter_x[atom_id] += (1 - dz) * vx_z0 + dz * vx_z1;\n"
"\n"
"			// Vector in y-direction\n"
"			y20 = cube[0][1][0] - cube [0][0][0];	// z = 0\n"
"			y51 = cube[1][1][0] - cube [1][0][0];	// z = 0\n"
"			y63 = cube[0][1][1] - cube [0][0][1];	// z = 1\n"
"			y74 = cube[1][1][1] - cube [1][0][1];	// z = 1\n"
"			vy_z0 = (1 - dx) * y20 + dx * y51;	// z = 0\n"
"			vy_z1 = (1 - dx) * y63 + dx * y74;	// z = 1\n"
"			gradient_inter_y[atom_id] += (1 - dz) * vy_z0 + dz * vy_z1;\n"
"\n"
"			// Vectors in z-direction\n"
"			z30 = cube [0][0][1] - cube [0][0][0];	// y = 0\n"
"			z41 = cube [1][0][1] - cube [1][0][0];	// y = 0\n"
"			z62 = cube [0][1][1] - cube [0][1][0];	// y = 1 \n"
"			z75 = cube [1][1][1] - cube [1][1][0];	// y = 1\n"
"			vz_y0 = (1 - dx) * z30 + dx * z41;	// y = 0\n"
"			vz_y1 = (1 - dx) * z62 + dx * z75;	// y = 1\n"
"			gradient_inter_z[atom_id] += (1 - dy) * vz_y0 + dy * vz_y1;\n"
"\n"
"			//printf(\"%-15s %-3u %-10.8f %-10.8f %-10.8f %-10.8f %-10.8f %-10.8f\\n\", \"atom aff\", atom_id, vx_z0, vx_z1, vy_z0, vy_z1, vz_y0, vz_y1);\n"
"\n"
"			// -------------------------------------------------------------------\n"
"			// Calculating gradients (forces) corresponding to \n"
"			// \"elec\" intermolecular energy\n"
"			// Derived from autodockdev/maps.py\n"
"			// -------------------------------------------------------------------\n"
"\n"
"			// Capturing electrostatic values\n"
"			atom_typeid = dockpars_num_of_atypes;\n"
"\n"
"			mul_tmp = atom_typeid*g3;\n"
"			cube [0][0][0] = *(dockpars_fgrids + offset_cube_000 + mul_tmp);\n"
"			cube [1][0][0] = *(dockpars_fgrids + offset_cube_100 + mul_tmp);\n"
"      			cube [0][1][0] = *(dockpars_fgrids + offset_cube_010 + mul_tmp);\n"
"      			cube [1][1][0] = *(dockpars_fgrids + offset_cube_110 + mul_tmp);\n"
"		       	cube [0][0][1] = *(dockpars_fgrids + offset_cube_001 + mul_tmp);\n"
"		        cube [1][0][1] = *(dockpars_fgrids + offset_cube_101 + mul_tmp);\n"
"		        cube [0][1][1] = *(dockpars_fgrids + offset_cube_011 + mul_tmp);\n"
"		        cube [1][1][1] = *(dockpars_fgrids + offset_cube_111 + mul_tmp);\n"
"\n"
"			// Vector in x-direction\n"
"			x10 = cube [1][0][0] - cube [0][0][0]; // z = 0\n"
"			x52 = cube [1][1][0] - cube [0][1][0]; // z = 0\n"
"			x43 = cube [1][0][1] - cube [0][0][1]; // z = 1\n"
"			x76 = cube [1][1][1] - cube [0][1][1]; // z = 1\n"
"			vx_z0 = (1 - dy) * x10 + dy * x52;     // z = 0\n"
"			vx_z1 = (1 - dy) * x43 + dy * x76;     // z = 1\n"
"			gradient_inter_x[atom_id] += q * ((1 - dz) * vx_z0 + dz * vx_z1);\n"
"\n"
"			// Vector in y-direction\n"
"			y20 = cube[0][1][0] - cube [0][0][0];	// z = 0\n"
"			y51 = cube[1][1][0] - cube [1][0][0];	// z = 0\n"
"			y63 = cube[0][1][1] - cube [0][0][1];	// z = 1\n"
"			y74 = cube[1][1][1] - cube [1][0][1];	// z = 1\n"
"			vy_z0 = (1 - dx) * y20 + dx * y51;	// z = 0\n"
"			vy_z1 = (1 - dx) * y63 + dx * y74;	// z = 1\n"
"			gradient_inter_y[atom_id] += q *((1 - dz) * vy_z0 + dz * vy_z1);\n"
"\n"
"			// Vectors in z-direction\n"
"			z30 = cube [0][0][1] - cube [0][0][0];	// y = 0\n"
"			z41 = cube [1][0][1] - cube [1][0][0];	// y = 0\n"
"			z62 = cube [0][1][1] - cube [0][1][0];	// y = 1 \n"
"			z75 = cube [1][1][1] - cube [1][1][0];	// y = 1\n"
"			vz_y0 = (1 - dx) * z30 + dx * z41;	// y = 0\n"
"			vz_y1 = (1 - dx) * z62 + dx * z75;	// y = 1\n"
"			gradient_inter_z[atom_id] += q *((1 - dy) * vz_y0 + dy * vz_y1);\n"
"\n"
"			//printf(\"%-15s %-3u %-10.8f %-10.8f %-10.8f %-10.8f %-10.8f %-10.8f\\n\", \"elec\", atom_id, vx_z0, vx_z1, vy_z0, vy_z1, vz_y0, vz_y1);\n"
"\n"
"			// -------------------------------------------------------------------\n"
"			// Calculating gradients (forces) corresponding to \n"
"			// \"dsol\" intermolecular energy\n"
"			// Derived from autodockdev/maps.py\n"
"			// -------------------------------------------------------------------\n"
"\n"
"			// Capturing desolvation values\n"
"			atom_typeid = dockpars_num_of_atypes+1;\n"
"\n"
"			mul_tmp = atom_typeid*g3;\n"
"			cube [0][0][0] = *(dockpars_fgrids + offset_cube_000 + mul_tmp);\n"
"			cube [1][0][0] = *(dockpars_fgrids + offset_cube_100 + mul_tmp);\n"
"      			cube [0][1][0] = *(dockpars_fgrids + offset_cube_010 + mul_tmp);\n"
"      			cube [1][1][0] = *(dockpars_fgrids + offset_cube_110 + mul_tmp);\n"
"      			cube [0][0][1] = *(dockpars_fgrids + offset_cube_001 + mul_tmp);\n"
"      			cube [1][0][1] = *(dockpars_fgrids + offset_cube_101 + mul_tmp);\n"
"      			cube [0][1][1] = *(dockpars_fgrids + offset_cube_011 + mul_tmp);\n"
"      			cube [1][1][1] = *(dockpars_fgrids + offset_cube_111 + mul_tmp);\n"
"\n"
"			// Vector in x-direction\n"
"			x10 = cube [1][0][0] - cube [0][0][0]; // z = 0\n"
"			x52 = cube [1][1][0] - cube [0][1][0]; // z = 0\n"
"			x43 = cube [1][0][1] - cube [0][0][1]; // z = 1\n"
"			x76 = cube [1][1][1] - cube [0][1][1]; // z = 1\n"
"			vx_z0 = (1 - dy) * x10 + dy * x52;     // z = 0\n"
"			vx_z1 = (1 - dy) * x43 + dy * x76;     // z = 1\n"
"			gradient_inter_x[atom_id] += fabs(q) * ((1 - dz) * vx_z0 + dz * vx_z1);\n"
"\n"
"			// Vector in y-direction\n"
"			y20 = cube[0][1][0] - cube [0][0][0];	// z = 0\n"
"			y51 = cube[1][1][0] - cube [1][0][0];	// z = 0\n"
"			y63 = cube[0][1][1] - cube [0][0][1];	// z = 1\n"
"			y74 = cube[1][1][1] - cube [1][0][1];	// z = 1\n"
"			vy_z0 = (1 - dx) * y20 + dx * y51;	// z = 0\n"
"			vy_z1 = (1 - dx) * y63 + dx * y74;	// z = 1\n"
"			gradient_inter_y[atom_id] += fabs(q) *((1 - dz) * vy_z0 + dz * vy_z1);\n"
"\n"
"			// Vectors in z-direction\n"
"			z30 = cube [0][0][1] - cube [0][0][0];	// y = 0\n"
"			z41 = cube [1][0][1] - cube [1][0][0];	// y = 0\n"
"			z62 = cube [0][1][1] - cube [0][1][0];	// y = 1 \n"
"			z75 = cube [1][1][1] - cube [1][1][0];	// y = 1\n"
"			vz_y0 = (1 - dx) * z30 + dx * z41;	// y = 0\n"
"			vz_y1 = (1 - dx) * z62 + dx * z75;	// y = 1\n"
"			gradient_inter_z[atom_id] += fabs(q) *((1 - dy) * vz_y0 + dy * vz_y1);\n"
"\n"
"			//printf(\"%-15s %-3u %-10.8f %-10.8f %-10.8f %-10.8f %-10.8f %-10.8f\\n\", \"desol\", atom_id, vx_z0, vx_z1, vy_z0, vy_z1, vz_y0, vz_y1);\n"
"			// -------------------------------------------------------------------\n"
"		}\n"
"\n"
"	} // End atom_id for-loop (INTERMOLECULAR ENERGY)\n"
"\n"
"	// Inter- and intra-molecular energy calculation\n"
"	// are independent from each other, so NO barrier is needed here.\n"
"  	// As these two require different operations,\n"
"	// they can be executed only sequentially on the GPU.\n"
"\n"
"	// ================================================\n"
"	// CALCULATING INTRAMOLECULAR GRADIENTS\n"
"	// ================================================\n"
"	for (uint contributor_counter = get_local_id(0);\n"
"	          contributor_counter < dockpars_num_of_intraE_contributors;\n"
"	          contributor_counter+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		// Getting atom IDs\n"
"		uint atom1_id = intraE_contributors_const[3*contributor_counter];\n"
"		uint atom2_id = intraE_contributors_const[3*contributor_counter+1];\n"
"	\n"
"		/*\n"
"		printf (\"%-5u %-5u %-5u\\n\", contributor_counter, atom1_id, atom2_id);\n"
"		*/\n"
"		\n"
"		// Calculating vector components of vector going\n"
"		// from first atom's to second atom's coordinates\n"
"		float subx = calc_coords_x[atom1_id] - calc_coords_x[atom2_id];\n"
"		float suby = calc_coords_y[atom1_id] - calc_coords_y[atom2_id];\n"
"		float subz = calc_coords_z[atom1_id] - calc_coords_z[atom2_id];\n"
"\n"
"		// Calculating atomic distance\n"
"		float atomic_distance = native_sqrt(subx*subx + suby*suby + subz*subz)*dockpars_grid_spacing;\n"
"\n"
"		if (atomic_distance < 1.0f)\n"
"			atomic_distance = 1.0f;\n"
"\n"
"		// Calculating gradient contributions\n"
"		if ((atomic_distance < 8.0f) && (atomic_distance < 20.48f))\n"
"		{\n"
"			// Getting type IDs\n"
"			uint atom1_typeid = atom_types_const[atom1_id];\n"
"			uint atom2_typeid = atom_types_const[atom2_id];\n"
"			//printf (\"%-5u %-5u %-5u\\n\", contributor_counter, atom1_id, atom2_id);\n"
"\n"
"			// Calculating van der Waals / hydrogen bond term\n"
"			gradient_per_intracontributor[contributor_counter] += native_divide (-12*VWpars_AC_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],\n"
"									                     native_powr(atomic_distance, 13)\n"
"									       		    );\n"
"\n"
"			if (intraE_contributors_const[3*contributor_counter+2] == 1) {	//H-bond\n"
"				gradient_per_intracontributor[contributor_counter] += native_divide (10*VWpars_BD_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],\n"
"										                     native_powr(atomic_distance, 11)\n"
"												    );\n"
"			}\n"
"			else {	//van der Waals\n"
"				gradient_per_intracontributor[contributor_counter] += native_divide (6*VWpars_BD_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],\n"
"										                     native_powr(atomic_distance, 7)\n"
"										                    );\n"
"			}\n"
"\n"
"			// Calculating electrostatic term\n"
"			// http://www.wolframalpha.com/input/?i=1%2F(x*(A%2B(B%2F(1%2BK*exp(-h*B*x)))))\n"
"			float upper = DIEL_A*native_powr(native_exp(DIEL_B_TIMES_H*atomic_distance) + DIEL_K, 2) + (DIEL_B)*native_exp(DIEL_B_TIMES_H*atomic_distance)*(DIEL_B_TIMES_H_TIMES_K*atomic_distance + native_exp(DIEL_B_TIMES_H*atomic_distance) + DIEL_K);\n"
"		\n"
"			float lower = native_powr(atomic_distance, 2) * native_powr(DIEL_A * (native_exp(DIEL_B_TIMES_H*atomic_distance) + DIEL_K) + DIEL_B * native_exp(DIEL_B_TIMES_H*atomic_distance), 2);\n"
"\n"
"        		gradient_per_intracontributor[contributor_counter] +=  -dockpars_coeff_elec * atom_charges_const[atom1_id] * atom_charges_const[atom2_id] * native_divide (upper, lower);\n"
"\n"
"			// Calculating desolvation term\n"
"			gradient_per_intracontributor[contributor_counter] += (\n"
"									       (dspars_S_const[atom1_typeid] + dockpars_qasp*fabs(atom_charges_const[atom1_id])) * dspars_V_const[atom2_typeid] +\n"
"							                       (dspars_S_const[atom2_typeid] + dockpars_qasp*fabs(atom_charges_const[atom2_id])) * dspars_V_const[atom1_typeid]\n"
"				        				      ) *\n"
"					                       			dockpars_coeff_desolv * -0.07716049382716049 * atomic_distance * native_exp(-0.038580246913580245*native_powr(atomic_distance, 2));\n"
"\n"
"		}\n"
"\n"
"	} // End contributor_counter for-loop (INTRAMOLECULAR ENERGY)\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// Accumulating gradients from \"gradient_per_intracontributor\" for each each\n"
"	if (get_local_id(0) == 0) {\n"
"		for (uint contributor_counter = 0;\n"
"			  contributor_counter < dockpars_num_of_intraE_contributors;\n"
"			  contributor_counter ++) {\n"
"\n"
"			// Getting atom IDs\n"
"			uint atom1_id = intraE_contributors_const[3*contributor_counter];\n"
"			uint atom2_id = intraE_contributors_const[3*contributor_counter+1];\n"
"\n"
"			// Calculating xyz distances in Angstroms of vector\n"
"			// that goes from \"atom1_id\"-to-\"atom2_id\"\n"
"			float subx = (calc_coords_x[atom2_id] - calc_coords_x[atom1_id]);\n"
"			float suby = (calc_coords_y[atom2_id] - calc_coords_y[atom1_id]);\n"
"			float subz = (calc_coords_z[atom2_id] - calc_coords_z[atom1_id]);\n"
"			float dist = native_sqrt(subx*subx + suby*suby + subz*subz);\n"
"\n"
"			float subx_div_dist = native_divide(subx, dist);\n"
"			float suby_div_dist = native_divide(suby, dist);\n"
"			float subz_div_dist = native_divide(subz, dist);\n"
"\n"
"			// Calculating gradients in xyz components.\n"
"			// Gradients for both atoms in a single contributor pair\n"
"			// have the same magnitude, but opposite directions\n"
"			gradient_intra_x[atom1_id] -= gradient_per_intracontributor[contributor_counter] * subx_div_dist;\n"
"			gradient_intra_y[atom1_id] -= gradient_per_intracontributor[contributor_counter] * suby_div_dist;\n"
"			gradient_intra_z[atom1_id] -= gradient_per_intracontributor[contributor_counter] * subz_div_dist;\n"
"\n"
"			gradient_intra_x[atom2_id] += gradient_per_intracontributor[contributor_counter] * subx_div_dist;\n"
"			gradient_intra_y[atom2_id] += gradient_per_intracontributor[contributor_counter] * suby_div_dist;\n"
"			gradient_intra_z[atom2_id] += gradient_per_intracontributor[contributor_counter] * subz_div_dist;\n"
"\n"
"			//printf(\"%-20s %-10u %-5u %-5u %-10.8f\\n\", \"grad_intracontrib\", contributor_counter, atom1_id, atom2_id, gradient_per_intracontributor[contributor_counter]);\n"
"		}\n"
"	}\n"
"	\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// Accumulating inter- and intramolecular gradients\n"
"	for (uint atom_cnt = get_local_id(0);\n"
"		  atom_cnt < dockpars_num_of_atoms;\n"
"		  atom_cnt+= NUM_OF_THREADS_PER_BLOCK) {\n"
"\n"
"		// Grid gradients were calculated in the grid space,\n"
"		// so they have to be put back in Angstrom.\n"
"\n"
"		// Intramolecular gradients were already in Angstrom,\n"
"		// so no scaling for them is required.\n"
"		gradient_inter_x[atom_cnt] = native_divide(gradient_inter_x[atom_cnt], dockpars_grid_spacing);\n"
"		gradient_inter_y[atom_cnt] = native_divide(gradient_inter_y[atom_cnt], dockpars_grid_spacing);\n"
"		gradient_inter_z[atom_cnt] = native_divide(gradient_inter_z[atom_cnt], dockpars_grid_spacing);\n"
"\n"
"		gradient_x[atom_cnt] = gradient_inter_x[atom_cnt] + gradient_intra_x[atom_cnt];\n"
"		gradient_y[atom_cnt] = gradient_inter_y[atom_cnt] + gradient_intra_y[atom_cnt];\n"
"		gradient_z[atom_cnt] = gradient_inter_z[atom_cnt] + gradient_intra_z[atom_cnt];\n"
"	\n"
"		//printf(\"%-15s %-5u %-10.8f %-10.8f %-10.8f\\n\", \"grad_grid\", atom_cnt, gradient_inter_x[atom_cnt], gradient_inter_y[atom_cnt], gradient_inter_z[atom_cnt]);\n"
"\n"
"		//printf(\"%-15s %-5u %-10.8f %-10.8f %-10.8f\\n\", \"grad_intra\", atom_cnt, gradient_intra_x[atom_cnt], gradient_intra_y[atom_cnt], gradient_intra_z[atom_cnt]);\n"
"\n"
"		//printf(\"%-15s %-5u %-10.8f %-10.8f %-10.8f\\n\", \"calc_coords\", atom_cnt, calc_coords_x[atom_cnt], calc_coords_y[atom_cnt], calc_coords_z[atom_cnt]);\n"
"\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// ------------------------------------------\n"
"	// Obtaining translation-related gradients\n"
"	// ------------------------------------------\n"
"	if (get_local_id(0) == 0) {\n"
"		for (uint lig_atom_id = 0;\n"
"			  lig_atom_id<dockpars_num_of_atoms;\n"
"			  lig_atom_id++) {\n"
"			gradient_genotype[0] += gradient_x[lig_atom_id]; // gradient for gene 0: gene x\n"
"			gradient_genotype[1] += gradient_y[lig_atom_id]; // gradient for gene 1: gene y\n"
"			gradient_genotype[2] += gradient_z[lig_atom_id]; // gradient for gene 2: gene z\n"
"		}\n"
"\n"
"		// Scaling gradient for translational genes as \n"
"		// their corresponding gradients were calculated in the space \n"
"		// where these genes are in Angstrom,\n"
"		// but OCLaDock translational genes are within in grids\n"
"		gradient_genotype[0] *= dockpars_grid_spacing;\n"
"		gradient_genotype[1] *= dockpars_grid_spacing;\n"
"		gradient_genotype[2] *= dockpars_grid_spacing;\n"
"\n"
"		#if defined (DEBUG_GRAD_TRANSLATION_GENES)\n"
"		printf(\"gradient_x:%f\\n\", gradient_genotype [0]);\n"
"		printf(\"gradient_y:%f\\n\", gradient_genotype [1]);\n"
"		printf(\"gradient_z:%f\\n\", gradient_genotype [2]);\n"
"		#endif\n"
"	}\n"
"\n"
"	// ------------------------------------------\n"
"	// Obtaining rotation-related gradients\n"
"	// ------------------------------------------ \n"
"				\n"
"	// Transform gradients_inter_{x|y|z} \n"
"	// into local_gradients[i] (with four quaternion genes)\n"
"	// Derived from autodockdev/motions.py/forces_to_delta_genes()\n"
"\n"
"	// Transform local_gradients[i] (with four quaternion genes)\n"
"	// into local_gradients[i] (with three Shoemake genes)\n"
"	// Derived from autodockdev/motions.py/_get_cube3_gradient()\n"
"	// ------------------------------------------\n"
"	if (get_local_id(0) == 1) {\n"
"\n"
"		float3 torque_rot;\n"
"		torque_rot.x = 0.0f;\n"
"		torque_rot.y = 0.0f;\n"
"		torque_rot.z = 0.0f;\n"
"\n"
"		#if defined (DEBUG_GRAD_ROTATION_GENES)\n"
"		printf(\"%-20s %-10.5f %-10.5f %-10.5f\\n\", \"initial torque: \", torque_rot.x, torque_rot.y, torque_rot.z);\n"
"		#endif\n"
"\n"
"		// Declaring a variable to hold the center of rotation \n"
"		// In getparameters.cpp, it indicates \n"
"		// translation genes are in grid spacing (instead of Angstroms)\n"
"		float3 about;\n"
"		about.x = genotype[0];\n"
"		about.y = genotype[1];\n"
"		about.z = genotype[2];\n"
"	\n"
"		// Temporal variable to calculate translation differences.\n"
"		// They are converted back to Angstroms here\n"
"		float3 r;\n"
"			\n"
"		for (uint lig_atom_id = 0;\n"
"			  lig_atom_id<dockpars_num_of_atoms;\n"
"			  lig_atom_id++) {\n"
"			r.x = (calc_coords_x[lig_atom_id] - about.x) * dockpars_grid_spacing; \n"
"			r.y = (calc_coords_y[lig_atom_id] - about.y) * dockpars_grid_spacing;  \n"
"			r.z = (calc_coords_z[lig_atom_id] - about.z) * dockpars_grid_spacing; \n"
"\n"
"			float3 force;\n"
"			force.x	= gradient_x[lig_atom_id];\n"
"			force.y	= gradient_y[lig_atom_id]; \n"
"			force.z	= gradient_z[lig_atom_id];\n"
"\n"
"			torque_rot += cross(r, force);\n"
"\n"
"			#if defined (DEBUG_GRAD_ROTATION_GENES)\n"
"			printf(\"%-20s %-10u\\n\", \"contrib. of atom-id: \", lig_atom_id);\n"
"			printf(\"%-20s %-10.5f %-10.5f %-10.5f\\n\", \"r             : \", r.x, r.y, r.z);\n"
"			printf(\"%-20s %-10.5f %-10.5f %-10.5f\\n\", \"force         : \", force.x, force.y, force.z);\n"
"			printf(\"%-20s %-10.5f %-10.5f %-10.5f\\n\", \"partial torque: \", torque_rot.x, torque_rot.y, torque_rot.z);\n"
"			printf(\"\\n\");\n"
"			#endif\n"
"		}\n"
"\n"
"		#if defined (DEBUG_GRAD_ROTATION_GENES)\n"
"		printf(\"%-20s %-10.5f %-10.5f %-10.5f\\n\", \"final torque: \", torque_rot.x, torque_rot.y, torque_rot.z);\n"
"		#endif\n"
"\n"
"		// Derived from rotation.py/axisangle_to_q()\n"
"		// genes[3:7] = rotation.axisangle_to_q(torque, rad)\n"
"		float torque_length = fast_length(torque_rot);\n"
"		\n"
"		#if defined (DEBUG_GRAD_ROTATION_GENES)\n"
"		printf(\"%-20s %-10.5f\\n\", \"torque length: \", torque_length);\n"
"		#endif\n"
"\n"
"		// Infinitesimal rotation in radians\n"
"		const float infinitesimal_radian = 1E-5;\n"
"\n"
"		// Finding the quaternion that performs\n"
"		// the infinitesimal rotation around torque axis\n"
"		float4 quat_torque;\n"
"		quat_torque.w = native_cos(infinitesimal_radian*0.5f);\n"
"		quat_torque.x = fast_normalize(torque_rot).x * native_sin(infinitesimal_radian*0.5f);\n"
"		quat_torque.y = fast_normalize(torque_rot).y * native_sin(infinitesimal_radian*0.5f);\n"
"		quat_torque.z = fast_normalize(torque_rot).z * native_sin(infinitesimal_radian*0.5f);\n"
"\n"
"		#if defined (DEBUG_GRAD_ROTATION_GENES)\n"
"		printf(\"%-20s %-10.5f %-10.5f %-10.5f %-10.5f\\n\", \"quat_torque (w,x,y,z): \", quat_torque.w, quat_torque.x, quat_torque.y, quat_torque.z);\n"
"		#endif\n"
"\n"
"		// Converting quaternion gradients into Shoemake gradients \n"
"		// Derived from autodockdev/motion.py/_get_cube3_gradient\n"
"\n"
"		// This is where we are in Shoemake space\n"
"		float current_u1, current_u2, current_u3;\n"
"		current_u1 = genotype[3]; // check very initial input Shoemake genes\n"
"		current_u2 = genotype[4];\n"
"		current_u3 = genotype[5];\n"
"		\n"
"		#if defined (DEBUG_GRAD_ROTATION_GENES)\n"
"		printf(\"%-30s %-10.5f %-10.5f %-10.5f\\n\", \"current_u (1,2,3): \", genotype[3], genotype[4], genotype[5]);\n"
"		#endif		\n"
"\n"
"		// This is where we are in quaternion space\n"
"		// current_q = cube3_to_quaternion(current_u)\n"
"		float4 current_q;\n"
"		current_q.w = native_sqrt(1-current_u1) * native_sin(PI_TIMES_2*current_u2);\n"
"		current_q.x = native_sqrt(1-current_u1) * native_cos(PI_TIMES_2*current_u2);\n"
"		current_q.y = native_sqrt(current_u1)   * native_sin(PI_TIMES_2*current_u3);\n"
"		current_q.z = native_sqrt(current_u1)   * native_cos(PI_TIMES_2*current_u3);\n"
"\n"
"		#if defined (DEBUG_GRAD_ROTATION_GENES)\n"
"		printf(\"%-30s %-10.8f %-10.8f %-10.8f %-10.8f\\n\", \"current_q (w,x,y,z): \", current_q.w, current_q.x, current_q.y, current_q.z);\n"
"		#endif\n"
"\n"
"		// This is where we want to be in quaternion space\n"
"		float4 target_q;\n"
"\n"
"		// target_q = rotation.q_mult(q, current_q)\n"
"		// Derived from autodockdev/rotation.py/q_mult()\n"
"		// In our terms means q_mult(quat_{w|x|y|z}, current_q{w|x|y|z})\n"
"		target_q.w = quat_torque.w*current_q.w - quat_torque.x*current_q.x - quat_torque.y*current_q.y - quat_torque.z*current_q.z;// w\n"
"		target_q.x = quat_torque.w*current_q.x + quat_torque.x*current_q.w + quat_torque.y*current_q.z - quat_torque.z*current_q.y;// x\n"
"		target_q.y = quat_torque.w*current_q.y + quat_torque.y*current_q.w + quat_torque.z*current_q.x - quat_torque.x*current_q.z;// y\n"
"		target_q.z = quat_torque.w*current_q.z + quat_torque.z*current_q.w + quat_torque.x*current_q.y - quat_torque.y*current_q.x;// z\n"
"		#if defined (DEBUG_GRAD_ROTATION_GENES)\n"
"		printf(\"%-30s %-10.8f %-10.8f %-10.8f %-10.8f\\n\", \"target_q (w,x,y,z): \", target_q.w, target_q.x, target_q.y, target_q.z);\n"
"		#endif\n"
"\n"
"		// This is where we want to be in Shoemake space\n"
"		float target_u1, target_u2, target_u3;\n"
"\n"
"		// target_u = quaternion_to_cube3(target_q)\n"
"		// Derived from autodockdev/motions.py/quaternion_to_cube3()\n"
"		// In our terms means quaternion_to_cube3(target_q{w|x|y|z})\n"
"		target_u1 = target_q.y*target_q.y + target_q.z*target_q.z;\n"
"		target_u2 = atan2(target_q.w, target_q.x);\n"
"		target_u3 = atan2(target_q.y, target_q.z);\n"
"		\n"
"		if (target_u2 < 0.0f)       { target_u2 += PI_TIMES_2; }\n"
"		if (target_u2 > PI_TIMES_2) { target_u2 -= PI_TIMES_2; }\n"
"		if (target_u3 < 0.0f) 	    { target_u3 += PI_TIMES_2; }\n"
"		if (target_u3 > PI_TIMES_2) { target_u3 -= PI_TIMES_2; }\n"
"\n"
"		#if defined (DEBUG_GRAD_ROTATION_GENES)\n"
"		printf(\"%-30s %-10.8f %-10.8f %-10.8f\\n\", \"target_u (1,2,3) - after mapping: \", target_u1, target_u2, target_u3);\n"
"		#endif\n"
"		\n"
"   		// The infinitesimal rotation will produce an infinitesimal displacement\n"
"    		// in shoemake space. This is to guarantee that the direction of\n"
"    		// the displacement in shoemake space is not distorted.\n"
"    		// The correct amount of displacement in shoemake space is obtained\n"
"		// by multiplying the infinitesimal displacement by shoemake_scaling:\n"
"		float shoemake_scaling = torque_length / infinitesimal_radian;\n"
"\n"
"		// Derivates in cube3\n"
"		// \"current_u2\" and \"current_u3\" are mapped into \n"
"		// the same range [0, 2PI] of \"target_u2\" and \"target_u3\"\n"
"		float grad_u1, grad_u2, grad_u3;\n"
"		grad_u1 = shoemake_scaling * (target_u1 - current_u1);\n"
"		grad_u2 = shoemake_scaling * (target_u2 - current_u2 * PI_TIMES_2);\n"
"		grad_u3 = shoemake_scaling * (target_u3 - current_u3 * PI_TIMES_2);\n"
"\n"
"		#if defined (DEBUG_GRAD_ROTATION_GENES)\n"
"		printf(\"%-30s %-10.8f %-10.8f %-10.8f\\n\", \"grad_u (1,2,3) - before emp. scaling: \", grad_u1, grad_u2, grad_u3);\n"
"		#endif\n"
"			\n"
"		// Empirical scaling\n"
"		float temp_u1 = genotype[3];\n"
"			\n"
"		if ((0.0f < temp_u1) && (temp_u1 < 1.0f)){\n"
"			grad_u1 *= ((1.0f/temp_u1) + (1.0f/(1.0f-temp_u1)));\n"
"		}\n"
"		grad_u2 *= 4.0f * (1.0f-temp_u1);\n"
"		grad_u3 *= 4.0f * temp_u1;\n"
"\n"
"		#if defined (DEBUG_GRAD_ROTATION_GENES)\n"
"		printf(\"%-30s %-10.8f %-10.8f %-10.8f\\n\", \"grad_u (1,2,3) - after emp. scaling: \", grad_u1, grad_u2, grad_u3);\n"
"		#endif\n"
"		\n"
"		// Setting gradient rotation-related genotypes in cube3.\n"
"		// Scaling gradient for u2 and u3 genes as \n"
"		// their corresponding gradients were calculated in the space where u2/3 are within [0, 2PI]\n"
"		// but OCLaDock u2/3 genes are within [0, 1]\n"
"		gradient_genotype[3] = grad_u1;\n"
"		gradient_genotype[4] = grad_u2 * PI_TIMES_2; \n"
"		gradient_genotype[5] = grad_u3 * PI_TIMES_2;\n"
"	}\n"
"\n"
"	// ------------------------------------------\n"
"	// Obtaining torsion-related gradients\n"
"	// ------------------------------------------\n"
"	if (get_local_id(0) == 2) {\n"
"\n"
"		for (uint rotbond_id = 0;\n"
"			  rotbond_id < dockpars_num_of_genes-6;\n"
"			  rotbond_id ++) {\n"
"\n"
"			// Querying ids of atoms belonging to the rotatable bond in question\n"
"			int atom1_id = rotbonds_const[2*rotbond_id];\n"
"			int atom2_id = rotbonds_const[2*rotbond_id+1];\n"
"\n"
"			float3 atomRef_coords;\n"
"			atomRef_coords.x = calc_coords_x[atom1_id];\n"
"			atomRef_coords.y = calc_coords_y[atom1_id];\n"
"			atomRef_coords.z = calc_coords_z[atom1_id];\n"
"\n"
"			#if defined (DEBUG_GRAD_TORSION_GENES)\n"
"			printf(\"%-15s %-10u\\n\", \"rotbond_id: \", rotbond_id);\n"
"			printf(\"%-15s %-10i\\n\", \"atom1_id: \", atom1_id);\n"
"			printf(\"%-15s %-10.8f %-10.8f %-10.8f\\n\", \"atom1_coords: \", calc_coords_x[atom1_id], calc_coords_y[atom1_id], calc_coords_z[atom1_id]);\n"
"			printf(\"%-15s %-10i\\n\", \"atom2_id: \", atom2_id);\n"
"			printf(\"%-15s %-10.8f %-10.8f %-10.8f\\n\", \"atom2_coords: \", calc_coords_x[atom2_id], calc_coords_y[atom2_id], calc_coords_z[atom2_id]);\n"
"			printf(\"\\n\");\n"
"			#endif		\n"
"\n"
"			float3 rotation_unitvec;\n"
"			/*\n"
"			rotation_unitvec.x = rotbonds_unit_vectors_const[3*rotbond_id];\n"
"			rotation_unitvec.y = rotbonds_unit_vectors_const[3*rotbond_id+1];\n"
"			rotation_unitvec.z = rotbonds_unit_vectors_const[3*rotbond_id+2];\n"
"			*/\n"
"			rotation_unitvec.x = calc_coords_x[atom2_id] - calc_coords_x[atom1_id];\n"
"			rotation_unitvec.y = calc_coords_y[atom2_id] - calc_coords_y[atom1_id];\n"
"			rotation_unitvec.z = calc_coords_z[atom2_id] - calc_coords_z[atom1_id];\n"
"			rotation_unitvec = fast_normalize(rotation_unitvec);\n"
"\n"
"			// Torque of torsions\n"
"			float3 torque_tor;\n"
"			torque_tor.x = 0.0f;\n"
"			torque_tor.y = 0.0f;\n"
"			torque_tor.z = 0.0f;\n"
"\n"
"			// Iterating over each ligand atom that rotates \n"
"			// if the bond in question rotates\n"
"			for (uint rotable_atom_cnt = 0;\n"
"				  rotable_atom_cnt<num_rotating_atoms_per_rotbond_const[rotbond_id];\n"
"				  rotable_atom_cnt++) {\n"
"\n"
"				uint lig_atom_id = rotbonds_atoms_const[MAX_NUM_OF_ATOMS*rotbond_id + rotable_atom_cnt];\n"
"\n"
"				// Calculating torque on point \"A\" \n"
"				// (could be any other point \"B\" along the rotation axis)\n"
"				float3 atom_coords;\n"
"				atom_coords.x = calc_coords_x[lig_atom_id];\n"
"				atom_coords.y = calc_coords_y[lig_atom_id];\n"
"				atom_coords.z = calc_coords_z[lig_atom_id];\n"
"\n"
"				// Temporal variable to calculate translation differences.\n"
"				// They are converted back to Angstroms here\n"
"				float3 r;\n"
"				r.x = (atom_coords.x - atomRef_coords.x) * dockpars_grid_spacing;\n"
"				r.y = (atom_coords.y - atomRef_coords.y) * dockpars_grid_spacing;\n"
"				r.z = (atom_coords.z - atomRef_coords.z) * dockpars_grid_spacing;\n"
"\n"
"				float3 atom_force;\n"
"				atom_force.x = gradient_x[lig_atom_id]; \n"
"				atom_force.y = gradient_y[lig_atom_id];\n"
"				atom_force.z = gradient_z[lig_atom_id];\n"
"\n"
"				torque_tor += cross(r, atom_force);\n"
"\n"
"				#if defined (DEBUG_GRAD_TORSION_GENES)\n"
"				printf(\"\\n\");\n"
"				printf(\"%-15s %-10u\\n\", \"rotable_atom_cnt: \", rotable_atom_cnt);\n"
"				printf(\"%-15s %-10u\\n\", \"atom_id: \", lig_atom_id);\n"
"				printf(\"%-15s %-10.8f %-10.8f %-10.8f\\n\", \"atom_coords: \", atom_coords.x, atom_coords.y, atom_coords.z);\n"
"				printf(\"%-15s %-10.8f %-10.8f %-10.8f\\n\", \"r: \", r.x, r.y, r.z);\n"
"				printf(\"%-15s %-10.8f %-10.8f %-10.8f\\n\", \"unitvec: \", rotation_unitvec.x, rotation_unitvec.y, rotation_unitvec.z);\n"
"				printf(\"%-15s %-10.8f %-10.8f %-10.8f\\n\", \"atom_force: \", atom_force.x, atom_force.y, atom_force.z);\n"
"				printf(\"%-15s %-10.8f %-10.8f %-10.8f\\n\", \"torque_tor: \", torque_tor.x, torque_tor.y, torque_tor.z);\n"
"				#endif\n"
"\n"
"			}\n"
"			#if defined (DEBUG_GRAD_TORSION_GENES)\n"
"			printf(\"\\n\");\n"
"			#endif\n"
"\n"
"			// Projecting torque on rotation axis\n"
"			float torque_on_axis = dot(rotation_unitvec, torque_tor);\n"
"\n"
"			// Assignment of gene-based gradient\n"
"			gradient_genotype[rotbond_id+6] = torque_on_axis * (M_PI / 180.0f);\n"
"\n"
"			#if defined (DEBUG_GRAD_TORSION_GENES)\n"
"			printf(\"gradient_torsion [%u] :%f\\n\", rotbond_id+6, gradient_genotype [rotbond_id+6]);\n"
"			#endif\n"
"			\n"
"		} // End of iterations over rotatable bonds\n"
"	}\n"
"\n"
"}\n"
"//#define DEBUG_GRADDESC_ENABLED\n"
"\n"
"\n"
"// Implementation of auxiliary functions \n"
"// for the gradient-based minimizer\n"
"void is_gradDescent_enabled(\n"
"			    __local    bool* 	is_genotype_valid,\n"
"                            __local    uint*    local_nIter,\n"
"                                       uint     gradMin_maxiter,\n"
"			    __local    float*   local_candidate_genotype,\n"
"				       uint     gradMin_numElements,\n"
"                            __local    bool*    is_gradDescentEn\n"
")\n"
"{\n"
"	bool is_gNorm_gt_gMin;\n"
"	bool is_nIter_lt_maxIter;\n"
"	bool is_valid;\n"
"	\n"
"	if (get_local_id(0) == 0) {\n"
"		is_nIter_lt_maxIter = (local_nIter[0] < gradMin_maxiter);\n"
"		is_valid = true;\n"
"	}	\n"
"\n"
"/*\n"
"	// Verifying that Shoemake genes do not get out of valid range.\n"
"	// If they do so, then set them to 0.0f\n"
"	if (get_local_id(0) < 3){\n"
"		if ((local_candidate_genotype[get_local_id(0)] < 0.0f) && (local_candidate_genotype[get_local_id(0)] > 1.0f)) {\n"
"			local_candidate_genotype[get_local_id(0)] = 0.0f;\n"
"		}\n"
"	}\n"
"*/	\n"
"\n"
"	// Using every of its genes, let's determine \n"
"	// if candidate genotype is valid \n"
"  	for(uint i = get_local_id(0); \n"
"		 i < gradMin_numElements; \n"
"		 i+= NUM_OF_THREADS_PER_BLOCK) {\n"
"   		is_genotype_valid[i] = !isnan(local_candidate_genotype[i]) && !isinf(local_candidate_genotype[i]);\n"
"  	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	if (get_local_id(0) == 0) {\n"
"		\n"
"		// Reduce all \"valid\" values of genes\n"
"		// into their corresponding genotype\n"
"	  	for(uint i = 0; \n"
"			 i < gradMin_numElements;\n"
"			 i++) {\n"
"	    		is_valid = is_valid && is_genotype_valid[i];\n"
"			\n"
"			#if defined (DEBUG_GRADDESC_ENABLED)\n"
"			//printf(\"is_genotype_valid[%u]?: %s\\n\", i, (is_genotype_valid[i] == true)?\"yes\":\"no\");\n"
"			#endif\n"
"\n"
"	  	}\n"
"	\n"
"		// Reduce all previous partial evaluations (nIter, valid) into a final one\n"
"		*is_gradDescentEn = is_nIter_lt_maxIter && is_valid;\n"
"\n"
"		#if defined (DEBUG_GRADDESC_ENABLED)\n"
"		//printf(\"is_gNorm_gt_gMin?: %s\\n\", (is_gNorm_gt_gMin == true)?\"yes\":\"no\");\n"
"		//printf(\"is_nIter_lt_maxIter?: %s\\n\", (is_nIter_lt_maxIter == true)?\"yes\":\"no\");\n"
"		//printf(\"is_valid?: %s\\n\", (is_valid == true)?\"yes\":\"no\");\n"
"		printf(\"Continue grad-mini?: %s\\n\", (*is_gradDescentEn == true)?\"yes\":\"no\");\n"
"		#endif\n"
"	}\n"
"}\n"
"// Gradient-based steepest descent minimizer\n"
"// Alternative to Solis-Wetts\n"
"\n"
"//#define DEBUG_MINIMIZER\n"
"\n"
"#define TRANGENE_ALPHA 1E-3//1E-8\n"
"#define ROTAGENE_ALPHA 1E-8//1E-15\n"
"#define TORSGENE_ALPHA 1E-13//1E-4\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gradient_minimizer(	\n"
"			char   dockpars_num_of_atoms,\n"
"			char   dockpars_num_of_atypes,\n"
"			int    dockpars_num_of_intraE_contributors,\n"
"			char   dockpars_gridsize_x,\n"
"			char   dockpars_gridsize_y,\n"
"			char   dockpars_gridsize_z,\n"
"			float  dockpars_grid_spacing,\n"
"	 __global const float* restrict dockpars_fgrids, // This is too large to be allocated in __constant \n"
"			int    dockpars_rotbondlist_length,\n"
"			float  dockpars_coeff_elec,\n"
"			float  dockpars_coeff_desolv,\n"
"	  __global      float* restrict dockpars_conformations_next,\n"
"	  __global      float* restrict dockpars_energies_next,\n"
"  	  __global 	int*   restrict dockpars_evals_of_new_entities,\n"
"	  __global      uint*  restrict dockpars_prng_states,\n"
"			int    dockpars_pop_size,\n"
"			int    dockpars_num_of_genes,\n"
"			float  dockpars_lsearch_rate,\n"
"			uint   dockpars_num_of_lsentities,\n"
"			float  dockpars_qasp,\n"
"	     __constant float* atom_charges_const,\n"
"    	     __constant char*  atom_types_const,\n"
"	     __constant char*  intraE_contributors_const,\n"
"    	     __constant float* VWpars_AC_const,\n"
"    	     __constant float* VWpars_BD_const,\n"
"             __constant float* dspars_S_const,\n"
"             __constant float* dspars_V_const,\n"
"             __constant int*   rotlist_const,\n"
"    	     __constant float* ref_coords_x_const,\n"
"    	     __constant float* ref_coords_y_const,\n"
"             __constant float* ref_coords_z_const,\n"
"    	     __constant float* rotbonds_moving_vectors_const,\n"
"             __constant float* rotbonds_unit_vectors_const,\n"
"             __constant float* ref_orientation_quats_const,\n"
"	     __constant int*   rotbonds_const,\n"
"	     __constant int*   rotbonds_atoms_const,\n"
"	     __constant int*   num_rotating_atoms_per_rotbond_const,\n"
"    			// Specific gradient-minimizer args\n"
"		    	uint      	  gradMin_maxiters,\n"
"			uint      	  gradMin_maxfails,\n"
"	    		float             gradMin_alpha,\n"
"    	     __constant float* gradMin_conformation_min_perturbation     // minimal values for gene perturbation, originally as the scalar \"dxmin\"\n"
")\n"
"//The GPU global function performs gradient-based minimization on (some) entities of conformations_next.\n"
"//The number of OpenCL compute units (CU) which should be started equals to num_of_minEntities*num_of_runs.\n"
"//This way the first num_of_lsentities entity of each population will be subjected to local search\n"
"//(and each CU carries out the algorithm for one entity).\n"
"//Since the first entity is always the best one in the current population,\n"
"//it is always tested according to the ls probability, and if it not to be\n"
"//subjected to local search, the entity with ID num_of_lsentities is selected instead of the first one (with ID 0).\n"
"{\n"
"	// -----------------------------------------------------------------------------\n"
"	// Determining entity, and its run, energy, and genotype\n"
"	__local int   entity_id;\n"
"	__local int   run_id;\n"
"  	__local float energy;\n"
"	__local float genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"\n"
"	// Variables for gradient minimizer\n"
"  	__local uint iteration_cnt;  	// minimizer iteration counter\n"
"	__local uint failure_cnt;  	// minimizer failure counter\n"
"	__local bool exit;		\n"
"\n"
"	// Number of energy-evaluations counter\n"
"	__local int  evaluation_cnt;\n"
"\n"
"	if (get_local_id(0) == 0)\n"
"	{\n"
"		// Choosing a random entity out of the entire population\n"
"///*\n"
"		run_id = get_group_id(0);\n"
"		entity_id = (uint)(dockpars_pop_size * gpu_randf(dockpars_prng_states));\n"
"		//entity_id = 0;\n"
"//*/\n"
"\n"
"/*\n"
"		run_id = get_group_id(0) / dockpars_num_of_lsentities;\n"
"		entity_id = get_group_id(0) % dockpars_num_of_lsentities;\n"
"*/\n"
"		\n"
"		energy = dockpars_energies_next[run_id*dockpars_pop_size+entity_id];\n"
"\n"
"		#if defined (DEBUG_MINIMIZER)\n"
"		printf(\"\\nrun_id:  %5u entity_id: %5u  initial_energy: %.5f\\n\", run_id, entity_id, energy);\n"
"		#endif\n"
"\n"
"		// Initializing gradient-minimizer counters and flags\n"
"    		iteration_cnt  = 0;\n"
"		failure_cnt    = 0;\n"
"		/*exit           = false;*/\n"
"		evaluation_cnt = 0;\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"  	async_work_group_copy(genotype,\n"
"  			      dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"                              dockpars_num_of_genes, 0);\n"
"\n"
"  	// -----------------------------------------------------------------------------\n"
"  	// Some OpenCL compilers don't allow declaring \n"
"	// local variables within non-kernel functions.\n"
"	// These local variables must be declared in a kernel, \n"
"	// and then passed to non-kernel functions.\n"
"	\n"
"	// Partial results for checking validity of genotype\n"
"	__local bool is_candidate_genotype_valid [ACTUAL_GENOTYPE_LENGTH];\n"
"           \n"
"	// Partial results of the gradient step\n"
"	__local float gradient          [ACTUAL_GENOTYPE_LENGTH];\n"
"	__local float candidate_energy;\n"
"	__local float candidate_genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"\n"
"	// -------------------------------------------------------------------\n"
"	// Calculate gradients (forces) for intermolecular energy\n"
"	// Derived from autodockdev/maps.py\n"
"	// -------------------------------------------------------------------\n"
"	// Gradient of the intermolecular energy per each ligand atom\n"
"	__local float gradient_inter_x[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_inter_y[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_inter_z[MAX_NUM_OF_ATOMS];\n"
"\n"
"	// Gradient of the intramolecular energy per each ligand atom\n"
"	__local float gradient_intra_x[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_intra_y[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_intra_z[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_per_intracontributor[MAX_INTRAE_CONTRIBUTORS];\n"
"\n"
"	// Accummulated gradient per each ligand atom\n"
"	__local float gradient_x[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_y[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_z[MAX_NUM_OF_ATOMS];	\n"
"	// -------------------------------------------------------------------\n"
"\n"
"	// Ligand-atom position and partial energies\n"
"	__local float calc_coords_x[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_y[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_z[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	#if defined (DEBUG_ENERGY_KERNEL5)\n"
"	__local float partial_interE[NUM_OF_THREADS_PER_BLOCK];\n"
"	__local float partial_intraE[NUM_OF_THREADS_PER_BLOCK];\n"
"	#endif\n"
"	// -----------------------------------------------------------------------------\n"
"\n"
"	// Step size of the steepest descent\n"
"	float alpha;\n"
"\n"
"	// Initilizing each (work-item)-specific alpha\n"
"	for(uint i = get_local_id(0); \n"
"		 i < dockpars_num_of_genes; \n"
"		 i+= NUM_OF_THREADS_PER_BLOCK) {\n"
"			if (i<3)      { alpha = TRANGENE_ALPHA;	}\n"
"			else if (i<6) { alpha = ROTAGENE_ALPHA; } \n"
"			else 	      { alpha = TORSGENE_ALPHA;	}\n"
"\n"
"			#if defined (DEBUG_MINIMIZER)\n"
"			//printf(\"(%-3u) %-15.15f\\n\", i, alpha);\n"
"			#endif\n"
"	}\n"
"\n"
"	// Perform gradient-descent iterations\n"
"\n"
"	#if 0\n"
"	// 7cpa\n"
"	float grid_center_x = 49.836;\n"
"	float grid_center_y = 17.609;\n"
"	float grid_center_z = 36.272;\n"
"	float ligand_center_x = 49.2216976744186;\n"
"	float ligand_center_y = 17.793953488372097;\n"
"	float ligand_center_z = 36.503837209302326;\n"
"	float shoemake_gene_u1 = 0.02;\n"
"	float shoemake_gene_u2 = 0.23;\n"
"	float shoemake_gene_u3 = 0.95;\n"
"	#endif\n"
"\n"
"	#if 0\n"
"	// 3tmn\n"
"	float grid_center_x = 52.340;\n"
"	float grid_center_y = 15.029;\n"
"	float grid_center_z = -2.932;\n"
"	float ligand_center_x = 52.22740741;\n"
"	float ligand_center_y = 15.51751852;\n"
"	float ligand_center_z = -2.40896296;\n"
"	#endif\n"
"\n"
"	do {\n"
"		#if 0\n"
"		// Specific input genotypes for a ligand with no rotatable bonds (1ac8).\n"
"		// Translation genes must be expressed in grids in OCLADock (genotype [0|1|2]).\n"
"		// However, for testing purposes, \n"
"		// we start using translation values in real space (Angstrom): {31.79575, 93.743875, 47.699875}\n"
"		// Rotation genes are expresed in the Shoemake space: genotype [3|4|5]\n"
"		// xyz_gene_gridspace = gridcenter_gridspace + (input_gene_realspace - gridcenter_realspace)/gridsize\n"
"\n"
"		// 1ac8				\n"
"		genotype[0] = 30 + (31.79575  - 31.924) / 0.375;\n"
"		genotype[1] = 30 + (93.743875 - 93.444) / 0.375;\n"
"		genotype[2] = 30 + (47.699875 - 47.924) / 0.375;\n"
"		genotype[3] = 0.1f;\n"
"		genotype[4] = 0.5f;\n"
"		genotype[5] = 0.9f;\n"
"		#endif\n"
"\n"
"		#if 0\n"
"		// 3tmn\n"
"		genotype[0] = 30 + (ligand_center_x - grid_center_x) / 0.375;\n"
"		genotype[1] = 30 + (ligand_center_y - grid_center_y) / 0.375;\n"
"		genotype[2] = 30 + (ligand_center_z - grid_center_z) / 0.375;\n"
"		genotype[3] = shoemake_gene_u1;\n"
"		genotype[4] = shoemake_gene_u2;\n"
"		genotype[5] = shoemake_gene_u3;\n"
"		genotype[6] = 0.0f;\n"
"		genotype[7] = 0.0f;\n"
"		genotype[8] = 0.0f;\n"
"		genotype[9] = 0.0f;\n"
"		genotype[10] = 0.0f;\n"
"		genotype[11] = 0.0f;\n"
"		genotype[12] = 0.0f;\n"
"		genotype[13] = 0.0f;\n"
"		genotype[14] = 0.0f;\n"
"		genotype[15] = 0.0f;\n"
"		genotype[16] = 0.0f;\n"
"		genotype[17] = 0.0f;\n"
"		genotype[18] = 0.0f;\n"
"		genotype[19] = 0.0f;\n"
"		genotype[20] = 0.0f;\n"
"		#endif\n"
"\n"
"		// Calculating gradient\n"
"		// =============================================================\n"
"		gpu_calc_gradient(\n"
"				dockpars_rotbondlist_length,\n"
"				dockpars_num_of_atoms,\n"
"				dockpars_gridsize_x,\n"
"				dockpars_gridsize_y,\n"
"				dockpars_gridsize_z,\n"
"				dockpars_fgrids,\n"
"				dockpars_num_of_atypes,\n"
"				dockpars_num_of_intraE_contributors,\n"
"				dockpars_grid_spacing,\n"
"				dockpars_coeff_elec,\n"
"				dockpars_qasp,\n"
"				dockpars_coeff_desolv,\n"
"				// Some OpenCL compilers don't allow declaring \n"
"				// local variables within non-kernel functions.\n"
"				// These local variables must be declared in a kernel, \n"
"				// and then passed to non-kernel functions.\n"
"				genotype,\n"
"				&energy,\n"
"				&run_id,\n"
"\n"
"				calc_coords_x,\n"
"				calc_coords_y,\n"
"				calc_coords_z,\n"
"\n"
"			        atom_charges_const,\n"
"				atom_types_const,\n"
"				intraE_contributors_const,\n"
"				VWpars_AC_const,\n"
"				VWpars_BD_const,\n"
"				dspars_S_const,\n"
"				dspars_V_const,\n"
"				rotlist_const,\n"
"				ref_coords_x_const,\n"
"				ref_coords_y_const,\n"
"				ref_coords_z_const,\n"
"				rotbonds_moving_vectors_const,\n"
"				rotbonds_unit_vectors_const,\n"
"				ref_orientation_quats_const,\n"
"				rotbonds_const,\n"
"				rotbonds_atoms_const,\n"
"				num_rotating_atoms_per_rotbond_const\n"
"			 	// Gradient-related arguments\n"
"			 	// Calculate gradients (forces) for intermolecular energy\n"
"			 	// Derived from autodockdev/maps.py\n"
"				,\n"
"				dockpars_num_of_genes,\n"
"				gradient_inter_x,\n"
"				gradient_inter_y,\n"
"				gradient_inter_z,\n"
"				gradient_intra_x,\n"
"				gradient_intra_y,\n"
"				gradient_intra_z,\n"
"				gradient_x,\n"
"				gradient_y,\n"
"				gradient_z,\n"
"				gradient_per_intracontributor,\n"
"				gradient\n"
"				);\n"
"		// =============================================================\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		\n"
"		for(uint i = get_local_id(0); i < dockpars_num_of_genes; i+= NUM_OF_THREADS_PER_BLOCK) {\n"
"\n"
"	     		// Taking step\n"
"			candidate_genotype[i] = genotype[i] - alpha * gradient[i];	\n"
"\n"
"			#if defined (DEBUG_MINIMIZER)\n"
"			//printf(\"(%-3u) %-0.15f %-10.10f %-10.10f %-10.10f\\n\", i, alpha, genotype[i], gradient[i], candidate_genotype[i]);\n"
"			#endif\n"
"\n"
"			// Checking if every gene of candidate_genotype\n"
"			// is neither a nan, not inf\n"
"   			is_candidate_genotype_valid[i] = (isnan(candidate_genotype[i]) == 0) && (isinf(candidate_genotype[i]) == 0);\n"
"\n"
"			// Verifying that Shoemake genes \n"
"			// do not get out of valid region\n"
"			if ((i > 2) && (i < 6)) {\n"
"				if (is_candidate_genotype_valid[i] == true) {\n"
"					//printf(\"BEFORE is_candidate_genotype_valid[%u]?: %s\\n\", i, (is_candidate_genotype_valid[i] == true)?\"yes\":\"no\");\n"
"					if ((candidate_genotype[i] < 0.0f) || (candidate_genotype[i] > 1.0f)){\n"
"						is_candidate_genotype_valid[i] = false;\n"
"						//printf(\"AFTER  is_candidate_genotype_valid[%u]?: %s\\n\", i, (is_candidate_genotype_valid[i] == true)?\"yes\":\"no\");\n"
"					}\n"
"				}\n"
"			}\n"
"	   	}\n"
"		\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		__local bool is_valid;\n"
"\n"
"		// Reducing all \"valid\" values of genes\n"
"		// into their corresponding genotype\n"
"		if (get_local_id(0) == 0) { \n"
"			is_valid = true;\n"
"			\n"
"		  	for(uint i = 0; i < dockpars_num_of_genes;i++) {\n"
"		    		is_valid = is_valid && is_candidate_genotype_valid[i];\n"
"			\n"
"				#if defined (DEBUG_MINIMIZER)\n"
"				//printf(\"is_candidate_genotype_valid[%u]?: %s\\n\", i, (is_candidate_genotype_valid[i] == true)?\"yes\":\"no\");\n"
"				#endif\n"
"		  	}\n"
"			/*\n"
"			if (is_valid == false) {\n"
"				exit = true;\n"
"			}\n"
"			*/\n"
"			#if defined (DEBUG_MINIMIZER)\n"
"			//printf(\"is_valid?: %s, exit?: %s\\n\", (is_valid == true)?\"yes\":\"no\", (exit == true)?\"yes\":\"no\");\n"
"			if (is_valid == false) {\n"
"				printf(\"Candidate genome is invalid!\\n\");\n"
"			}\n"
"			#endif\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		/*if (exit == false) {*/\n"
"		if (is_valid == true) {\n"
"				// =============================================================\n"
"				gpu_calc_energy(dockpars_rotbondlist_length,\n"
"						dockpars_num_of_atoms,\n"
"						dockpars_gridsize_x,\n"
"						dockpars_gridsize_y,\n"
"						dockpars_gridsize_z,\n"
"						dockpars_fgrids,\n"
"						dockpars_num_of_atypes,\n"
"						dockpars_num_of_intraE_contributors,\n"
"						dockpars_grid_spacing,\n"
"						dockpars_coeff_elec,\n"
"						dockpars_qasp,\n"
"						dockpars_coeff_desolv,\n"
"						candidate_genotype,\n"
"						&candidate_energy,\n"
"						&run_id,\n"
"						// Some OpenCL compilers don't allow declaring \n"
"						// local variables within non-kernel functions.\n"
"						// These local variables must be declared in a kernel, \n"
"						// and then passed to non-kernel functions.\n"
"						calc_coords_x,\n"
"						calc_coords_y,\n"
"						calc_coords_z,\n"
"						partial_energies,\n"
"						#if defined (DEBUG_ENERGY_KERNEL1)\n"
"						partial_interE,\n"
"						partial_intraE,\n"
"						#endif\n"
"\n"
"						atom_charges_const,\n"
"						atom_types_const,\n"
"						intraE_contributors_const,\n"
"						VWpars_AC_const,\n"
"						VWpars_BD_const,\n"
"						dspars_S_const,\n"
"						dspars_V_const,\n"
"						rotlist_const,\n"
"						ref_coords_x_const,\n"
"						ref_coords_y_const,\n"
"						ref_coords_z_const,\n"
"						rotbonds_moving_vectors_const,\n"
"						rotbonds_unit_vectors_const,\n"
"						ref_orientation_quats_const\n"
"						);\n"
"				// =============================================================\n"
"\n"
"				// Updating number of energy-evaluations counter\n"
"				if (get_local_id(0) == 0) {\n"
"					evaluation_cnt = evaluation_cnt + 1;\n"
"				}\n"
"				barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"				// Checking if E(candidate_genotype) < E(genotype)\n"
"				if (candidate_energy < energy){\n"
"					// Updating energy\n"
"					if (get_local_id(0) == 0) {				\n"
"						energy = candidate_energy;\n"
"					}\n"
"\n"
"					for(uint i = get_local_id(0); \n"
"					 	 i < dockpars_num_of_genes; \n"
"					 	 i+= NUM_OF_THREADS_PER_BLOCK) {\n"
"\n"
"						// Updating genotype\n"
"						genotype [i] = candidate_genotype[i];\n"
"			\n"
"						// Up-scaling alpha by one order magnitud\n"
"						alpha = alpha*/*10*/(5/(failure_cnt == 0?(failure_cnt+1):(failure_cnt)));\n"
"\n"
"						#if defined (DEBUG_MINIMIZER)\n"
"						//printf(\"(%-3u) %-15.15f %-10.10f %-10.10f %-10.10f\\n\", i, alpha, genotype[i], gradient[i], candidate_genotype[i]);\n"
"						#endif\n"
"					}\n"
"				}\n"
"				// If E (candidate) is worse \n"
"				else {\n"
"					// Update failure counter\n"
"					if (get_local_id(0) == 0) {\n"
"						failure_cnt = failure_cnt + 1;\n"
"\n"
"						#if defined (DEBUG_MINIMIZER)\n"
"						printf(\"Candidate energy has not improved!\\n\");\n"
"						#endif\n"
"					}\n"
"					barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"					// Down-scaling alpha by one order magnitud.\n"
"					// Genotype is not updated, meaning that search will be\n"
"					// started over from the same point from with different alpha\n"
"					for(uint i = get_local_id(0); \n"
"						 i < dockpars_num_of_genes; \n"
"						 i+= NUM_OF_THREADS_PER_BLOCK) {\n"
"						alpha = native_divide(alpha, 5*failure_cnt/*10*/);\n"
"\n"
"						#if defined (DEBUG_MINIMIZER)\n"
"						//printf(\"(%-3u) %-15.15f\\n\", i, alpha);\n"
"						#endif\n"
"					}	\n"
"				} // End of energy comparison\n"
"			/*} // End of if(valid genotypes)*/\n"
"		} \n"
"		else {\n"
"			// Update failure counter\n"
"			if (get_local_id(0) == 0) {\n"
"				failure_cnt = failure_cnt + 1;\n"
"			}\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			// Down-scaling alpha by one order magnitud.\n"
"			// Genotype is not updated, meaning that search will be\n"
"			// started over from the same point from with different alpha\n"
"			for(uint i = get_local_id(0); \n"
"				 i < dockpars_num_of_genes; \n"
"				 i+= NUM_OF_THREADS_PER_BLOCK) {\n"
"				alpha = native_divide(alpha, 5*failure_cnt/*10*/);\n"
"\n"
"				#if defined (DEBUG_MINIMIZER)\n"
"				//printf(\"(%-3u) %-15.15f\\n\", i, alpha);\n"
"				#endif\n"
"			}\n"
"		} // End of if(exit==false)\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// Updating number of stepest-descent iterations\n"
"		if (get_local_id(0) == 0) {\n"
"	    		iteration_cnt = iteration_cnt + 1;\n"
"\n"
"			#if defined (DEBUG_MINIMIZER)\n"
"			printf(\"# mini-iters: %-3u, # ener-evals: %-3u, # failures: %-3u, energy: %f\\n\", iteration_cnt, evaluation_cnt, failure_cnt, energy);\n"
"			#endif\n"
"\n"
"			#if defined (DEBUG_ENERGY_KERNEL5)\n"
"			printf(\"%-18s [%-5s]---{%-5s}   [%-10.8f]---{%-10.8f}\\n\", \"-ENERGY-KERNEL5-\", \"GRIDS\", \"INTRA\", partial_interE[0], partial_intraE[0]);\n"
"			#endif\n"
"		}\n"
"\n"
"  	} while ((iteration_cnt < gradMin_maxiters) && (failure_cnt < gradMin_maxfails) /*&& (exit == false)*/);\n"
"\n"
"	// -----------------------------------------------------------------------------\n"
"\n"
"  	// Updating eval counter and energy\n"
"	if (get_local_id(0) == 0) {\n"
"		dockpars_evals_of_new_entities[run_id*dockpars_pop_size+entity_id] += evaluation_cnt;\n"
"		dockpars_energies_next[run_id*dockpars_pop_size+entity_id] = energy;\n"
"\n"
"		#if defined (DEBUG_MINIMIZER)\n"
"		printf(\"-------> End of grad-min cycle, num of evals: %u, final energy: %.5f\\n\", evaluation_cnt, energy);\n"
"		#endif\n"
"	}\n"
"\n"
"	// Mapping torsion angles\n"
"	for (uint gene_counter = get_local_id(0);\n"
"	     	  gene_counter < dockpars_num_of_genes;\n"
"	          gene_counter+= NUM_OF_THREADS_PER_BLOCK) {\n"
"		   if (gene_counter >= 6) {\n"
"			    map_angle(&(genotype[gene_counter]));\n"
"		   }\n"
"	}\n"
"\n"
"	// Updating old offspring in population\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	async_work_group_copy(dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"			      genotype,\n"
"			      dockpars_num_of_genes, 0);\n"
"}\n"
;
#endif // End of STRINGIFY_H

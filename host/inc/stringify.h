// OCLADOCK: AUTOMATICALLY GENERATED FILE, DO NOT EDIT
#ifndef STRINGIFY_H
#define STRINGIFY_H
const char *calcenergy_ocl =
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"#ifndef DEFINES_H_\n"
"#define DEFINES_H_\n"
"\n"
"#if defined (N16WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 16\n"
"#elif defined (N32WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 32\n"
"#elif defined (N64WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 64\n"
"#elif defined (N128WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 128\n"
"#elif defined (N256WI)\n"
"	#define NUM_OF_THREADS_PER_BLOCK 256\n"
"#else\n"
"	#define NUM_OF_THREADS_PER_BLOCK 64\n"
"#endif\n"
"\n"
"#define MAX_NUM_OF_ATOMS 				256\n"
"#define MAX_NUM_OF_ATYPES 			14\n"
"#define MAX_NUM_OF_ROTBONDS 		32\n"
"#define MAX_INTRAE_CONTRIBUTORS MAX_NUM_OF_ATOMS * MAX_NUM_OF_ATOMS\n"
"#define MAX_NUM_OF_ROTATIONS 		MAX_NUM_OF_ATOMS * MAX_NUM_OF_ROTBONDS\n"
"#define MAX_POPSIZE 						2048\n"
"#define MAX_NUM_OF_RUNS 				1000\n"
"\n"
"// Must be bigger than MAX_NUM_OF_ROTBONDS+6\n"
"#define GENOTYPE_LENGTH_IN_GLOBMEM 64\n"
"#define ACTUAL_GENOTYPE_LENGTH	(MAX_NUM_OF_ROTBONDS+6)\n"
"\n"
"#define LS_EXP_FACTOR 					2.0f\n"
"#define LS_CONT_FACTOR 					0.5f\n"
"\n"
"// Improvements over Pechan's implementation\n"
"#define NATIVE_PRECISION\n"
"#define ASYNC_COPY\n"
"#define IMPROVE_GRID\n"
"#define RESTRICT_ARGS\n"
"#define MAPPED_COPY\n"
"\n"
"#endif /* DEFINES_H_ */\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"#ifndef CALCENERGY_BASIC_H_\n"
"#define CALCENERGY_BASIC_H_\n"
"\n"
"\n"
"#define RLIST_ATOMID_MASK 	 0x000000FF\n"
"#define RLIST_RBONDID_MASK 	 0x0000FF00\n"
"#define RLIST_RBONDID_SHIFT  8\n"
"#define RLIST_FIRSTROT_MASK  0x00010000\n"
"#define RLIST_GENROT_MASK 	 0x00020000\n"
"#define RLIST_DUMMY_MASK 	 	 0x00040000\n"
"#define DEG_TO_RAD 					 0.0174533f\n"
"\n"
"// LCG: linear congruential generator constants\n"
"#define RAND_A 							1103515245u\n"
"#define RAND_C 							12345u\n"
"// WARNING: it is supposed that unsigned int is 32 bit long\n"
"#define MAX_UINT 						4294967296.0f\n"
"\n"
"// Macro for capturing grid values\n"
"	// Original\n"
"	#define GETGRIDVALUE(mempoi,gridsize_x,gridsize_y,gridsize_z,t,z,y,x)   *(mempoi + gridsize_x*(y + gridsize_y*(z + gridsize_z*t)) + x)\n"
"\n"
"	// Optimization 1\n"
"	// #define GETGRIDVALUE_OPT(mempoi,gridsize_x,gridsize_y,mul_tmp,z,y,x)   *(mempoi + gridsize_x*(y + gridsize_y*(z + mul_tmp)) + x)\n"
"\n"
"	// Optimization 2\n"
"	// Implemented direclty in the kernel code: calcenergy_fourkernels_intel.cl\n"
"\n"
"// Macro for trilinear interpolation\n"
"#define TRILININTERPOL(cube, weights) (cube[0][0][0]*weights[0][0][0] +cube[1][0][0]*weights[1][0][0] +	\\\n"
"				       cube[0][1][0]*weights[0][1][0] +cube[1][1][0]*weights[1][1][0] + \\\n"
"				       cube[0][0][1]*weights[0][0][1] +cube[1][0][1]*weights[1][0][1] + \\\n"
"				       cube[0][1][1]*weights[0][1][1] +cube[1][1][1]*weights[1][1][1])\n"
"\n"
"// Used for Shoemake to quternion transformation\n"
"#define PI_TIMES_2 (float)(2.0f*M_PI)\n"
"\n"
"\n"
"\n"
"#endif /* CALCENERGY_BASIC_H_ */\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"\n"
"// All related pragmas are in defines.h (accesible by host and device code)\n"
"\n"
"void gpu_calc_energy(	    int    dockpars_rotbondlist_length,\n"
"			    char   dockpars_num_of_atoms,\n"
"			    char   dockpars_gridsize_x,\n"
"			    char   dockpars_gridsize_y,\n"
"			    char   dockpars_gridsize_z,\n"
"		#if defined (RESTRICT_ARGS)\n"
"			__global const float* restrict dockpars_fgrids, // cannot be allocated in __constant (too large)\n"
"		#else\n"
"			__global const float* dockpars_fgrids, 		// cannot be allocated in __constant (too large)\n"
"		#endif\n"
"		            char   dockpars_num_of_atypes,\n"
"		            int    dockpars_num_of_intraE_contributors,\n"
"			    float  dockpars_grid_spacing,\n"
"			    float  dockpars_coeff_elec,\n"
"			    float  dockpars_qasp,\n"
"			    float  dockpars_coeff_desolv,\n"
"\n"
"                    // Some OpenCL compilers don't allow declaring \n"
"		    // local variables within non-kernel functions.\n"
"		    // These local variables must be declared in a kernel, \n"
"		    // and then passed to non-kernel functions.\n"
"		    __local float* genotype,\n"
"		    __local float* energy,\n"
"		    __local int*   run_id,\n"
"\n"
"		    __local float* calc_coords_x,\n"
"		    __local float* calc_coords_y,\n"
"		    __local float* calc_coords_z,\n"
"		    __local float* partial_energies,\n"
"\n"
"	         __constant float* atom_charges_const,\n"
"                 __constant char*  atom_types_const,\n"
"                 __constant char*  intraE_contributors_const,\n"
"                 __constant float* VWpars_AC_const,\n"
"                 __constant float* VWpars_BD_const,\n"
"                 __constant float* dspars_S_const,\n"
"                 __constant float* dspars_V_const,\n"
"                 __constant int*   rotlist_const,\n"
"                 __constant float* ref_coords_x_const,\n"
"                 __constant float* ref_coords_y_const,\n"
"                 __constant float* ref_coords_z_const,\n"
"                 __constant float* rotbonds_moving_vectors_const,\n"
"                 __constant float* rotbonds_unit_vectors_const,\n"
"                 __constant float* ref_orientation_quats_const,\n"
"\n"
"		    // Gradient-related arguments\n"
"		    // Calculate gradients (forces) for intermolecular energy\n"
"		    // Derived from autodockdev/maps.py\n"
"		\n"
"		    // \"is_enabled_gradient_calc\": enables gradient calculation.\n"
"		    // In Genetic-Generation: no need for gradients\n"
"		    // In Gradient-Minimizer: must calculate gradients\n"
"		    __local bool*  is_enabled_gradient_calc,\n"
"	    	    __local float* gradient_inter_x,\n"
"	            __local float* gradient_inter_y,\n"
"	            __local float* gradient_inter_z,\n"
"		    __local float* gradient_genotype	\n"
"			\n"
")\n"
"\n"
"//The GPU device function calculates the energy of the entity described by genotype, dockpars and the liganddata\n"
"//arrays in constant memory and returns it in the energy parameter. The parameter run_id has to be equal to the ID\n"
"//of the run whose population includes the current entity (which can be determined with blockIdx.x), since this\n"
"//determines which reference orientation should be used.\n"
"{\n"
"	partial_energies[get_local_id(0)] = 0.0f;\n"
"\n"
"	// -------------------------------------------------------------------\n"
"	// Calculate gradients (forces) for intermolecular energy\n"
"	// Derived from autodockdev/maps.py\n"
"	// -------------------------------------------------------------------\n"
"	if (*is_enabled_gradient_calc) {\n"
"		for (uint atom_id = get_local_id(0);\n"
"		          atom_id < dockpars_num_of_atoms;\n"
"		          atom_id+= NUM_OF_THREADS_PER_BLOCK) {\n"
"			gradient_inter_x[atom_id] = 0.0f;\n"
"			gradient_inter_y[atom_id] = 0.0f;\n"
"			gradient_inter_z[atom_id] = 0.0f;\n"
"		}\n"
"	}\n"
"\n"
"#if 0\n"
"	// Rotational genes in the Shoemake space expressed in radians\n"
"	float u1, u2, u3; \n"
"	\n"
"	u1 = genotype[3];\n"
"	u2 = genotype[4]/**DEG_TO_RAD*/;\n"
"	u3 = genotype[5]/**DEG_TO_RAD*/;\n"
"#endif\n"
"\n"
"#if defined (IMPROVE_GRID)\n"
"	// INTERMOLECULAR for-loop (intermediate results)\n"
"	// It stores a product of two chars\n"
"	//uint mul_tmp;\n"
"\n"
"	uchar g1 = dockpars_gridsize_x;\n"
"	uint  g2 = dockpars_gridsize_x * dockpars_gridsize_y;\n"
"  	uint  g3 = dockpars_gridsize_x * dockpars_gridsize_y * dockpars_gridsize_z;\n"
"#else\n"
"\n"
"#endif\n"
"\n"
"	// ================================================\n"
"	// CALCULATE ATOMIC POSITIONS AFTER ROTATIONS\n"
"	// ================================================\n"
"	for (uint rotation_counter = get_local_id(0);\n"
"	          rotation_counter < dockpars_rotbondlist_length;\n"
"	          rotation_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		int rotation_list_element = rotlist_const[rotation_counter];\n"
"\n"
"		if ((rotation_list_element & RLIST_DUMMY_MASK) == 0)	// If not dummy rotation\n"
"		{\n"
"			uint atom_id = rotation_list_element & RLIST_ATOMID_MASK;\n"
"\n"
"			// Capturing atom coordinates\n"
"			float atom_to_rotate[3];\n"
"\n"
"			if ((rotation_list_element & RLIST_FIRSTROT_MASK) != 0)	// If first rotation of this atom\n"
"			{\n"
"				atom_to_rotate[0] = ref_coords_x_const[atom_id];\n"
"				atom_to_rotate[1] = ref_coords_y_const[atom_id];\n"
"				atom_to_rotate[2] = ref_coords_z_const[atom_id];\n"
"			}\n"
"			else\n"
"			{\n"
"				atom_to_rotate[0] = calc_coords_x[atom_id];\n"
"				atom_to_rotate[1] = calc_coords_y[atom_id];\n"
"				atom_to_rotate[2] = calc_coords_z[atom_id];\n"
"			}\n"
"\n"
"			// Capturing rotation vectors and angle\n"
"			float rotation_movingvec[3];\n"
"\n"
"			float quatrot_left_x, quatrot_left_y, quatrot_left_z, quatrot_left_q;\n"
"			float quatrot_temp_x, quatrot_temp_y, quatrot_temp_z, quatrot_temp_q;\n"
"\n"
"			if ((rotation_list_element & RLIST_GENROT_MASK) != 0)	// If general rotation\n"
"			{\n"
"				// -------------------------------------------------------------------\n"
"				// Replacing rotation genes: from spherical space to Shoemake space\n"
"				// gene [0:2]: translation -> kept as original x, y, z\n"
"				// gene [3:5]: rotation    -> transformed into Shoemake (u1: adimensional, u2&u3: sexagesimal)\n"
"				// gene [6:N]: torsions	   -> kept as original angles	(all in sexagesimal)\n"
"\n"
"				// Shoemake ranges:\n"
"				// u1: [0, 1]\n"
"				// u2: [0: 2PI] or [0: 360]\n"
"\n"
"				// Random generator in the host is changed:\n"
"				// LCG (original, myrand()) -> CPP std (rand())\n"
"				// -------------------------------------------------------------------\n"
"\n"
"				// Transforming Shoemake (u1, u2, u3) genes into quaternions\n"
"				// FIXME: add precision choices with preprocessor directives: \n"
"				// NATIVE_PRECISION, HALF_PRECISION, Full precision\n"
"\n"
"				// Rotational genes in the Shoemake space expressed in radians\n"
"				float u1, u2, u3; \n"
"	\n"
"				u1 = genotype[3];\n"
"				u2 = genotype[4]/**DEG_TO_RAD*/;\n"
"				u3 = genotype[5]/**DEG_TO_RAD*/;\n"
"\n"
"				// u1, u2, u3 should be within their valid range of [0,1]\n"
"				quatrot_left_q = native_sqrt(1 - u1) * native_sin(PI_TIMES_2*u2); \n"
"				quatrot_left_x = native_sqrt(1 - u1) * native_cos(PI_TIMES_2*u2);\n"
"				quatrot_left_y = native_sqrt(u1)     * native_sin(PI_TIMES_2*u3);\n"
"				quatrot_left_z = native_sqrt(u1)     * native_cos(PI_TIMES_2*u3);\n"
"\n"
"				rotation_movingvec[0] = genotype[0];\n"
"				rotation_movingvec[1] = genotype[1];\n"
"				rotation_movingvec[2] = genotype[2];\n"
"			}\n"
"			else	// If rotating around rotatable bond\n"
"			{\n"
"				uint rotbond_id = (rotation_list_element & RLIST_RBONDID_MASK) >> RLIST_RBONDID_SHIFT;\n"
"\n"
"				float rotation_unitvec[3];\n"
"				rotation_unitvec[0] = rotbonds_unit_vectors_const[3*rotbond_id];\n"
"				rotation_unitvec[1] = rotbonds_unit_vectors_const[3*rotbond_id+1];\n"
"				rotation_unitvec[2] = rotbonds_unit_vectors_const[3*rotbond_id+2];\n"
"				float rotation_angle = genotype[6+rotbond_id]*DEG_TO_RAD;\n"
"\n"
"				rotation_movingvec[0] = rotbonds_moving_vectors_const[3*rotbond_id];\n"
"				rotation_movingvec[1] = rotbonds_moving_vectors_const[3*rotbond_id+1];\n"
"				rotation_movingvec[2] = rotbonds_moving_vectors_const[3*rotbond_id+2];\n"
"\n"
"				// Performing additionally the first movement which \n"
"				// is needed only if rotating around rotatable bond\n"
"				atom_to_rotate[0] -= rotation_movingvec[0];\n"
"				atom_to_rotate[1] -= rotation_movingvec[1];\n"
"				atom_to_rotate[2] -= rotation_movingvec[2];\n"
"\n"
"				// Transforming torsion angles into quaternions\n"
"				// FIXME: add precision choices with preprocessor directives: \n"
"				// NATIVE_PRECISION, HALF_PRECISION, Full precision\n"
"				rotation_angle  = native_divide(rotation_angle, 2.0f);\n"
"				float sin_angle = native_sin(rotation_angle);\n"
"				quatrot_left_q  = native_cos(rotation_angle);\n"
"				quatrot_left_x  = sin_angle*rotation_unitvec[0];\n"
"				quatrot_left_y  = sin_angle*rotation_unitvec[1];\n"
"				quatrot_left_z  = sin_angle*rotation_unitvec[2];\n"
"			}\n"
"\n"
"			// Performing rotation\n"
"			if ((rotation_list_element & RLIST_GENROT_MASK) != 0)	// If general rotation,\n"
"										// two rotations should be performed\n"
"										// (multiplying the quaternions)\n"
"			{\n"
"				// Calculating quatrot_left*ref_orientation_quats_const,\n"
"				// which means that reference orientation rotation is the first\n"
"				quatrot_temp_q = quatrot_left_q;\n"
"				quatrot_temp_x = quatrot_left_x;\n"
"				quatrot_temp_y = quatrot_left_y;\n"
"				quatrot_temp_z = quatrot_left_z;\n"
"\n"
"				quatrot_left_q = quatrot_temp_q*ref_orientation_quats_const[4*(*run_id)]-\n"
"						 quatrot_temp_x*ref_orientation_quats_const[4*(*run_id)+1]-\n"
"						 quatrot_temp_y*ref_orientation_quats_const[4*(*run_id)+2]-\n"
"						 quatrot_temp_z*ref_orientation_quats_const[4*(*run_id)+3];\n"
"				quatrot_left_x = quatrot_temp_q*ref_orientation_quats_const[4*(*run_id)+1]+\n"
"						 ref_orientation_quats_const[4*(*run_id)]*quatrot_temp_x+\n"
"						 quatrot_temp_y*ref_orientation_quats_const[4*(*run_id)+3]-\n"
"						 ref_orientation_quats_const[4*(*run_id)+2]*quatrot_temp_z;\n"
"				quatrot_left_y = quatrot_temp_q*ref_orientation_quats_const[4*(*run_id)+2]+\n"
"						 ref_orientation_quats_const[4*(*run_id)]*quatrot_temp_y+\n"
"						 ref_orientation_quats_const[4*(*run_id)+1]*quatrot_temp_z-\n"
"						 quatrot_temp_x*ref_orientation_quats_const[4*(*run_id)+3];\n"
"				quatrot_left_z = quatrot_temp_q*ref_orientation_quats_const[4*(*run_id)+3]+\n"
"						 ref_orientation_quats_const[4*(*run_id)]*quatrot_temp_z+\n"
"						 quatrot_temp_x*ref_orientation_quats_const[4*(*run_id)+2]-\n"
"						 ref_orientation_quats_const[4*(*run_id)+1]*quatrot_temp_y;\n"
"			}\n"
"\n"
"			quatrot_temp_q = 0 -\n"
"					 quatrot_left_x*atom_to_rotate [0] -\n"
"					 quatrot_left_y*atom_to_rotate [1] -\n"
"					 quatrot_left_z*atom_to_rotate [2];\n"
"			quatrot_temp_x = quatrot_left_q*atom_to_rotate [0] +\n"
"					 quatrot_left_y*atom_to_rotate [2] -\n"
"					 quatrot_left_z*atom_to_rotate [1];\n"
"			quatrot_temp_y = quatrot_left_q*atom_to_rotate [1] -\n"
"					 quatrot_left_x*atom_to_rotate [2] +\n"
"					 quatrot_left_z*atom_to_rotate [0];\n"
"			quatrot_temp_z = quatrot_left_q*atom_to_rotate [2] +\n"
"					 quatrot_left_x*atom_to_rotate [1] -\n"
"					 quatrot_left_y*atom_to_rotate [0];\n"
"\n"
"			atom_to_rotate [0] = 0 -\n"
"					  quatrot_temp_q*quatrot_left_x +\n"
"					  quatrot_temp_x*quatrot_left_q -\n"
"					  quatrot_temp_y*quatrot_left_z +\n"
"					  quatrot_temp_z*quatrot_left_y;\n"
"			atom_to_rotate [1] = 0 -\n"
"					  quatrot_temp_q*quatrot_left_y +\n"
"					  quatrot_temp_x*quatrot_left_z +\n"
"					  quatrot_temp_y*quatrot_left_q -\n"
"					  quatrot_temp_z*quatrot_left_x;\n"
"			atom_to_rotate [2] = 0 -\n"
"					  quatrot_temp_q*quatrot_left_z -\n"
"					  quatrot_temp_x*quatrot_left_y +\n"
"					  quatrot_temp_y*quatrot_left_x +\n"
"					  quatrot_temp_z*quatrot_left_q;\n"
"\n"
"			// Performing final movement and storing values\n"
"			calc_coords_x[atom_id] = atom_to_rotate [0] + rotation_movingvec[0];\n"
"			calc_coords_y[atom_id] = atom_to_rotate [1] + rotation_movingvec[1];\n"
"			calc_coords_z[atom_id] = atom_to_rotate [2] + rotation_movingvec[2];\n"
"\n"
"		} // End if-statement not dummy rotation\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	} // End rotation_counter for-loop\n"
"\n"
"	// -------------------------------------------------------------------\n"
"	// Calculate gradients (forces) for intermolecular energy\n"
"	// Derived from autodockdev/maps.py\n"
"	// -------------------------------------------------------------------\n"
"	// Variables to store gradient of \n"
"	// the intermolecular energy per each ligand atom\n"
"\n"
"	// Some OpenCL compilers don't allow declaring \n"
"	// local variables within non-kernel functions.\n"
"	// These local variables must be declared in a kernel, \n"
"	// and then passed to non-kernel functions.\n"
"	/*\n"
"	__local float gradient_inter_x[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_inter_y[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_inter_z[MAX_NUM_OF_ATOMS];\n"
"	*/\n"
"\n"
"	// Deltas dx, dy, dz are already normalized \n"
"	// (by host/src/getparameters.cpp) in OCLaDock.\n"
"	// The correspondance between vertices in xyz axes is:\n"
"	// 0, 1, 2, 3, 4, 5, 6, 7  and  000, 100, 010, 001, 101, 110, 011, 111\n"
"	/*\n"
"            deltas: (x-x0)/(x1-x0), (y-y0...\n"
"            vertices: (000, 100, 010, 001, 101, 110, 011, 111)        \n"
"\n"
"                  Z\n"
"                  '\n"
"                  3 - - - - 6\n"
"                 /.        /|\n"
"                4 - - - - 7 |\n"
"                | '       | |\n"
"                | 0 - - - + 2 -- Y\n"
"                '/        |/\n"
"                1 - - - - 5\n"
"               /\n"
"              X\n"
"	*/\n"
"\n"
"	// Intermediate values for vectors in x-direction\n"
"	float x10, x52, x43, x76;\n"
"	float vx_z0, vx_z1;\n"
"\n"
"	// Intermediate values for vectors in y-direction\n"
"	float y20, y51, y63, y74;\n"
"	float vy_z0, vy_z1;\n"
"\n"
"	// Intermediate values for vectors in z-direction\n"
"	float z30, z41, z62, z75;\n"
"	float vz_y0, vz_y1;\n"
"	// -------------------------------------------------------------------\n"
"\n"
"	// ================================================\n"
"	// CALCULATE INTERMOLECULAR ENERGY\n"
"	// ================================================\n"
"	for (uint atom_id = get_local_id(0);\n"
"	          atom_id < dockpars_num_of_atoms;\n"
"	          atom_id+= NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		uint atom_typeid = atom_types_const[atom_id];\n"
"		float x = calc_coords_x[atom_id];\n"
"		float y = calc_coords_y[atom_id];\n"
"		float z = calc_coords_z[atom_id];\n"
"		float q = atom_charges_const[atom_id];\n"
"\n"
"		if ((x < 0) || (y < 0) || (z < 0) || (x >= dockpars_gridsize_x-1)\n"
"				                  || (y >= dockpars_gridsize_y-1)\n"
"						  || (z >= dockpars_gridsize_z-1)){\n"
"			partial_energies[get_local_id(0)] += 16777216.0f; //100000.0f;\n"
"			\n"
"			// -------------------------------------------------------------------\n"
"			// Calculate gradients (forces) for intermolecular energy\n"
"			// Derived from autodockdev/maps.py\n"
"			// -------------------------------------------------------------------\n"
"\n"
"			if (*is_enabled_gradient_calc) {\n"
"				// Penalty values are valid as long as they are high\n"
"				gradient_inter_x[atom_id] += 16777216.0f;\n"
"				gradient_inter_y[atom_id] += 16777216.0f;\n"
"				gradient_inter_z[atom_id] += 16777216.0f;\n"
"			}\n"
"			// -------------------------------------------------------------------\n"
"		}\n"
"		else\n"
"		{\n"
"			// Get coordinates\n"
"			int x_low  = (int)floor(x); \n"
"			int y_low  = (int)floor(y); \n"
"			int z_low  = (int)floor(z);\n"
"			int x_high = (int)ceil(x); \n"
"			int y_high = (int)ceil(y); \n"
"			int z_high = (int)ceil(z);\n"
"			float dx = x - x_low; \n"
"			float dy = y - y_low; \n"
"			float dz = z - z_low;\n"
"\n"
"			// Calculate interpolation weights\n"
"			float weights[2][2][2];\n"
"			weights [0][0][0] = (1-dx)*(1-dy)*(1-dz);\n"
"			weights [1][0][0] = dx*(1-dy)*(1-dz);\n"
"			weights [0][1][0] = (1-dx)*dy*(1-dz);\n"
"			weights [1][1][0] = dx*dy*(1-dz);\n"
"			weights [0][0][1] = (1-dx)*(1-dy)*dz;\n"
"			weights [1][0][1] = dx*(1-dy)*dz;\n"
"			weights [0][1][1] = (1-dx)*dy*dz;\n"
"			weights [1][1][1] = dx*dy*dz;\n"
"\n"
"			// Capture affinity values\n"
"#if defined (IMPROVE_GRID)\n"
"			uint ylow_times_g1  = y_low*g1;\n"
"			uint yhigh_times_g1 = y_high*g1;\n"
"		  	uint zlow_times_g2  = z_low*g2;\n"
"			uint zhigh_times_g2 = z_high*g2;\n"
"\n"
"			// Grid offset\n"
"			uint offset_cube_000 = x_low  + ylow_times_g1  + zlow_times_g2;\n"
"			uint offset_cube_100 = x_high + ylow_times_g1  + zlow_times_g2;\n"
"			uint offset_cube_010 = x_low  + yhigh_times_g1 + zlow_times_g2;\n"
"			uint offset_cube_110 = x_high + yhigh_times_g1 + zlow_times_g2;\n"
"			uint offset_cube_001 = x_low  + ylow_times_g1  + zhigh_times_g2;\n"
"			uint offset_cube_101 = x_high + ylow_times_g1  + zhigh_times_g2;\n"
"			uint offset_cube_011 = x_low  + yhigh_times_g1 + zhigh_times_g2;\n"
"			uint offset_cube_111 = x_high + yhigh_times_g1 + zhigh_times_g2;\n"
"\n"
"			uint mul_tmp = atom_typeid*g3;\n"
"\n"
"			float cube[2][2][2];\n"
"			cube [0][0][0] = *(dockpars_fgrids + offset_cube_000 + mul_tmp);\n"
"			cube [1][0][0] = *(dockpars_fgrids + offset_cube_100 + mul_tmp);\n"
"			cube [0][1][0] = *(dockpars_fgrids + offset_cube_010 + mul_tmp);\n"
"		        cube [1][1][0] = *(dockpars_fgrids + offset_cube_110 + mul_tmp);\n"
"		        cube [0][0][1] = *(dockpars_fgrids + offset_cube_001 + mul_tmp);\n"
"			cube [1][0][1] = *(dockpars_fgrids + offset_cube_101 + mul_tmp);\n"
"                        cube [0][1][1] = *(dockpars_fgrids + offset_cube_011 + mul_tmp);\n"
"                        cube [1][1][1] = *(dockpars_fgrids + offset_cube_111 + mul_tmp);\n"
"\n"
"			// -------------------------------------------------------------------\n"
"			// Calculate gradients (forces) corresponding to \n"
"			// \"atype\" intermolecular energy\n"
"			// Derived from autodockdev/maps.py\n"
"			// -------------------------------------------------------------------\n"
"\n"
"			if (*is_enabled_gradient_calc) {\n"
"				// vector in x-direction\n"
"				/*\n"
"			 	x10 = grid[int(vertices[1])] - grid[int(vertices[0])] # z = 0\n"
"				x52 = grid[int(vertices[5])] - grid[int(vertices[2])] # z = 0\n"
"				x43 = grid[int(vertices[4])] - grid[int(vertices[3])] # z = 1\n"
"				x76 = grid[int(vertices[7])] - grid[int(vertices[6])] # z = 1\n"
"				vx_z0 = (1-yd) * x10 + yd * x52     #  z = 0\n"
"				vx_z1 = (1-yd) * x43 + yd * x76     #  z = 1\n"
"				gradient[0] = (1-zd) * vx_z0 + zd * vx_z1 \n"
"				*/\n"
"\n"
"				x10 = cube [1][0][0] - cube [0][0][0]; // z = 0\n"
"				x52 = cube [1][1][0] - cube [0][1][0]; // z = 0\n"
"				x43 = cube [1][0][1] - cube [0][0][1]; // z = 1\n"
"				x76 = cube [1][1][1] - cube [0][1][1]; // z = 1\n"
"				vx_z0 = (1 - dy) * x10 + dy * x52;     // z = 0\n"
"				vx_z1 = (1 - dy) * x43 + dy * x76;     // z = 1\n"
"				gradient_inter_x[atom_id] += (1 - dz) * vx_z0 + dz * vx_z1;\n"
"\n"
"				// vector in y-direction\n"
"				/*\n"
"				y20 = grid[int(vertices[2])] - grid[int(vertices[0])] # z = 0\n"
"				y51 = grid[int(vertices[5])] - grid[int(vertices[1])] # z = 0\n"
"				y63 = grid[int(vertices[6])] - grid[int(vertices[3])] # z = 1\n"
"			for (uint rotation_counter = get_local_id(0);\n"
"	          rotation_counter < dockpars_rotbondlist_length;\n"
"	          rotation_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"	{	y74 = grid[int(vertices[7])] - grid[int(vertices[4])] # z = 1\n"
"				vy_z0 = (1-xd) * y20 + xd * y51     #  z = 0\n"
"				vy_z1 = (1-xd) * y63 + xd * y74     #  z = 1\n"
"				gradient[1] = (1-zd) * vy_z0 + zd * vy_z1\n"
"				*/\n"
"\n"
"				y20 = cube[0][1][0] - cube [0][0][0];	// z = 0\n"
"				y51 = cube[1][1][0] - cube [1][0][0];	// z = 0\n"
"				y63 = cube[0][1][1] - cube [0][0][1];	// z = 1\n"
"				y74 = cube[1][1][1] - cube [1][0][1];	// z = 1\n"
"				vy_z0 = (1 - dx) * y20 + dx * y51;	// z = 0\n"
"				vy_z1 = (1 - dx) * y63 + dx * y74;	// z = 1\n"
"				gradient_inter_y[atom_id] += (1 - dz) * vy_z0 + dz * vy_z1;\n"
"\n"
"				// vectors in z-direction\n"
"				/*	\n"
"				z30 = grid[int(vertices[3])] - grid[int(vertices[0])] # y = 0\n"
"				z41 = grid[int(vertices[4])] - grid[int(vertices[1])] # y = 0\n"
"				z62 = grid[int(vertices[6])] - grid[int(vertices[2])] # y = 1\n"
"				z75 = grid[int(vertices[7])] - grid[int(vertices[5])] # y = 1\n"
"				vz_y0 = (1-xd) * z30 + xd * z41     # y = 0\n"
"				vz_y1 = (1-xd) * z62 + xd * z75     # y = 1\n"
"				gradient[2] = (1-yd) * vz_y0 + yd * vz_y1\n"
"				*/\n"
"\n"
"				z30 = cube [0][0][1] - cube [0][0][0];	// y = 0\n"
"				z41 = cube [1][0][1] - cube [1][0][0];	// y = 0\n"
"				z62 = cube [0][1][1] - cube [0][1][0];	// y = 1 \n"
"				z75 = cube [1][1][1] - cube [1][1][0];	// y = 1\n"
"				vz_y0 = (1 - dx) * z30 + dx * z41;	// y = 0\n"
"				vz_y1 = (1 - dx) * z62 + dx * z75;	// y = 1\n"
"				gradient_inter_z[atom_id] += (1 - dy) * vz_y0 + dy * vz_y1;\n"
"			}\n"
"			// -------------------------------------------------------------------	\n"
"#else\n"
"			// -------------------------------------------------------------------\n"
"			// FIXME: this block within the \"#else\" preprocessor directive \n"
"			// provides NO gradient corresponding to \"atype\" intermolecular energy\n"
"			// -------------------------------------------------------------------	\n"
"\n"
"			cube [0][0][0] = GETGRIDVALUE(dockpars_fgrids, \n"
"						      dockpars_gridsize_x,\n"
"						      dockparsdockpars_num_of_atoms;_gridsize_y, \n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_low, y_low, x_low);\n"
"			cube [1][0][0] = GETGRIDVALUE(dockpars_fgrids, \n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y, \n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_low, y_low, x_high);\n"
"			cube [0][1][0] = GETGRIDVALUE(dockpars_fgrids, \n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y, \n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_low, y_high, x_low);\n"
"			cube [1][1][0] = GETGRIDVALUE(dockpars_fgrids, \n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y, \n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_low, y_high, x_high);\n"
"			cube [0][0][1] = GETGRIDVALUE(dockpars_fgrids, \n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y, \n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_high, y_low, x_low);\n"
"			cube [1][0][1] = GETGRIDVALUE(dockpars_fgrids, \n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y, \n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_high, y_low, x_high);\n"
"			cube [0][1][1] = GETGRIDVALUE(dockpars_fgrids, \n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y, \n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_high, y_high, x_low);\n"
"			cube [1][1][1] = GETGRIDVALUE(dockpars_fgrids, \n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y, \n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_high, y_high, x_high);\n"
"#endif\n"
"\n"
"			//calculating affinity energy\n"
"			partial_energies[get_local_id(0)] += TRILININTERPOL(cube, weights);\n"
"\n"
"			//capturing electrostatic values\n"
"			atom_typeid = dockpars_num_of_atypes;\n"
"\n"
"#if defined (IMPROVE_GRID)\n"
"			mul_tmp = atom_typeid*g3;\n"
"			cube [0][0][0] = *(dockpars_fgrids + offset_cube_000 + mul_tmp);\n"
"			cube [1][0][0] = *(dockpars_fgrids + offset_cube_100 + mul_tmp);\n"
"      			cube [0][1][0] = *(dockpars_fgrids + offset_cube_010 + mul_tmp);\n"
"      			cube [1][1][0] = *(dockpars_fgrids + offset_cube_110 + mul_tmp);\n"
"		       	cube [0][0][1] = *(dockpars_fgrids + offset_cube_001 + mul_tmp);\n"
"		        cube [1][0][1] = *(dockpars_fgrids + offset_cube_101 + mul_tmp);\n"
"		        cube [0][1][1] = *(dockpars_fgrids + offset_cube_011 + mul_tmp);\n"
"		        cube [1][1][1] = *(dockpars_fgrids + offset_cube_111 + mul_tmp);\n"
"\n"
"			// -------------------------------------------------------------------\n"
"			// Calculate gradients (forces) corresponding to \n"
"			// \"elec\" intermolecular energy\n"
"			// Derived from autodockdev/maps.py\n"
"			// -------------------------------------------------------------------\n"
"\n"
"			if (*is_enabled_gradient_calc) {\n"
"				// vector in x-direction\n"
"				x10 = cube [1][0][0] - cube [0][0][0]; // z = 0\n"
"				x52 = cube [1][1][0] - cube [0][1][0]; // z = 0\n"
"				x43 = cube [1][0][1] - cube [0][0][1]; // z = 1\n"
"				x76 = cube [1][1][1] - cube [0][1][1]; // z = 1\n"
"				vx_z0 = (1 - dy) * x10 + dy * x52;     // z = 0\n"
"				vx_z1 = (1 - dy) * x43 + dy * x76;     // z = 1\n"
"				gradient_inter_x[atom_id] += (1 - dz) * vx_z0 + dz * vx_z1;\n"
"\n"
"				// vector in y-direction\n"
"				y20 = cube[0][1][0] - cube [0][0][0];	// z = 0\n"
"				y51 = cube[1][1][0] - cube [1][0][0];	// z = 0\n"
"				y63 = cube[0][1][1] - cube [0][0][1];	// z = 1\n"
"				y74 = cube[1][1][1] - cube [1][0][1];	// z = 1\n"
"				vy_z0 = (1 - dx) * y20 + dx * y51;	// z = 0\n"
"				vy_z1 = (1 - dx) * y63 + dx * y74;	// z = 1\n"
"				gradient_inter_y[atom_id] += (1 - dz) * vy_z0 + dz * vy_z1;\n"
"\n"
"				// vectors in z-direction\n"
"				z30 = cube [0][0][1] - cube [0][0][0];	// y = 0\n"
"				z41 = cube [1][0][1] - cube [1][0][0];	// y = 0\n"
"				z62 = cube [0][1][1] - cube [0][1][0];	// y = 1 \n"
"				z75 = cube [1][1][1] - cube [1][1][0];	// y = 1\n"
"				vz_y0 = (1 - dx) * z30 + dx * z41;	// y = 0\n"
"				vz_y1 = (1 - dx) * z62 + dx * z75;	// y = 1\n"
"				gradient_inter_z[atom_id] += (1 - dy) * vz_y0 + dy * vz_y1;\n"
"			}\n"
"			// -------------------------------------------------------------------\n"
"#else\n"
"			// -------------------------------------------------------------------\n"
"			// FIXME: this block within the \"#else\" preprocessor directive \n"
"			// provides NO gradient corresponding to \"elec\" intermolecular energybas\n"
"			// -------------------------------------------------------------------\n"
"\n"
"			cube [0][0][0] = GETGRIDVALUE(dockpars_fgrids, \n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y, \n"
"						      dockpars_gridsize_z,\n"
"					 	      atom_typeid, z_low, y_low, x_low);\n"
"			cube [1][0][0] = GETGRIDVALUE(dockpars_fgrids, \n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y,\n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_low, y_low, x_high);\n"
"			cube [0][1][0] = GETGRIDVALUE(dockpars_fgrids,\n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y,\n"
"                                                      dockpars_gridsize_z,\n"
"						      atom_typeid, z_low, y_high, x_low);\n"
"			cube [1][1][0] = GETGRIDVALUE(dockpars_fgrids,\n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y,\n"
"						      dockpars_gridsize_z,bas\n"
"						      atom_typeid, z_low, y_high, x_high);\n"
"			cube [0][0][1] = GETGRIDVALUE(dockpars_fgrids,\n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y,\n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_high, y_low, x_low);\n"
"			cube [1][0][1] = GETGRIDVALUE(dockpars_fgrids,\n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y,\n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_high, y_low, x_high);\n"
"			cube [0][1][1] = GETGRIDVALUE(dockpars_fgrids,\n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y,\n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_high, y_high, x_low);\n"
"			cube [1][1][1] = GETGRIDVALUE(dockpars_fgrids,\n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y,\n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_high, y_high, x_high);\n"
"#endif\n"
"\n"
"			//calculating electrosatic energy\n"
"			partial_energies[get_local_id(0)] += q * TRILININTERPOL(cube, weights);\n"
"\n"
"			//capturing desolvation values\n"
"			atom_typeid = dockpars_num_of_atypes+1;\n"
"\n"
"#if defined (IMPROVE_GRID)\n"
"			mul_tmp = atom_typeid*g3;\n"
"			cube [0][0][0] = *(dockpars_fgrids + offset_cube_000 + mul_tmp);\n"
"			cube [1][0][0] = *(dockpars_fgrids + offset_cube_100 + mul_tmp);\n"
"      			cube [0][1][0] = *(dockpars_fgrids + offset_cube_010 + mul_tmp);\n"
"      			cube [1][1][0] = *(dockpars_fgrids + offset_cube_110 + mul_tmp);\n"
"      			cube [0][0][1] = *(dockpars_fgrids + offset_cube_001 + mul_tmp);\n"
"      			cube [1][0][1] = *(dockpars_fgrids + offset_cube_101 + mul_tmp);\n"
"      			cube [0][1][1] = *(dockpars_fgrids + offset_cube_011 + mul_tmp);\n"
"      			cube [1][1][1] = *(dockpars_fgrids + offset_cube_111 + mul_tmp);\n"
"\n"
"			// -------------------------------------------------------------------\n"
"			// Calculate gradients (forces) corresponding to \n"
"			// \"dsol\" intermolecular energy\n"
"			// Derived from autodockdev/maps.py\n"
"			// -------------------------------------------------------------------\n"
"\n"
"			if (*is_enabled_gradient_calc) {\n"
"				// vector in x-direction\n"
"				x10 = cube [1][0][0] - cube [0][0][0]; // z = 0\n"
"				x52 = cube [1][1][0] - cube [0][1][0]; // z = 0\n"
"				x43 = cube [1][0][1] - cube [0][0][1]; // z = 1\n"
"				x76 = cube [1][1][1] - cube [0][1][1]; // z = 1\n"
"				vx_z0 = (1 - dy) * x10 + dy * x52;     // z = 0\n"
"				vx_z1 = (1 - dy) * x43 + dy * x76;     // z = 1\n"
"				gradient_inter_x[atom_id] += (1 - dz) * vx_z0 + dz * vx_z1;\n"
"\n"
"				// vector in y-direction\n"
"				y20 = cube[0][1][0] - cube [0][0][0];	// z = 0\n"
"				y51 = cube[1][1][0] - cube [1][0][0];	// z = 0\n"
"				y63 = cube[0][1][1] - cube [0][0][1];	// z = 1\n"
"				y74 = cube[1][1][1] - cube [1][0][1];	// z = 1\n"
"				vy_z0 = (1 - dx) * y20 + dx * y51;	// z = 0\n"
"				vy_z1 = (1 - dx) * y63 + dx * y74;	// z = 1\n"
"				gradient_inter_y[atom_id] += (1 - dz) * vy_z0 + dz * vy_z1;\n"
"\n"
"				// vectors in z-direction\n"
"				z30 = cube [0][0][1] - cube [0][0][0];	// y = 0\n"
"				z41 = cube [1][0][1] - cube [1][0][0];	// y = 0\n"
"				z62 = cube [0][1][1] - cube [0][1][0];	// y = 1 \n"
"				z75 = cube [1][1][1] - cube [1][1][0];	// y = 1\n"
"				vz_y0 = (1 - dx) * z30 + dx * z41;	// y = 0\n"
"				vz_y1 = (1 - dx) * z62 + dx * z75;	// y = 1\n"
"				gradient_inter_z[atom_id] += (1 - dy) * vz_y0 + dy * vz_y1;\n"
"			}\n"
"			// -------------------------------------------------------------------\n"
"#else\n"
"			// -------------------------------------------------------------------\n"
"			// FIXME: this block within the \"#else\" preprocessor directive \n"
"			// provides NO gradient corresponding to \"dsol\" intermolecular energy\n"
"			// -------------------------------------------------------------------\n"
"\n"
"			cube [0][0][0] = GETGRIDVALUE(dockpars_fgrids,\n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y,\n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_low, y_low, x_low);\n"
"			cube [1][0][0] = GETGRIDVALUE(dockpars_fgridsu2,\n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y,\n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_low, y_low, x_high);\n"
"			cube [0][1][0] = GETGRIDVALUE(dockpars_fgrids,\n"
"						      dockpars_gridsize_x,rotbonds_unit_vectors_const\n"
"						      dockpars_gridsize_y,\n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_low, y_high, x_low);\n"
"			cube [1][1][0] = GETGRIDVALUE(dockpars_fgrids,\n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y,\n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_low, y_high, x_high);\n"
"			cube [0][0][1] = GETGRIDVALUE(dockpars_fgrids, \n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y,\n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_high, y_low, x_low);\n"
"			cube [1][0][1] = GETGRIDVALUE(dockpars_fgrids,\n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y,\n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_high, y_low, x_high);\n"
"			cube [0][1][1] = GETGRIDVALUE(dockpars_fgrids,\n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y,\n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_high, y_high, x_low);\n"
"			cube [1][1][1] = GETGRIDVALUE(dockpars_fgrids,\n"
"						      dockpars_gridsize_x,\n"
"						      dockpars_gridsize_y,\n"
"						      dockpars_gridsize_z,\n"
"						      atom_typeid, z_high, y_high, x_high);\n"
"#endif\n"
"\n"
"			//calculating desolvation energy\n"
"			partial_energies[get_local_id(0)] += fabs(q) * TRILININTERPOL(cube, weights);\n"
"		}\n"
"\n"
"	} // End atom_id for-loop (INTERMOLECULAR ENERGY)\n"
"\n"
"	// In paper: intermolecular and internal energy calculation\n"
"	// are independent from each other, -> NO BARRIER NEEDED\n"
"  	// but require different operations,\n"
"	// thus, they can be executed only sequentially on the GPU.\n"
"\n"
"	// ================================================\n"
"	// CALCULATE INTRAMOLECULAR ENERGY\n"
"	// ================================================\n"
"	for (uint contributor_counter = get_local_id(0);\n"
"	          contributor_counter < dockpars_num_of_intraE_contributors;\n"
"	          contributor_counter +=NUM_OF_THREADS_PER_BLOCK)\n"
"	{\n"
"		//getting atom IDs\n"
"		uint atom1_id = intraE_contributors_const[3*contributor_counter];\n"
"		uint atom2_id = intraE_contributors_const[3*contributor_counter+1];\n"
"\n"
"		//calculating address of first atom's coordinates\n"
"		float subx = calc_coords_x[atom1_id];\n"
"		float suby = calc_coords_y[atom1_id];\n"
"		float subz = calc_coords_z[atom1_id];\n"
"\n"
"		//calculating address of second atom's coordinates\n"
"		subx -= calc_coords_x[atom2_id];\n"
"		suby -= calc_coords_y[atom2_id];\n"
"		subz -= calc_coords_z[atom2_id];\n"
"\n"
"		//calculating distance (atomic_distance)\n"
"#if defined (NATIVE_PRECISION)\n"
"		float atomic_distance = native_sqrt(subx*subx + suby*suby + subz*subz)*dockpars_grid_spacing;\n"
"#elif defined (HALF_PRECISION)\n"
"		float atomic_distance = half_sqrt(subx*subx + suby*suby + subz*subz)*dockpars_grid_spacing;\n"
"#else	// Full precision\n"
"		float atomic_distance = sqrt(subx*subx + suby*suby + subz*subz)*dockpars_grid_spacing;\n"
"#endif\n"
"\n"
"		if (atomic_distance < 1.0f)\n"
"			atomic_distance = 1.0f;\n"
"\n"
"		//calculating energy contributions\n"
"		if ((atomic_distance < 8.0f) && (atomic_distance < 20.48f))\n"
"		{\n"
"			// Getting type IDs\n"
"			uint atom1_typeid = atom_types_const[atom1_id];\n"
"			uint atom2_typeid = atom_types_const[atom2_id];\n"
"\n"
"			//calculating van der Waals / hydrogen bond term\n"
"#if defined (NATIVE_PRECISION)\n"
"			partial_energies[get_local_id(0)] += native_divide(VWpars_AC_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],native_powr(atomic_distance,12));\n"
"#elif defined (HALF_PRECISION)\n"
"			pfor (uint rotation_counter = get_local_id(0);\n"
"	          rotation_counter < dockpars_rotbondlist_length;\n"
"	          rotation_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"	{artial_energies[get_local_id(0)] += half_divide(VWpars_AC_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],half_powr(atomic_distance,12));\n"
"#else	// Full precision\n"
"			partial_energies[get_local_id(0)] += VWpars_AC_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid]/powr(atomic_distance,12);\n"
"#endif\n"
"\n"
"			if (intraE_contributors_const[3*contributor_counter+2] == 1)	//H-bond\n"
"#if defined (NATIVE_PRECISION)\n"
"				partial_energies[get_local_id(0)] -= native_divide(VWpars_BD_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],native_powr(atomic_distance,10));\n"
"#elif defined (HALF_PRECISION)\n"
"				partial_energies[get_local_id(0)] -= half_divide(VWpars_BD_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],half_powr(atomic_distance,10));\n"
"#else	// Full precision\n"
"				partial_energies[get_local_id(0)] -= VWpars_BD_const[atom1_typeid*dockpars_num_of_atypes+atom2_typeid]/powr(atomic_distance,10);\n"
"#endif\n"
"\n"
"			else	//van der Waals\n"
"#if defined (NATIVE_PRECISION)\n"
"				partial_energies[get_local_id(0)] -= native_divide(VWpars_BD_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],native_powr(atomic_distance,6));\n"
"#elif defined (HALF_PRECISION)\n"
"				partial_energies[get_local_id(0)] -= half_divide(VWpars_BD_const[atom1_typeid * dockpars_num_of_atypes+atom2_typeid],half_powr(atomic_distance,6));\n"
"#else	// Full precision\n"
"				partial_energies[get_local_id(0)] -= VWpars_BD_const[atom1_typeid*dockpars_num_of_atypes+atom2_typeid]/powr(atomic_distance,6);\n"
"#endif\n"
"\n"
"			//calculating electrostatic term\n"
"#if defined (NATIVE_PRECISION)\n"
"        partial_energies[get_local_id(0)] += native_divide (\n"
"                                                             dockpars_coeff_elec * atom_charges_const[atom1_id] * atom_charges_const[atom2_id],\n"
"                                                             atomic_distance * (-8.5525f + native_divide(86.9525f,(1.0f + 7.7839f*native_exp(-0.3154f*atomic_distance))))\n"
"                                                             );\n"
"#elif defined (HALF_PRECISION)\n"
"        partial_energies[get_local_id(0)] += half_divide (\n"
"                                                             dockpars_coeff_elec * atom_charges_const[atom1_id] * atom_charges_const[atom2_id],\n"
"                                                             atomic_distance * (-8.5525f + half_divide(86.9525f,(1.0f + 7.7839f*half_exp(-0.3154f*atomic_distance))))\n"
"                                                             );\n"
"#else	// Full precision\n"
"				partial_energies[get_local_id(0)] += dockpars_coeff_elec*atom_charges_const[atom1_id]*atom_charges_const[atom2_id]/\n"
"			                                       (atomic_distance*(-8.5525f + 86.9525f/(1.0f + 7.7839f*exp(-0.3154f*atomic_distance))));\n"
"#endif\n"
"\n"
"			//calculating desolvation term\n"
"#if defined (NATIVE_PRECISION)\n"
"			partial_energies[get_local_id(0)] += ((dspars_S_const[atom1_typeid] +\n"
"							       dockpars_qasp*fabs(atom_charges_const[atom1_id]))*dspars_V_const[atom2_typeid] +\n"
"					                       (dspars_S_const[atom2_typeid] +\n"
"							       dockpars_qasp*fabs(atom_charges_const[atom2_id]))*dspars_V_const[atom1_typeid]) *\n"
"					                       dockpars_coeff_desolv*native_exp(-atomic_distance*native_divide(atomic_distance,25.92f));\n"
"#elif defined (HALF_PRECISION)\n"
"			partial_energies[get_local_id(0)] += ((dspars_S_const[atom1_typeid] +\n"
"							       dockpars_qasp*fabs(atom_charges_const[atom1_id]))*dspars_V_const[atom2_typeid] +\n"
"					                       (dspars_S_const[atom2_typeid] +\n"
"							       dockpars_qasp*fabs(atom_charges_const[atom2_id]))*dspars_V_const[atom1_typeid]) *\n"
"					                       dockpars_coeff_desolv*half_exp(-atomic_distance*half_divide(atomic_distance,25.92f));\n"
"#else	// Full precision\n"
"			partial_energies[get_local_id(0)] += ((dspars_S_const[atom1_typeid] +\n"
"							       dockpars_qasp*fabs(atom_charges_const[atom1_id]))*dspars_V_const[atom2_typeid] +\n"
"					                       (dspars_S_const[atom2_typeid] +\n"
"							       dockpars_qasp*fabs(atom_charges_const[atom2_id]))*dspars_V_const[atom1_typeid]) *\n"
"					                       dockpars_coeff_desolv*exp(-atomic_distance*atomic_distance/25.92f);\n"
"#endif\n"
"\n"
"		}\n"
"	} // End contributor_counter for-loop (INTRAMOLECULAR ENERGY)\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	if (get_local_id(0) == 0)\n"
"	{\n"
"		*energy = partial_energies[0];\n"
"\n"
"		for (uint contributor_counter=1;\n"
"		          contributor_counter<NUM_OF_THREADS_PER_BLOCK;\n"
"		          contributor_counter++)\n"
"		{\n"
"			*energy += partial_energies[contributor_counter];\n"
"		}\n"
"	}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"	// -------------------------------------------------------------------\n"
"	// Calculate gradients (forces) corresponding to (interE + intraE)\n"
"	// Derived from autodockdev/motions.py/forces_to_delta()\n"
"	// -------------------------------------------------------------------\n"
"	\n"
"	// Could be barrier removed if another work-item is used? \n"
"	// (e.g. get_locla_id(0) == 1)\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// FIXME: done so far only for interE\n"
"	if (get_local_id(0) == 0) {\n"
"		if (*is_enabled_gradient_calc) {\n"
"			gradient_genotype [0] = 0.0f;\n"
"			gradient_genotype [1] = 0.0f;\n"
"			gradient_genotype [2] = 0.0f;\n"
"		\n"
"			// ------------------------------------------\n"
"			// translation-related gradients\n"
"			// ------------------------------------------\n"
"			for (uint lig_atom_id = 0;\n"
"				  lig_atom_id<dockpars_num_of_atoms;\n"
"				  lig_atom_id++) {\n"
"				gradient_genotype [0] += gradient_inter_x[lig_atom_id]; // gradient for gene 0: gene x\n"
"				gradient_genotype [1] += gradient_inter_y[lig_atom_id]; // gradient for gene 1: gene y\n"
"				gradient_genotype [2] += gradient_inter_z[lig_atom_id]; // gradient for gene 2: gene z\n"
"			}\n"
"\n"
"			// ------------------------------------------\n"
"			// rotation-related gradients \n"
"			// ------------------------------------------\n"
"			float3 torque_rot = (float3)(0.0f, 0.0f, 0.0f);\n"
"\n"
"			// center of rotation \n"
"			// In getparameters.cpp, it indicates \n"
"			// translation genes are in grid spacing (instead of Angstroms)\n"
"			float about[3];\n"
"			about[0] = genotype[0]; \n"
"			about[1] = genotype[1];\n"
"			about[2] = genotype[2];\n"
"		\n"
"			// Temporal variable to calculate translation differences.\n"
"			// They are converted back to Angstroms here\n"
"			float3 r;\n"
"			\n"
"			for (uint lig_atom_id = 0;\n"
"				  lig_atom_id<dockpars_num_of_atoms;\n"
"				  lig_atom_id++) {\n"
"				r.x = (calc_coords_x[lig_atom_id] - about[0]) * dockpars_grid_spacing; \n"
"				r.y = (calc_coords_y[lig_atom_id] - about[1]) * dockpars_grid_spacing;  \n"
"				r.z = (calc_coords_z[lig_atom_id] - about[2]) * dockpars_grid_spacing; \n"
"				torque_rot += cross(r, torque_rot);\n"
"			}\n"
"\n"
"			const float rad = 1E-8;\n"
"			const float rad_div_2 = native_divide(rad, 2);\n"
"\n"
"			\n"
"			float quat_w, quat_x, quat_y, quat_z;\n"
"\n"
"			// Derived from rotation.py/axisangle_to_q()\n"
"			// genes[3:7] = rotation.axisangle_to_q(torque, rad)\n"
"			torque_rot = fast_normalize(torque_rot);\n"
"			quat_x = torque_rot.x;\n"
"			quat_y = torque_rot.y;\n"
"			quat_z = torque_rot.z;\n"
"\n"
"			// rotation-related gradients are expressed here in quaternions\n"
"			quat_w = native_cos(rad_div_2);\n"
"			quat_x = quat_x * native_sin(rad_div_2);\n"
"			quat_y = quat_y * native_sin(rad_div_2);\n"
"			quat_z = quat_z * native_sin(rad_div_2);\n"
"\n"
"			// convert quaternion gradients into Shoemake gradients \n"
"			// Derived from autodockdev/motion.py/_get_cube3_gradient\n"
"\n"
"			// where we are in cube3\n"
"			float current_u1, current_u2, current_u3;\n"
"			current_u1 = genotype[3]; // check very initial input Shoemake genes\n"
"			current_u2 = genotype[4];\n"
"			current_u3 = genotype[5];\n"
"\n"
"			// where we are in quaternion space\n"
"			// current_q = cube3_to_quaternion(current_u)\n"
"			float current_qw, current_qx, current_qy, current_qz;\n"
"			current_qw = native_sqrt(1-current_u1) * native_sin(PI_TIMES_2*current_u2);\n"
"			current_qx = native_sqrt(1-current_u1) * native_cos(PI_TIMES_2*current_u2);\n"
"			current_qy = native_sqrt(current_u1)   * native_sin(PI_TIMES_2*current_u3);\n"
"			current_qz = native_sqrt(current_u1)   * native_cos(PI_TIMES_2*current_u3);\n"
"\n"
"			// where we want to be in quaternion space\n"
"			float target_qw, target_qx, target_qy, target_qz;\n"
"\n"
"			// target_q = rotation.q_mult(q, current_q)\n"
"			// Derived from autodockdev/rotation.py/q_mult()\n"
"			// In our terms means q_mult(quat_{w|x|y|z}, current_q{w|x|y|z})\n"
"			target_qw = quat_w*current_qw - quat_x*current_qx - quat_y*current_qy - quat_z*current_qz;// w\n"
"			target_qx = quat_w*current_qx + quat_x*current_qw + quat_y*current_qz - quat_z*current_qy;// x\n"
"			target_qy = quat_w*current_qy + quat_y*current_qw + quat_z*current_qx - quat_x*current_qz;// y\n"
"			target_qz = quat_w*current_qz + quat_z*current_qw + quat_x*current_qy - quat_y*current_qx;// z\n"
"\n"
"			// where we want ot be in cube3\n"
"			float target_u1, target_u2, target_u3;\n"
"\n"
"			// target_u = quaternion_to_cube3(target_q)\n"
"			// Derived from autodockdev/motions.py/quaternion_to_cube3()\n"
"			// In our terms means quaternion_to_cube3(target_q{w|x|y|z})\n"
"			target_u1 = target_qy*target_qy + target_qz*target_qz;\n"
"			target_u2 = atan2pi(target_qw, target_qx)/PI_TIMES_2;\n"
"			target_u3 = atan2pi(target_qy, target_qz)/PI_TIMES_2;\n"
"\n"
"			// derivates in cube3\n"
"			float grad_u1, grad_u2, grad_u3;\n"
"			grad_u1 = target_u1 - current_u1;\n"
"			grad_u2 = target_u2 - current_u2;\n"
"			grad_u3 = target_u3 - current_u3;\n"
"			\n"
"			// empirical scaling\n"
"			float temp_u1 = genotype[3];\n"
"			\n"
"			if ((temp_u1 > 1.0f) || (temp_u1 < 0.0f)){\n"
"				grad_u1 *= ((1/temp_u1) + (1/(1-temp_u1)));\n"
"			}\n"
"			grad_u2 *= 4 * (1-temp_u1);\n"
"			grad_u3 *= 4 * temp_u1;\n"
"			\n"
"			// set gradient rotation-ralated genotypes in cube3\n"
"			gradient_genotype[3] = grad_u1;\n"
"			gradient_genotype[4] = grad_u2;\n"
"			gradient_genotype[5] = grad_u3;\n"
"			\n"
"			// ------------------------------------------\n"
"			// torsion-related gradients \n"
"			// ------------------------------------------\n"
"			\n"
"			// Iterate over rotations,\n"
"			// but identify those associated with rotatable bonds\n"
"			// Then iterate over rotatable bonds\n"
"			for (uint rotation_counter = 0;\n"
"			          rotation_counter < dockpars_rotbondlist_length;\n"
"			          rotation_counter ++)\n"
"			{\n"
"				int rotation_list_element = rotlist_const[rotation_counter];\n"
"\n"
"				if ((rotation_list_element & RLIST_DUMMY_MASK) == 0)	// If not dummy rotation\n"
"				{\n"
"					uint atom_id = rotation_list_element & RLIST_ATOMID_MASK;\n"
"\n"
"					if ((rotation_list_element & RLIST_GENROT_MASK) != 0)	// If general rotation\n"
"					{\n"
"\n"
"					}\n"
"					else	// If rotating around rotatable bond\n"
"					{\n"
"						uint rotbond_id = (rotation_list_element & RLIST_RBONDID_MASK) >> RLIST_RBONDID_SHIFT;\n"
"\n"
"						float3 rotation_unitvec;\n"
"						rotation_unitvec.x = rotbonds_unit_vectors_const[3*rotbond_id];\n"
"						rotation_unitvec.y = rotbonds_unit_vectors_const[3*rotbond_id+1];\n"
"						rotation_unitvec.z = rotbonds_unit_vectors_const[3*rotbond_id+2];\n"
"\n"
"						// Torque of torsions\n"
"						float3 torque_tor = (float3)(0.0f, 0.0f, 0.0f);\n"
"\n"
"						// Iterate over each ligand atom\n"
"						for (unsigned int lig_atom_id = 0;\n"
"								  lig_atom_id<dockpars_num_of_atoms;\n"
"								  lig_atom_id++) {\n"
"							// Calculate torque on point \"A\" \n"
"							// (could be any other point \"B\" along the rotation axis)\n"
"							float3 atom_coords = {calc_coords_x[lig_atom_id], \n"
"								              calc_coords_y[lig_atom_id], \n"
"								              calc_coords_z[lig_atom_id]};\n"
"\n"
"							float3 atom_force  = {gradient_inter_x[lig_atom_id],\n"
"								              gradient_inter_y[lig_atom_id],\n"
"							                      gradient_inter_z[lig_atom_id]};\n"
"\n"
"							float3 rotation_movingvec;\n"
"							rotation_movingvec.x = rotbonds_moving_vectors_const[3*rotbond_id];\n"
"							rotation_movingvec.y = rotbonds_moving_vectors_const[3*rotbond_id+1];\n"
"							rotation_movingvec.z = rotbonds_moving_vectors_const[3*rotbond_id+2];\n"
"\n"
"							torque_tor += cross((atom_coords-rotation_movingvec), atom_force);\n"
"						}\n"
"\n"
"						// Project torque on rotation axis\n"
"						float torque_on_axis = dot(rotation_unitvec, torque_tor);\n"
"\n"
"						// Assignment of gene-based gradient\n"
"						gradient_genotype[rotbond_id] = torque_on_axis;\n"
"\n"
"					} // End of general / rotatable-bond rotation\n"
"\n"
"				} // End of not dummy rotation\n"
"\n"
"			} // End of iterations over rotations\n"
"\n"
"		} // End if (*is_enabled_gradient_calc)\n"
"\n"
"	} // End gradient-calculation performed by single work-item\n"
"\n"
"}\n"
"\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gpu_calc_initpop(	char   dockpars_num_of_atoms,\n"
"			char   dockpars_num_of_atypes,\n"
"			int    dockpars_num_of_intraE_contributors,\n"
"			char   dockpars_gridsize_x,\n"
"			char   dockpars_gridsize_y,\n"
"			char   dockpars_gridsize_z,\n"
"			float  dockpars_grid_spacing,\n"
"		#if defined (RESTRICT_ARGS)\n"
"		  __global const float* restrict dockpars_fgrids, // cannot be allocated in __constant (too large)\n"
"		#else\n"
"		  __global const float* dockpars_fgrids,          // cannot be allocated in __constant (too large)\n"
"		#endif\n"
"			int    dockpars_rotbondlist_length,\n"
"			float  dockpars_coeff_elec,\n"
"			float  dockpars_coeff_desolv,\n"
"\n"
"		#if defined (RESTRICT_ARGS)\n"
"			__global const float* restrict dockpars_conformations_current,\n"
"			__global float* restrict dockpars_energies_current,\n"
"		        __global int*   restrict dockpars_evals_of_new_entities,\n"
"		#else\n"
"			__global const float* dockpars_conformations_current,\n"
"			__global float* dockpars_energies_current,\n"
"		        __global int*   dockpars_evals_of_new_entities,\n"
"		#endif\n"
"\n"
"			int    dockpars_pop_size,\n"
"			float  dockpars_qasp,\n"
"\n"
"	   __constant float* atom_charges_const,\n"
"           __constant char*  atom_types_const,\n"
"	   __constant char*  intraE_contributors_const,\n"
"           __constant float* VWpars_AC_const,\n"
"           __constant float* VWpars_BD_const,\n"
"           __constant float* dspars_S_const,\n"
"           __constant float* dspars_V_const,\n"
"           __constant int*   rotlist_const,\n"
"           __constant float* ref_coords_x_const,\n"
"           __constant float* ref_coords_y_const,\n"
"           __constant float* ref_coords_z_const,\n"
"           __constant float* rotbonds_moving_vectors_const,\n"
"           __constant float* rotbonds_unit_vectors_const,\n"
"           __constant float* ref_orientation_quats_const\n"
"){\n"
"	__local float  genotype[GENOTYPE_LENGTH_IN_GLOBMEM];\n"
"	__local float  energy;\n"
"	__local int    run_id;\n"
"\n"
"        // Some OpenCL compilers don't allow declaring \n"
"	// local variables within non-kernel functions.\n"
"	// These local variables must be declared in a kernel, \n"
"	// and then passed to non-kernel functions.\n"
"	__local float calc_coords_x[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_y[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_z[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	event_t ev = async_work_group_copy(genotype,\n"
"			                   dockpars_conformations_current + GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0),\n"
"			                   GENOTYPE_LENGTH_IN_GLOBMEM, 0);\n"
"\n"
"	wait_group_events(1,&ev);\n"
"\n"
"	//determining run ID\n"
"	if (get_local_id(0) == 0)\n"
"		run_id = get_group_id(0) / dockpars_pop_size;\n"
"\n"
"	// -------------------------------------------------------------------\n"
"	// L30nardoSV\n"
"	// Calculate gradients (forces) for intermolecular energy\n"
"	// Derived from autodockdev/maps.py\n"
"	// -------------------------------------------------------------------\n"
"	// Some OpenCL compilers don't allow declaring \n"
"	// local variables within non-kernel functions.\n"
"	// These local variables must be declared in a kernel, \n"
"	// and then passed to non-kernel functions.\n"
"\n"
"	// Disable gradient calculation for this kernel\n"
"	__local bool  is_enabled_gradient_calc;\n"
"	if (get_local_id(0) == 0) {\n"
"		is_enabled_gradient_calc = false;\n"
"	}\n"
"\n"
"	// Variables to store gradient of \n"
"	// the intermolecular energy per each ligand atom\n"
"	__local float gradient_inter_x[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_inter_y[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_inter_z[MAX_NUM_OF_ATOMS];\n"
"	\n"
"	// Final gradient resulting out of gradient calculation\n"
"	__local float gradient_genotype[GENOTYPE_LENGTH_IN_GLOBMEM];\n"
"	// -------------------------------------------------------------------\n"
"\n"
"	// =============================================================\n"
"	// WARNING: only energy of work-item=0 will be valid\n"
"	gpu_calc_energy(dockpars_rotbondlist_length,\n"
"			dockpars_num_of_atoms,\n"
"			dockpars_gridsize_x,\n"
"			dockpars_gridsize_y,\n"
"			dockpars_gridsize_z,\n"
"			dockpars_fgrids,\n"
"			dockpars_num_of_atypes,\n"
"			dockpars_num_of_intraE_contributors,\n"
"			dockpars_grid_spacing,\n"
"			dockpars_coeff_elec,\n"
"			dockpars_qasp,\n"
"			dockpars_coeff_desolv,\n"
"			genotype,\n"
"			&energy,\n"
"			&run_id,\n"
"			// Some OpenCL compilers don't allow declaring \n"
"			// local variables within non-kernel functions.\n"
"			// These local variables must be declared in a kernel, \n"
"			// and then passed to non-kernel functions.\n"
"			calc_coords_x,\n"
"			calc_coords_y,\n"
"			calc_coords_z,\n"
"			partial_energies,\n"
"\n"
"	                atom_charges_const,\n"
"		        atom_types_const,\n"
"			intraE_contributors_const,\n"
"			VWpars_AC_const,\n"
"			VWpars_BD_const,\n"
"			dspars_S_const,\n"
"			dspars_V_const,\n"
"			rotlist_const,\n"
"			ref_coords_x_const,\n"
"			ref_coords_y_const,\n"
"			ref_coords_z_const,\n"
"			rotbonds_moving_vectors_const,\n"
"			rotbonds_unit_vectors_const,\n"
"			ref_orientation_quats_const\n"
"\n"
"		 	// -------------------------------------------------------------------\n"
"		 	// L30nardoSV\n"
"		 	// Gradient-related arguments\n"
"		 	// Calculate gradients (forces) for intermolecular energy\n"
"		 	// Derived from autodockdev/maps.py\n"
"		 	// -------------------------------------------------------------------\n"
"			,\n"
"			&is_enabled_gradient_calc,\n"
"			gradient_inter_x,\n"
"			gradient_inter_y,\n"
"			gradient_inter_z,\n"
"\n"
"			gradient_genotype\n"
"			);\n"
"			// -------------------------------------------------------------------\n"
"	// =============================================================\n"
"\n"
"	if (get_local_id(0) == 0) {\n"
"		dockpars_energies_current[get_group_id(0)] = energy;\n"
"		dockpars_evals_of_new_entities[get_group_id(0)] = 1;\n"
"	}\n"
"}\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gpu_sum_evals(/*unsigned long pop_size,*/\n"
"		unsigned int pop_size,\n"
"	      /*unsigned long num_of_runs,*/\n"
"#if defined (RESTRICT_ARGS)\n"
"	      __global int* restrict dockpars_evals_of_new_entities,\n"
"              __global int* restrict evals_of_runs\n"
"#else\n"
"	      __global int* dockpars_evals_of_new_entities,\n"
"              __global int* evals_of_runs\n"
"#endif\n"
")\n"
"//The GPU global function sums the evaluation counter states\n"
"//which are stored in evals_of_new_entities array foreach entity,\n"
"//calculates the sums for each run and stores it in evals_of_runs array.\n"
"//The number of blocks which should be started equals to num_of_runs,\n"
"//since each block performs the summation for one run.\n"
"{\n"
"  int entity_counter;\n"
"  int sum_evals;\n"
"  __local int partsum_evals[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"  partsum_evals[get_local_id(0)] = 0;\n"
"\n"
"#if defined (ASYNC_COPY)\n"
"  __local int local_evals_of_new_entities[MAX_POPSIZE];	// defined in defines.h\n"
"\n"
"  async_work_group_copy(local_evals_of_new_entities,\n"
"                        dockpars_evals_of_new_entities+get_group_id(0)*pop_size,\n"
"                        pop_size,0);\n"
"\n"
"  for (entity_counter=get_local_id(0);\n"
"	     entity_counter<pop_size;\n"
"	     entity_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"       partsum_evals[get_local_id(0)] += local_evals_of_new_entities[entity_counter];\n"
"\n"
"#else\n"
"  for (entity_counter=get_local_id(0);\n"
"	     entity_counter<pop_size;\n"
"	     entity_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"       partsum_evals[get_local_id(0)] += dockpars_evals_of_new_entities[get_group_id(0)*pop_size+entity_counter];\n"
"#endif\n"
"\n"
"  barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"  if (get_local_id(0) == 0) {\n"
"    sum_evals = partsum_evals[0];\n"
"    for (entity_counter=1;\n"
"	       entity_counter<NUM_OF_THREADS_PER_BLOCK;\n"
"	       entity_counter++) {\n"
"		     sum_evals += partsum_evals[entity_counter];\n"
"    }\n"
"\n"
"    evals_of_runs[get_group_id(0)] += sum_evals;\n"
"  }\n"
"}\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"// -------------------------------------------------------\n"
"//\n"
"// -------------------------------------------------------\n"
"unsigned int gpu_rand(\n"
"			#if defined (RESTRICT_ARGS)\n"
"			__global unsigned int* restrict prng_states\n"
"			#else\n"
"			__global unsigned int* prng_states\n"
"			#endif\n"
")\n"
"//The GPU device function generates a random int\n"
"//with a linear congruential generator.\n"
"//Each thread (supposing num_of_runs*pop_size blocks and NUM_OF_THREADS_PER_BLOCK threads per block)\n"
"//has its own state which is stored in the global memory area pointed by\n"
"//prng_states (thread with ID tx in block with ID bx stores its state in prng_states[bx*NUM_OF_THREADS_PER_BLOCK+$\n"
"//The random number generator uses the gcc linear congruential generator constants.\n"
"{\n"
"  unsigned int state;\n"
"\n"
"#if defined (REPRO)\n"
"	state = 1;\n"
"#else\n"
"  //current state of the threads own PRNG\n"
"  //state = prng_states[get_group_id(0)*NUM_OF_THREADS_PER_BLOCK + get_local_id(0)];\n"
"	state = prng_states[get_global_id(0)];\n"
"\n"
"  //calculating next state\n"
"  state = (RAND_A*state+RAND_C);\n"
"#endif\n"
"  //saving next state to memory\n"
"  //prng_states[get_group_id(0)*NUM_OF_THREADS_PER_BLOCK + get_local_id(0)] = state;\n"
"	prng_states[get_global_id(0)] = state;\n"
"\n"
"  return state;\n"
"}\n"
"\n"
"// -------------------------------------------------------\n"
"//\n"
"// -------------------------------------------------------\n"
"float gpu_randf(\n"
"		#if defined (RESTRICT_ARGS)\n"
"		__global unsigned int* restrict prng_states\n"
"		#else\n"
"		__global unsigned int* prng_states\n"
"		#endif\n"
")\n"
"//The GPU device function generates a\n"
"//random float greater than (or equal to) 0 and less than 1.\n"
"//It uses gpu_rand() function.\n"
"{\n"
"  float state;\n"
"\n"
"	//state will be between 0 and 1\n"
"#if defined (REPRO)\n"
"	state = 0.55f; //0.55f;\n"
"#else\n"
"	#if defined (NATIVE_PRECISION)\n"
"	state =  native_divide(gpu_rand(prng_states),MAX_UINT)*0.999999f;\n"
"	#elif defined (HALF_PRECISION)\n"
"	state =  half_divide(gpu_rand(prng_states),MAX_UINT)*0.999999f;\n"
"	#else	// Full precision\n"
"	state = (((float) gpu_rand(prng_states))/MAX_UINT)*0.999999f;\n"
"	#endif\n"
"#endif\n"
"\n"
"  return state;\n"
"}\n"
"\n"
"// -------------------------------------------------------\n"
"//\n"
"// -------------------------------------------------------\n"
"void map_angle(__local float* angle)\n"
"//The GPU device function maps\n"
"//the input parameter to the interval 0...360\n"
"//(supposing that it is an angle).\n"
"{\n"
"  while (*angle >= 360.0f)\n"
"    *angle -= 360.0f;\n"
"\n"
"  while (*angle < 0.0f)\n"
"    *angle += 360.0f;\n"
"}\n"
"\n"
"// -------------------------------------------------------\n"
"//\n"
"// -------------------------------------------------------\n"
"void gpu_perform_elitist_selection(int    dockpars_pop_size,\n"
"\n"
"	         #if defined (RESTRICT_ARGS)\n"
"				    __global float* restrict dockpars_energies_current,\n"
"				    __global float* restrict dockpars_energies_next,\n"
"				    __global int*   restrict dockpars_evals_of_new_entities,\n"
"					#else\n"
"				    __global float* dockpars_energies_current,\n"
"				    __global float* dockpars_energies_next,\n"
"				    __global int*   dockpars_evals_of_new_entities,\n"
"					#endif\n"
"\n"
"					     int    dockpars_num_of_genes,\n"
"\n"
"					#if defined (RESTRICT_ARGS)\n"
"				    __global float* restrict dockpars_conformations_next,\n"
"		        __global const float* restrict dockpars_conformations_current\n"
"					#else\n"
"				    __global float* dockpars_conformations_next,\n"
"		        __global const float* dockpars_conformations_current\n"
"					#endif\n"
"				\n"
"					,\n"
"                    // Some OpenCL compilers don't allow local var outside kernels\n"
"                    // so this local vars are passed from a kernel\n"
"				    __local float* best_energies,\n"
"				    __local int*   best_IDs,\n"
"				    __local int*   best_ID	\n"
"\n"
"\n"
")\n"
"//The GPU device function performs elitist selection,\n"
"//that is, it looks for the best entity in conformations_current and\n"
"//energies_current of the run that corresponds to the block ID,\n"
"//and copies it to the place of the first entity in\n"
"//conformations_next and energies_next.\n"
"{\n"
"\n"
"	int entity_counter;\n"
"	int gene_counter;\n"
"	float best_energy;\n"
"\n"
"        // Some OpenCL compilers don't allow local var outside kernels\n"
"        // so this local vars are passed from a kernel\n"
"	//__local float best_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"	//__local int best_IDs[NUM_OF_THREADS_PER_BLOCK];\n"
"	//__local int best_ID;\n"
"\n"
"	if (get_local_id(0) < dockpars_pop_size)\n"
"	{\n"
"		best_energies[get_local_id(0)] = dockpars_energies_current[get_group_id(0)+get_local_id(0)];\n"
"		best_IDs[get_local_id(0)] = get_local_id(0);\n"
"	}\n"
"\n"
"	for (entity_counter=NUM_OF_THREADS_PER_BLOCK+get_local_id(0);\n"
"	     entity_counter<dockpars_pop_size;\n"
"	     entity_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"\n"
"	     if (dockpars_energies_current[get_group_id(0)+entity_counter] < best_energies[get_local_id(0)])\n"
"	     {\n"
"		best_energies[get_local_id(0)] = dockpars_energies_current[get_group_id(0)+entity_counter];\n"
"		best_IDs[get_local_id(0)] = entity_counter;\n"
"	     }\n"
"\n"
"       barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	//this could be implemented with a tree-like structure\n"
"	//which may be slightly faster\n"
"	if (get_local_id(0) == 0)\n"
"	{\n"
"		best_energy = best_energies[0];\n"
"		//best_ID = best_IDs[0];\n"
"		best_ID[0] = best_IDs[0];\n"
"\n"
"		for (entity_counter=1;\n"
"		     entity_counter<NUM_OF_THREADS_PER_BLOCK;\n"
"		     entity_counter++)\n"
"\n"
"		     if ((best_energies[entity_counter] < best_energy) && (entity_counter < dockpars_pop_size))\n"
"		     {\n"
"			      best_energy = best_energies[entity_counter];\n"
"			      //best_ID = best_IDs[entity_counter];\n"
"			      best_ID[0] = best_IDs[entity_counter];\n"
"		     }\n"
"\n"
"		//setting energy value of new entity\n"
"		dockpars_energies_next[get_group_id(0)] = best_energy;\n"
"\n"
"		//0 evals were performed for entity selected with elitism (since it was copied only)\n"
"		dockpars_evals_of_new_entities[get_group_id(0)] = 0;\n"
"	}\n"
"\n"
"	//now best_id stores the id of the best entity in the population,\n"
"	//copying genotype and energy value to the first entity of new population\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	for (gene_counter=get_local_id(0);\n"
"	     gene_counter<dockpars_num_of_genes;\n"
"	     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"	     //dockpars_conformations_next[GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0)+gene_counter] = dockpars_conformations_current[GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0)+GENOTYPE_LENGTH_IN_GLOBMEM*best_ID+gene_counter];\n"
"	     dockpars_conformations_next[GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0)+gene_counter] = dockpars_conformations_current[GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0)+GENOTYPE_LENGTH_IN_GLOBMEM*best_ID[0]+gene_counter];\n"
"}\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"perform_LS(	char   dockpars_num_of_atoms,\n"
"		char   dockpars_num_of_atypes,\n"
"		int    dockpars_num_of_intraE_contributors,\n"
"		char   dockpars_gridsize_x,\n"
"		char   dockpars_gridsize_y,\n"
"		char   dockpars_gridsize_z,\n"
"		float  dockpars_grid_spacing,\n"
"\n"
"		#if defined (RESTRICT_ARGS)\n"
"  __global const float* restrict dockpars_fgrids, // cannot be allocated in __constant (too large)\n"
"		#else\n"
"  __global const float* dockpars_fgrids,          // cannot be allocated in __constant (too large)\n"
"		#endif\n"
"\n"
"	        int    dockpars_rotbondlist_length,\n"
"		float  dockpars_coeff_elec,\n"
"		float  dockpars_coeff_desolv,\n"
"\n"
"		#if defined (RESTRICT_ARGS)\n"
"  __global float* restrict dockpars_conformations_next,\n"
"  __global float* restrict dockpars_energies_next,\n"
"  __global int*   restrict dockpars_evals_of_new_entities,\n"
"  __global unsigned int* restrict dockpars_prng_states,\n"
"		#else\n"
"  __global float* dockpars_conformations_next,\n"
"  __global float* dockpars_energies_next,\n"
"  __global int*   dockpars_evals_of_new_entities,\n"
"  __global unsigned int* dockpars_prng_states,\n"
"		#endif\n"
"\n"
"		int    dockpars_pop_size,\n"
"		int    dockpars_num_of_genes,\n"
"		float  dockpars_lsearch_rate,\n"
"		unsigned int dockpars_num_of_lsentities,\n"
"		float  dockpars_rho_lower_bound,\n"
"		float  dockpars_base_dmov_mul_sqrt3,\n"
"		float  dockpars_base_dang_mul_sqrt3,\n"
"		unsigned int dockpars_cons_limit,\n"
"		unsigned int dockpars_max_num_of_iters,\n"
"		float  dockpars_qasp,\n"
"\n"
"	  __constant float* atom_charges_const,\n"
"          __constant char*  atom_types_const,\n"
"	  __constant char*  intraE_contributors_const,\n"
"          __constant float* VWpars_AC_const,\n"
"          __constant float* VWpars_BD_const,\n"
"          __constant float* dspars_S_const,\n"
"          __constant float* dspars_V_const,\n"
"          __constant int*   rotlist_const,\n"
"          __constant float* ref_coords_x_const,\n"
"          __constant float* ref_coords_y_const,\n"
"          __constant float* ref_coords_z_const,\n"
"          __constant float* rotbonds_moving_vectors_const,\n"
"          __constant float* rotbonds_unit_vectors_const,\n"
"          __constant float* ref_orientation_quats_const\n"
")\n"
"//The GPU global function performs local search on the pre-defined entities of conformations_next.\n"
"//The number of blocks which should be started equals to num_of_lsentities*num_of_runs.\n"
"//This way the first num_of_lsentities entity of each population will be subjected to local search\n"
"//(and each block carries out the algorithm for one entity).\n"
"//Since the first entity is always the best one in the current population,\n"
"//it is always tested according to the ls probability, and if it not to be\n"
"//subjected to local search, the entity with ID num_of_lsentities is selected instead of the first one (with ID 0).\n"
"{\n"
"	__local float genotype_candidate[ACTUAL_GENOTYPE_LENGTH];\n"
"	__local float genotype_deviate  [ACTUAL_GENOTYPE_LENGTH];\n"
"	__local float genotype_bias     [ACTUAL_GENOTYPE_LENGTH];\n"
"        __local float rho;\n"
"	__local int   cons_succ;\n"
"	__local int   cons_fail;\n"
"	__local int   iteration_cnt;\n"
"	__local float candidate_energy;\n"
"	__local int   evaluation_cnt;\n"
"	int gene_counter;\n"
"\n"
"	__local float offspring_genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"	__local int run_id;\n"
"	__local int entity_id;\n"
"	__local float offspring_energy;\n"
"\n"
"	// Some OpenCL compilers don't allow declaring \n"
"	// local variables within non-kernel functions.\n"
"	// These local variables must be declared in a kernel, \n"
"	// and then passed to non-kernel functions.\n"
"	__local float calc_coords_x[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_y[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_z[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	// -------------------------------------------------------------------\n"
"	// L30nardoSV\n"
"	// Calculate gradients (forces) for intermolecular energy\n"
"	// Derived from autodockdev/maps.py\n"
"	// -------------------------------------------------------------------\n"
"	// Some OpenCL compilers don't allow declaring \n"
"	// local variables within non-kernel functions.\n"
"	// These local variables must be declared in a kernel, \n"
"	// and then passed to non-kernel functions.\n"
"\n"
"	// Disable gradient calculation for this kernel\n"
"	__local bool  is_enabled_gradient_calc;\n"
"	if (get_local_id(0) == 0) {\n"
"		is_enabled_gradient_calc = false;\n"
"	}\n"
"\n"
"	// Variables to store gradient of \n"
"	// the intermolecular energy per each ligand atom\n"
"	__local float gradient_inter_x[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_inter_y[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_inter_z[MAX_NUM_OF_ATOMS];\n"
"\n"
"	// Final gradient resulting out of gradient calculation\n"
"	__local float gradient_genotype[GENOTYPE_LENGTH_IN_GLOBMEM];\n"
"	// -------------------------------------------------------------------\n"
"\n"
"	//determining run ID and entity ID, initializing\n"
"	if (get_local_id(0) == 0)\n"
"	{\n"
"		run_id = get_group_id(0) / dockpars_num_of_lsentities;\n"
"		entity_id = get_group_id(0) % dockpars_num_of_lsentities;\n"
"\n"
"		//since entity 0 is the best one due to elitism, should be subjected to random selection\n"
"		if (entity_id == 0)\n"
"			if (100.0f*gpu_randf(dockpars_prng_states) > dockpars_lsearch_rate)\n"
"				entity_id = dockpars_num_of_lsentities;	//if entity 0 is not selected according to LS rate,\n"
"									//choosing an other entity\n"
"\n"
"		offspring_energy = dockpars_energies_next[run_id*dockpars_pop_size+entity_id];\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"#if defined (ASYNC_COPY)\n"
"  async_work_group_copy(offspring_genotype,\n"
"			dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"                        dockpars_num_of_genes,0);\n"
"#else\n"
"	for (gene_counter=get_local_id(0);\n"
"	     gene_counter<dockpars_num_of_genes;\n"
"	     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"		   offspring_genotype[gene_counter] = dockpars_conformations_next[(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"#endif\n"
"\n"
"	for (gene_counter=get_local_id(0);\n"
"	     gene_counter<dockpars_num_of_genes;\n"
"	     gene_counter += NUM_OF_THREADS_PER_BLOCK)\n"
"		   genotype_bias[gene_counter] = 0.0f;\n"
"\n"
"	if (get_local_id(0) == 0) {\n"
"		rho = 1.0f;\n"
"		cons_succ = 0;\n"
"		cons_fail = 0;\n"
"		iteration_cnt = 0;\n"
"		evaluation_cnt = 0;\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	while ((iteration_cnt < dockpars_max_num_of_iters) && (rho > dockpars_rho_lower_bound))\n"
"	{\n"
"		//new random deviate\n"
"		for (gene_counter=get_local_id(0);\n"
"		     gene_counter<dockpars_num_of_genes;\n"
"		     gene_counter += NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			genotype_deviate[gene_counter] = rho*(2*gpu_randf(dockpars_prng_states)-1);\n"
"\n"
"// -------------------------------------------------------------------\n"
"// L30nardoSV\n"
"// Replacing rotation genes: from spherical space to Shoemake space\n"
"// gene [0:2]: translation -> kept as original x, y, z\n"
"// gene [3:5]: rotation    -> transformed into Shoemake (u1: adimensional, u2&u3: sexagesimal)\n"
"// gene [6:N]: torsions	   -> kept as original angles	(all in sexagesimal)\n"
"\n"
"// Shoemake ranges:\n"
"// u1: [0, 1]\n"
"// u2: [0: 2PI] or [0: 360]\n"
"\n"
"// Random generator in the host is changed:\n"
"// LCG (original, myrand()) -> CPP std (rand())\n"
"// -------------------------------------------------------------------\n"
"\n"
"// Original code is commented out\n"
"/*\n"
"			if (gene_counter < 3)\n"
"				genotype_deviate[gene_counter] *= dockpars_base_dmov_mul_sqrt3;\n"
"			else\n"
"				genotype_deviate[gene_counter] *= dockpars_base_dang_mul_sqrt3;\n"
"*/\n"
"\n"
"			if (gene_counter < 3)\n"
"				genotype_deviate[gene_counter] *= dockpars_base_dmov_mul_sqrt3;\n"
"\n"
"/*\n"
"			else if (gene_counter == 3) // u1, FIXME: hardcoded\n"
"				genotype_deviate[gene_counter] *=  0.2f;\n"
"			else if (gene_counter < 6) // u2&u3, FIXME: harcoded\n"
"				genotype_deviate[gene_counter] *= 90.0f;\n"
"*/\n"
"			else if (gene_counter > 5) \n"
"				genotype_deviate[gene_counter] *= dockpars_base_dang_mul_sqrt3;\n"
"\n"
"		}\n"
"\n"
"		//generating new genotype candidate\n"
"		for (gene_counter=get_local_id(0);\n"
"		     gene_counter<dockpars_num_of_genes;\n"
"		     gene_counter += NUM_OF_THREADS_PER_BLOCK) {\n"
"			if ((gene_counter > 2) && (gene_counter < 6)) { // Shoemake genes: u1, u2, u3\n"
"			   genotype_candidate[gene_counter] = gpu_randf(dockpars_prng_states);\n"
"			}\n"
"			else {\n"
"			   genotype_candidate[gene_counter] = offspring_genotype[gene_counter] + genotype_deviate[gene_counter] + genotype_bias[gene_counter];\n"
"			}\n"
"/*\n"
"			   genotype_candidate[gene_counter] = offspring_genotype[gene_counter] + genotype_deviate[gene_counter] + genotype_bias[gene_counter];\n"
"\n"
"			if (gene_counter == 3) {// u1, FIXME: hardcoded\n"
"				if (genotype_candidate[gene_counter] > 1.0f) { // clamp it\n"
"					offspring_genotype[gene_counter] = 0.9f;\n"
"				}\n"
"				if (genotype_candidate[gene_counter] < 0.0f) { // clamp it\n"
"					offspring_genotype[gene_counter] = 0.1f;\n"
"				}\n"
"				//printf(\"LS positive - genotype_candidate[gene_counter]: %f\\n\", genotype_candidate[gene_counter]);\n"
"			}\n"
"*/\n"
"\n"
"		}\n"
"\n"
"\n"
"		//evaluating candidate\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// ==================================================================\n"
"		gpu_calc_energy(dockpars_rotbondlist_length,\n"
"				dockpars_num_of_atoms,\n"
"				dockpars_gridsize_x,\n"
"				dockpars_gridsize_y,\n"
"				dockpars_gridsize_z,\n"
"				dockpars_fgrids,\n"
"				dockpars_num_of_atypes,\n"
"				dockpars_num_of_intraE_contributors,\n"
"				dockpars_grid_spacing,\n"
"				dockpars_coeff_elec,\n"
"				dockpars_qasp,\n"
"				dockpars_coeff_desolv,\n"
"				genotype_candidate,\n"
"				&candidate_energy,\n"
"				&run_id,\n"
"				// Some OpenCL compilers don't allow declaring \n"
"				// local variables within non-kernel functions.\n"
"				// These local variables must be declared in a kernel, \n"
"				// and then passed to non-kernel functions.\n"
"				calc_coords_x,\n"
"				calc_coords_y,\n"
"				calc_coords_z,\n"
"				partial_energies,\n"
"\n"
"				atom_charges_const,\n"
"				atom_types_const,\n"
"				intraE_contributors_const,\n"
"				VWpars_AC_const,\n"
"				VWpars_BD_const,\n"
"				dspars_S_const,\n"
"				dspars_V_const,\n"
"				rotlist_const,\n"
"				ref_coords_x_const,\n"
"				ref_coords_y_const,\n"
"				ref_coords_z_const,\n"
"				rotbonds_moving_vectors_const,\n"
"				rotbonds_unit_vectors_const,\n"
"				ref_orientation_quats_const\n"
"\n"
"			 	// -------------------------------------------------------------------\n"
"			 	// L30nardoSV\n"
"			 	// Gradient-related arguments\n"
"			 	// Calculate gradients (forces) for intermolecular energy\n"
"			 	// Derived from autodockdev/maps.py\n"
"			 	// -------------------------------------------------------------------\n"
"				,\n"
"				&is_enabled_gradient_calc,\n"
"				gradient_inter_x,\n"
"				gradient_inter_y,\n"
"				gradient_inter_z,\n"
"\n"
"				gradient_genotype\n"
"				);\n"
"				// -------------------------------------------------------------------\n"
"		// =================================================================\n"
"\n"
"		if (get_local_id(0) == 0)\n"
"			evaluation_cnt++;\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (candidate_energy < offspring_energy)	//if candidate is better, success\n"
"		{\n"
"			for (gene_counter=get_local_id(0);\n"
"			     gene_counter<dockpars_num_of_genes;\n"
"			     gene_counter += NUM_OF_THREADS_PER_BLOCK)\n"
"			{\n"
"				//updating offspring_genotype\n"
"				offspring_genotype[gene_counter] = genotype_candidate[gene_counter];\n"
"\n"
"				//updating genotype_bias\n"
"				genotype_bias[gene_counter] = 0.6f*genotype_bias[gene_counter] + 0.4f*genotype_deviate[gene_counter];\n"
"			}\n"
"\n"
"			//thread 0 will overwrite the shared variables\n"
"			//used in the previous if condition,\n"
"			//all threads have to be after if\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			if (get_local_id(0) == 0)\n"
"			{\n"
"				offspring_energy = candidate_energy;\n"
"				cons_succ++;\n"
"				cons_fail = 0;\n"
"			}\n"
"		}\n"
"		else	//if candidate is worser, check the opposite direction\n"
"		{\n"
"			//generating the other genotype candidate\n"
"			for (gene_counter=get_local_id(0);\n"
"			     gene_counter<dockpars_num_of_genes;\n"
"			     gene_counter += NUM_OF_THREADS_PER_BLOCK) {\n"
"\n"
"				if ((gene_counter > 2) && (gene_counter < 6)) { // Shoemake genes: u1, u2, u3\n"
"				   genotype_candidate[gene_counter] =  gpu_randf(dockpars_prng_states);\n"
"				}\n"
"				else {\n"
"				   genotype_candidate[gene_counter] = offspring_genotype[gene_counter] - genotype_deviate[gene_counter] - genotype_bias[gene_counter];\n"
"				}\n"
"\n"
"/*\n"
"				   genotype_candidate[gene_counter] = offspring_genotype[gene_counter] - genotype_deviate[gene_counter] - genotype_bias[gene_counter];\n"
"\n"
"\n"
"				if (gene_counter == 3) {// u1, FIXME: hardcoded\n"
"					if (genotype_candidate[gene_counter] > 1.0f) { // clamp it\n"
"						offspring_genotype[gene_counter] = 0.9f;\n"
"					}\n"
"					if (genotype_candidate[gene_counter] < 0.0f) { // clamp it\n"
"						offspring_genotype[gene_counter] = 0.1f;\n"
"					}\n"
"					//printf(\"LS negative - genotype_candidate[gene_counter]: %f\\n\", genotype_candidate[gene_counter]);\n"
"				}\n"
"*/\n"
"\n"
"			}\n"
"\n"
"			//evaluating candidate\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			// =================================================================\n"
"			gpu_calc_energy(dockpars_rotbondlist_length,\n"
"					dockpars_num_of_atoms,\n"
"					dockpars_gridsize_x,\n"
"					dockpars_gridsize_y,\n"
"					dockpars_gridsize_z,\n"
"					dockpars_fgrids,\n"
"					dockpars_num_of_atypes,\n"
"					dockpars_num_of_intraE_contributors,\n"
"					dockpars_grid_spacing,\n"
"					dockpars_coeff_elec,\n"
"				        dockpars_qasp,\n"
"					dockpars_coeff_desolv,\n"
"					genotype_candidate,\n"
"					&candidate_energy,\n"
"					&run_id,\n"
"					// Some OpenCL compilers don't allow declaring \n"
"					// local variables within non-kernel functions.\n"
"					// These local variables must be declared in a kernel, \n"
"					// and then passed to non-kernel functions.\n"
"					calc_coords_x,\n"
"					calc_coords_y,\n"
"					calc_coords_z,\n"
"					partial_energies,\n"
"\n"
"					atom_charges_const,\n"
"					atom_types_const,\n"
"					intraE_contributors_const,\n"
"					VWpars_AC_const,\n"
"					VWpars_BD_const,\n"
"					dspars_S_const,\n"
"					dspars_V_const,\n"
"					rotlist_const,\n"
"					ref_coords_x_const,\n"
"					ref_coords_y_const,\n"
"					ref_coords_z_const,\n"
"					rotbonds_moving_vectors_const,\n"
"					rotbonds_unit_vectors_const,\n"
"					ref_orientation_quats_const\n"
"\n"
"				 	// -------------------------------------------------------------------\n"
"				 	// L30nardoSV\n"
"				 	// Gradient-related arguments\n"
"				 	// Calculate gradients (forces) for intermolecular energy\n"
"				 	// Derived from autodockdev/maps.py\n"
"				 	// -------------------------------------------------------------------\n"
"					,\n"
"					&is_enabled_gradient_calc,\n"
"					gradient_inter_x,\n"
"					gradient_inter_y,\n"
"					gradient_inter_z,\n"
"\n"
"					gradient_genotype\n"
"					);\n"
"					// -------------------------------------------------------------------\n"
"			// =================================================================\n"
"\n"
"			if (get_local_id(0) == 0)\n"
"				evaluation_cnt++;\n"
"\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			if (candidate_energy < offspring_energy)//if candidate is better, success\n"
"			{\n"
"				for (gene_counter=get_local_id(0);\n"
"				     gene_counter<dockpars_num_of_genes;\n"
"			       gene_counter += NUM_OF_THREADS_PER_BLOCK)\n"
"				{\n"
"					//updating offspring_genotype\n"
"					offspring_genotype[gene_counter] = genotype_candidate[gene_counter];\n"
"\n"
"					//updating genotype_bias\n"
"					genotype_bias[gene_counter] = 0.6f*genotype_bias[gene_counter] - 0.4f*genotype_deviate[gene_counter];\n"
"				}\n"
"\n"
"				//thread 0 will overwrite the shared variables\n"
"				//used in the previous if condition,\n"
"				//all threads have to be after if\n"
"				barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"				if (get_local_id(0) == 0)\n"
"				{\n"
"					offspring_energy = candidate_energy;\n"
"					cons_succ++;\n"
"					cons_fail = 0;\n"
"				}\n"
"			}\n"
"			else	//failure in both directions\n"
"			{\n"
"				for (gene_counter=get_local_id(0);\n"
"				     gene_counter<dockpars_num_of_genes;\n"
"				     gene_counter += NUM_OF_THREADS_PER_BLOCK)\n"
"					   //updating genotype_bias\n"
"					   genotype_bias[gene_counter] = 0.5f*genotype_bias[gene_counter];\n"
"\n"
"				if (get_local_id(0) == 0)\n"
"				{\n"
"					cons_succ = 0;\n"
"					cons_fail++;\n"
"				}\n"
"			}\n"
"		}\n"
"\n"
"		//changing rho if needed\n"
"		if (get_local_id(0) == 0)\n"
"		{\n"
"			iteration_cnt++;\n"
"\n"
"			if (cons_succ >= dockpars_cons_limit)\n"
"			{\n"
"				rho *= LS_EXP_FACTOR;\n"
"				cons_succ = 0;\n"
"			}\n"
"			else\n"
"				if (cons_fail >= dockpars_cons_limit)\n"
"				{\n"
"					rho *= LS_CONT_FACTOR;\n"
"					cons_fail = 0;\n"
"				}\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"	}\n"
"\n"
"	//updating eval counter and energy\n"
"	if (get_local_id(0) == 0)\n"
"	{\n"
"		dockpars_evals_of_new_entities[run_id*dockpars_pop_size+entity_id] += evaluation_cnt;\n"
"		dockpars_energies_next[run_id*dockpars_pop_size+entity_id] = offspring_energy;\n"
"	}\n"
"\n"
"	//mapping angles\n"
"// -------------------------------------------------------------------\n"
"// L30nardoSV\n"
"// Replacing rotation genes: from spherical space to Shoemake space\n"
"// gene [0:2]: translation -> kept as original x, y, z\n"
"// gene [3:5]: rotation    -> transformed into Shoemake (u1: adimensional, u2&u3: sexagesimal)\n"
"// gene [6:N]: torsions	   -> kept as original angles	(all in sexagesimal)\n"
"\n"
"// Shoemake ranges:\n"
"// u1: [0, 1]\n"
"// u2: [0: 2PI] or [0: 360]\n"
"\n"
"// Random generator in the host is changed:\n"
"// LCG (original, myrand()) -> CPP std (rand())\n"
"// -------------------------------------------------------------------\n"
"/*\n"
"	for (gene_counter=get_local_id(0);\n"
"	     gene_counter<dockpars_num_of_genes;\n"
"	     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"		   if (gene_counter >=  3)\n"
"			    map_angle(&(offspring_genotype[gene_counter]));\n"
"*/\n"
"	for (gene_counter=get_local_id(0);\n"
"	     gene_counter<dockpars_num_of_genes;\n"
"	     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"		   if (gene_counter >=  4)\n"
"			    map_angle(&(offspring_genotype[gene_counter]));\n"
"\n"
"\n"
"	//updating old offspring in population\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"#if defined (ASYNC_COPY)\n"
"  async_work_group_copy(dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"                        offspring_genotype,\n"
"                        dockpars_num_of_genes,0);\n"
"#else\n"
"	for (gene_counter=get_local_id(0);\n"
"	     gene_counter<dockpars_num_of_genes;\n"
"       gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"		   dockpars_conformations_next[(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter] = offspring_genotype[gene_counter];\n"
"#endif\n"
"}\n"
"/*\n"
"\n"
"OCLADock, an OpenCL implementation of AutoDock 4.2 running a Lamarckian Genetic Algorithm\n"
"Copyright (C) 2017 TU Darmstadt, Embedded Systems and Applications Group, Germany. All rights reserved.\n"
"\n"
"AutoDock is a Trade Mark of the Scripps Research Institute.\n"
"\n"
"This program is free software; you can redistribute it and/or\n"
"modify it under the terms of the GNU General Public License\n"
"as published by the Free Software Foundation; either version 2\n"
"of the License, or (at your option) any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software\n"
"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"
"\n"
"*/\n"
"\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gpu_gen_and_eval_newpops(char   dockpars_num_of_atoms,\n"
"			 char   dockpars_num_of_atypes,\n"
"			 int    dockpars_num_of_intraE_contributors,\n"
"			 char   dockpars_gridsize_x,\n"
"			 char   dockpars_gridsize_y,\n"
"			 char   dockpars_gridsize_z,\n"
"			 float  dockpars_grid_spacing,\n"
"\n"
"			#if defined (RESTRICT_ARGS)\n"
" __global const float* restrict dockpars_fgrids, // cannot be allocated in __constant (too large)\n"
"			#else\n"
" __global const float* dockpars_fgrids, // cannot be allocated in __constant (too large)\n"
"			#endif\n"
"\n"
"	                int    dockpars_rotbondlist_length,\n"
"			float  dockpars_coeff_elec,\n"
"			float  dockpars_coeff_desolv,\n"
"\n"
"			#if defined (RESTRICT_ARGS)\n"
" __global const float* restrict  dockpars_conformations_current,\n"
" __global float* restrict  dockpars_energies_current,\n"
" __global float* restrict  dockpars_conformations_next,\n"
" __global float* restrict  dockpars_energies_next,\n"
" __global int*   restrict  dockpars_evals_of_new_entities,\n"
" __global unsigned int* restrict dockpars_prng_states,\n"
"			#else\n"
" __global const float*  dockpars_conformations_current,\n"
" __global float*        dockpars_energies_current,\n"
" __global float*        dockpars_conformations_next,\n"
" __global float*        dockpars_energies_next,\n"
" __global int*          dockpars_evals_of_new_entities,\n"
" __global unsigned int* dockpars_prng_states,\n"
"			#endif\n"
"\n"
"	                int    dockpars_pop_size,\n"
"	                int    dockpars_num_of_genes,\n"
"		        float  dockpars_tournament_rate,\n"
"	                float  dockpars_crossover_rate,\n"
"		        float  dockpars_mutation_rate,\n"
"		        float  dockpars_abs_max_dmov,\n"
"		        float  dockpars_abs_max_dang,\n"
"		        float  dockpars_qasp,\n"
"\n"
"	      __constant float* atom_charges_const,\n"
"              __constant char*  atom_types_const,\n"
"	      __constant char*  intraE_contributors_const,\n"
"              __constant float* VWpars_AC_const,\n"
"              __constant float* VWpars_BD_const,\n"
"              __constant float* dspars_S_const,\n"
"              __constant float* dspars_V_const,\n"
"              __constant int*   rotlist_const,\n"
"              __constant float* ref_coords_x_const,\n"
"              __constant float* ref_coords_y_const,\n"
"              __constant float* ref_coords_z_const,\n"
"              __constant float* rotbonds_moving_vectors_const,\n"
"              __constant float* rotbonds_unit_vectors_const,\n"
"              __constant float* ref_orientation_quats_const\n"
")\n"
"//The GPU global function\n"
"{\n"
"	__local float offspring_genotype[ACTUAL_GENOTYPE_LENGTH];\n"
"	__local int parent_candidates[4];\n"
"	__local float candidate_energies[4];\n"
"	__local int parents[2];\n"
"	__local int run_id;\n"
"	__local int covr_point[2];\n"
"	__local float randnums[10];\n"
"	int temp_covr_point;\n"
"	int gene_counter;\n"
"	__local float energy;	//could be shared since only thread 0 will use it\n"
"\n"
"\n"
"	// Some OpenCL compilers don't allow declaring \n"
"	// local variables within non-kernel functions.\n"
"	// These local variables must be declared in a kernel, \n"
"	// and then passed to non-kernel functions.\n"
"	__local float best_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"	__local int best_IDs[NUM_OF_THREADS_PER_BLOCK];\n"
"        __local int best_ID[1]; //__local int best_ID;\n"
"\n"
"	__local float calc_coords_x[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_y[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_z[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	// -------------------------------------------------------------------\n"
"	// L30nardoSV\n"
"	// Calculate gradients (forces) for intermolecular energy\n"
"	// Derived from autodockdev/maps.py\n"
"	// -------------------------------------------------------------------\n"
"	// Some OpenCL compilers don't allow declaring \n"
"	// local variables within non-kernel functions.\n"
"	// These local variables must be declared in a kernel, \n"
"	// and then passed to non-kernel functions.\n"
"\n"
"	// Disable gradient calculation for this kernel\n"
"	__local bool  is_enabled_gradient_calc;\n"
"	if (get_local_id(0) == 0) {\n"
"		is_enabled_gradient_calc = false;\n"
"	}\n"
"\n"
"	// Variables to store gradient of \n"
"	// the intermolecular energy per each ligand atom\n"
"	__local float gradient_inter_x[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_inter_y[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_inter_z[MAX_NUM_OF_ATOMS];\n"
"\n"
"	// Final gradient resulting out of gradient calculation\n"
"	__local float gradient_genotype[GENOTYPE_LENGTH_IN_GLOBMEM];\n"
"	// -------------------------------------------------------------------\n"
"\n"
"	//in this case this block is responsible for elitist selection\n"
"	if ((get_group_id(0) % dockpars_pop_size) == 0)\n"
"		gpu_perform_elitist_selection(dockpars_pop_size,\n"
"					      dockpars_energies_current,\n"
"					      dockpars_energies_next,\n"
"					      dockpars_evals_of_new_entities,\n"
"					      dockpars_num_of_genes,\n"
"					      dockpars_conformations_next,\n"
"				              dockpars_conformations_current\n"
"					      ,\n"
"					      best_energies,\n"
"					      best_IDs,\n"
"					      best_ID);\n"
"	else\n"
"	{\n"
"		//generating the following random numbers: \n"
"		//[0..3] for parent candidates,\n"
"		//[4..5] for binary tournaments, [6] for deciding crossover,\n"
"		//[7..8] for crossover points, [9] for local search\n"
"\n"
"		for (gene_counter=get_local_id(0);\n"
"		     gene_counter<10;\n"
"		     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"			   randnums[gene_counter] = gpu_randf(dockpars_prng_states);\n"
"\n"
"		//determining run ID\n"
"		if (get_local_id(0) == 0)\n"
"			run_id = get_group_id(0) / dockpars_pop_size;\n"
"\n"
"		//performing binary tournament selection\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (get_local_id(0) < 4)	//it is not ensured that the four candidates will be different...\n"
"		{\n"
"			parent_candidates[get_local_id(0)] = (int) (dockpars_pop_size*randnums[get_local_id(0)]); //using randnums[0..3]\n"
"			candidate_energies[get_local_id(0)] = dockpars_energies_current[run_id*dockpars_pop_size+parent_candidates[get_local_id(0)]];\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (get_local_id(0) < 2)\n"
"		{\n"
"			if (candidate_energies[2*get_local_id(0)] < candidate_energies[2*get_local_id(0)+1])\n"
"				if (100.0f*randnums[4+get_local_id(0)] < dockpars_tournament_rate)		//using randnum[4..5]\n"
"					parents[get_local_id(0)] = parent_candidates[2*get_local_id(0)];\n"
"				else\n"
"					parents[get_local_id(0)] = parent_candidates[2*get_local_id(0)+1];\n"
"			else\n"
"				if (100.0f*randnums[4+get_local_id(0)] < dockpars_tournament_rate)\n"
"					parents[get_local_id(0)] = parent_candidates[2*get_local_id(0)+1];\n"
"				else\n"
"					parents[get_local_id(0)] = parent_candidates[2*get_local_id(0)];\n"
"		}\n"
"\n"
"		//performing crossover\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		if (100.0f*randnums[6] < dockpars_crossover_rate)	//using randnums[6]\n"
"		{\n"
"			if (get_local_id(0) < 2)\n"
"				//using randnum[7..8]\n"
"				covr_point[get_local_id(0)] = (int) ((dockpars_num_of_genes-1)*randnums[7+get_local_id(0)]);\n"
"\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"			if (get_local_id(0) == 0)	//covr_point[0] should store the lower crossover-point\n"
"				if (covr_point[1] < covr_point[0])\n"
"				{\n"
"					temp_covr_point = covr_point[1];\n"
"					covr_point[1] = covr_point[0];\n"
"					covr_point[0] = temp_covr_point;\n"
"				}\n"
"\n"
"			barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"			for (gene_counter=get_local_id(0);\n"
"			     gene_counter<dockpars_num_of_genes;\n"
"			     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"			{\n"
"				if (covr_point[0] != covr_point[1])	//two-point crossover\n"
"					if ((gene_counter <= covr_point[0]) || (gene_counter > covr_point[1]))\n"
"						offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[0])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"					else\n"
"						offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[1])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"				else									             //single-point crossover\n"
"					if (gene_counter <= covr_point[0])\n"
"						offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[0])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"					else\n"
"						offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[1])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"			}\n"
"\n"
"		}\n"
"		else	//no crossover\n"
"		{\n"
"#if defined (ASYNC_COPY)\n"
"			async_work_group_copy(offspring_genotype,\n"
"					     dockpars_conformations_current+(run_id*dockpars_pop_size+parents[0])*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"					     dockpars_num_of_genes,0);\n"
"\n"
"#else\n"
"			for (gene_counter=get_local_id(0);\n"
"			     gene_counter<dockpars_num_of_genes;\n"
"			     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"				   offspring_genotype[gene_counter] = dockpars_conformations_current[(run_id*dockpars_pop_size+parents[0])*GENOTYPE_LENGTH_IN_GLOBMEM+gene_counter];\n"
"#endif\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		//performing mutation\n"
"		for (gene_counter=get_local_id(0);\n"
"		     gene_counter<dockpars_num_of_genes;\n"
"		     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"		{\n"
"			if (100.0f*gpu_randf(dockpars_prng_states) < dockpars_mutation_rate)\n"
"			{\n"
"// -------------------------------------------------------------------\n"
"// L30nardoSV\n"
"// Replacing rotation genes: from spherical space to Shoemake space\n"
"// gene [0:2]: translation -> kept as original x, y, z\n"
"// gene [3:5]: rotation    -> transformed into Shoemake (u1: adimensional, u2&u3: sexagesimal)\n"
"// gene [6:N]: torsions	   -> kept as original angles	(all in sexagesimal)\n"
"\n"
"// Shoemake ranges:\n"
"// u1: [0, 1]\n"
"// u2: [0: 2PI] or [0: 360]\n"
"\n"
"// Random generator in the host is changed:\n"
"// LCG (original, myrand()) -> CPP std (rand())\n"
"// -------------------------------------------------------------------\n"
"\n"
"// Original code commented out\n"
"/*\n"
"				if (gene_counter < 3)\n"
"					offspring_genotype[gene_counter] += dockpars_abs_max_dmov*(2*gpu_randf(dockpars_prng_states)-1);\n"
"				else\n"
"				{\n"
"					offspring_genotype[gene_counter] += dockpars_abs_max_dang*(2*gpu_randf(dockpars_prng_states)-1);\n"
"					map_angle(&(offspring_genotype[gene_counter]));\n"
"				}\n"
"*/\n"
"\n"
"				if (gene_counter < 3)\n"
"					offspring_genotype[gene_counter] += dockpars_abs_max_dmov*(2*gpu_randf(dockpars_prng_states)-1);\n"
"\n"
"				else if (gene_counter < 6) { // Shoemake genes: u1, u2, 23\n"
"					offspring_genotype[gene_counter] = gpu_randf(dockpars_prng_states);\n"
"				}\n"
"				else\n"
"				{\n"
"					offspring_genotype[gene_counter] += dockpars_abs_max_dang*(2*gpu_randf(dockpars_prng_states)-1);\n"
"					map_angle(&(offspring_genotype[gene_counter]));\n"
"				}\n"
"\n"
"			}\n"
"		}\n"
"\n"
"		//calculating energy of new offspring\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		// =============================================================\n"
"		//WARNING: only energy of work-item=0 will be valid\n"
"		gpu_calc_energy(dockpars_rotbondlist_length,\n"
"				dockpars_num_of_atoms,\n"
"				dockpars_gridsize_x,\n"
"				dockpars_gridsize_y,\n"
"	                        dockpars_gridsize_z,\n"
"				dockpars_fgrids,\n"
"				dockpars_num_of_atypes,\n"
"				dockpars_num_of_intraE_contributors,\n"
"				dockpars_grid_spacing,\n"
"				dockpars_coeff_elec,\n"
"                                dockpars_qasp,\n"
"				dockpars_coeff_desolv,\n"
"				offspring_genotype,\n"
"				&energy,\n"
"				&run_id,\n"
"				// Some OpenCL compilers don't allow declaring \n"
"				// local variables within non-kernel functions.\n"
"				// These local variables must be declared in a kernel, \n"
"				// and then passed to non-kernel functions.\n"
"				calc_coords_x,\n"
"				calc_coords_y,\n"
"				calc_coords_z,\n"
"				partial_energies,\n"
"		\n"
"                                atom_charges_const,\n"
"	                        atom_types_const,\n"
"				intraE_contributors_const,\n"
"				VWpars_AC_const,\n"
"				VWpars_BD_const,\n"
"				dspars_S_const,\n"
"				dspars_V_const,\n"
"				rotlist_const,\n"
"				ref_coords_x_const,\n"
"				ref_coords_y_const,\n"
"				ref_coords_z_const,\n"
"				rotbonds_moving_vectors_const,\n"
"				rotbonds_unit_vectors_const,\n"
"				ref_orientation_quats_const\n"
"\n"
"		 		// -------------------------------------------------------------------\n"
"		 		// L30nardoSV\n"
"		 		// Gradient-related arguments\n"
"		 		// Calculate gradients (forces) for intermolecular energy\n"
"		 		// Derived from autodockdev/maps.py\n"
"		 		// -------------------------------------------------------------------\n"
"				,\n"
"				&is_enabled_gradient_calc,\n"
"				gradient_inter_x,\n"
"				gradient_inter_y,\n"
"				gradient_inter_z,\n"
"\n"
"				gradient_genotype\n"
"				);\n"
"				// -------------------------------------------------------------------\n"
"		// =============================================================\n"
"\n"
"		if (get_local_id(0) == 0) {\n"
"			dockpars_evals_of_new_entities[get_group_id(0)] = 1;\n"
"		}\n"
"\n"
"		if (get_local_id(0) == 0) {\n"
"			dockpars_energies_next[get_group_id(0)] = energy;\n"
"		}\n"
"\n"
"		//copying new offspring to next generation\n"
"#if defined (ASYNC_COPY)\n"
"		async_work_group_copy(dockpars_conformations_next + GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0),\n"
"				      offspring_genotype,\n"
"				      dockpars_num_of_genes,0);\n"
"#else\n"
"		for (gene_counter=get_local_id(0);\n"
"		     gene_counter<dockpars_num_of_genes;\n"
"		     gene_counter+=NUM_OF_THREADS_PER_BLOCK)\n"
"			   dockpars_conformations_next[GENOTYPE_LENGTH_IN_GLOBMEM*get_group_id(0)+gene_counter] = offspring_genotype[gene_counter];\n"
"#endif\n"
"  }\n"
"}\n"
"// Implementation of auxiliary functions for the gradient-based minimizer\n"
"\n"
"bool is_gradDescent_enabled(__local    float*        a_gNorm,\n"
"                                       float         gradMin_tol,\n"
"                            __local    unsigned int* a_nIter,\n"
"                                       unsigned int  gradMin_maxiter,\n"
"                            __local    float*        a_perturbation,\n"
"                            __constant float*        gradMin_conformation_min_perturbation,\n"
"                            __local    bool*         is_gradDescentEn,\n"
"				       uint          gradMin_numElements)\n"
"{\n"
"	bool is_gNorm_gt_gMin       = (a_gNorm[0] >= gradMin_tol);\n"
"	bool is_nIter_lt_maxIter    = (a_nIter[0] <= gradMin_maxiter);\n"
"\n"
"	bool is_perturb_gt_gene_min [ACTUAL_GENOTYPE_LENGTH];\n"
"	bool is_perturb_gt_genotype = true;\n"
"\n"
"	// For every gene, let's determine \n"
"	// if perturbation is greater than min conformation\n"
"  	for(uint i=get_local_id(0); \n"
"		 i<gradMin_numElements; \n"
"		 i+=NUM_OF_THREADS_PER_BLOCK) {\n"
"   		is_perturb_gt_gene_min[i] = (a_perturbation[i] >= gradMin_conformation_min_perturbation[i]);\n"
"  	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"  	// Reduce all is_perturb_gt_gene_min's \n"
"	// into their corresponding genotype\n"
"  	for(uint i=get_local_id(0); \n"
"		 i<gradMin_numElements;\n"
"		 i+=NUM_OF_THREADS_PER_BLOCK) {\n"
"    		is_perturb_gt_genotype = is_perturb_gt_genotype && is_perturb_gt_gene_min[i];\n"
"  	}\n"
"\n"
"  	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"  	// Reduce all three previous \n"
"	// partial evaluations (gNorm, nIter, perturb) into a final one\n"
"  	if (get_local_id(0) == 0) {\n"
"      		is_gradDescentEn[0] = is_gNorm_gt_gMin && is_nIter_lt_maxIter && is_perturb_gt_genotype;\n"
"  	}\n"
"\n"
"  	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"  	return is_gradDescentEn[0];\n"
"}\n"
"\n"
"void stepGPU (// Args for minimization\n"
"	      __local float*       local_genotype,         // originally as \"d_x\"\n"
"              __local float*       local_genotype_new,     // originally as \"d_xnew\"\n"
"              __local float*       local_genotype_diff,    // originally as \"d_xdiff\"\n"
"              __local float*       local_gradient,         // originally as \"d_g\"\n"
"                      float        gradMin_alpha,          // originally as \"alpha\"\n"
"                      float        gradMin_h,              // originally as \"h\"\n"
"                      unsigned int gradMin_inputSize,      // originally as \"M\". initially labelled as \"gradMin_M\"\n"
"\n"
"	       // Args for energy and gradient calculation\n"
"		      int    	   dockpars_rotbondlist_length,\n"
"		      char	   dockpars_num_of_atoms,\n"
"		      char         dockpars_gridsize_x,\n"
"		      char         dockpars_gridsize_y,\n"
"		      char         dockpars_gridsize_z,\n"
"		#if defined (RESTRICT_ARGS)\n"
"    __global const float* restrict dockpars_fgrids, // cannot be allocated in __constant (too large)\n"
"		#else\n"
"    __global const float*          dockpars_fgrids, // cannot be allocated in __constant (too large)\n"
"		#endif\n"
"	              char   	   dockpars_num_of_atypes,\n"
"		      int    	   dockpars_num_of_intraE_contributors,\n"
"		      float  	   dockpars_grid_spacing,\n"
"	              float  	   dockpars_coeff_elec,\n"
"	              float        dockpars_qasp,\n"
"		      float  	   dockpars_coeff_desolv,\n"
"\n"
"              __local float* 	   genotype,\n"
"	      __local float* 	   energy,\n"
"              __local int*   	   run_id,\n"
"\n"
"              // Some OpenCL compilers don't allow declaring \n"
"	      // local variables within non-kernel functions.\n"
"	      // These local variables must be declared in a kernel, \n"
"	      // and then passed to non-kernel functions.\n"
"		    __local float* calc_coords_x,\n"
"		    __local float* calc_coords_y,\n"
"		    __local float* calc_coords_z,\n"
"		    __local float* partial_energies,\n"
"\n"
"	         __constant float* atom_charges_const,\n"
"                 __constant char*  atom_types_const,\n"
"                 __constant char*  intraE_contributors_const,\n"
"                 __constant float* VWpars_AC_const,\n"
"                 __constant float* VWpars_BD_const,\n"
"                 __constant float* dspars_S_const,\n"
"                 __constant float* dspars_V_const,\n"
"                 __constant int*   rotlist_const,\n"
"                 __constant float* ref_coords_x_const,\n"
"                 __constant float* ref_coords_y_const,\n"
"                 __constant float* ref_coords_z_const,\n"
"                 __constant float* rotbonds_moving_vectors_const,\n"
"                 __constant float* rotbonds_unit_vectors_const,\n"
"                 __constant float* ref_orientation_quats_const\n"
"\n"
"		 // -------------------------------------------------------------------\n"
"		 // L30nardoSV\n"
"		 // Gradient-related arguments\n"
"		 // Calculate gradients (forces) for intermolecular energy\n"
"		 // Derived from autodockdev/maps.py\n"
"		 // -------------------------------------------------------------------\n"
"		\n"
"		 // \"is_enabled_gradient_calc\": enables gradient calculation.\n"
"		 // In Genetic-Generation: no need for gradients\n"
"		 // In Gradient-Minimizer: must calculate gradients\n"
"		 ,\n"
"		 __local bool*  is_enabled_gradient_calc,\n"
"	    	 __local float* gradient_inter_x,\n"
"	         __local float* gradient_inter_y,\n"
"	         __local float* gradient_inter_z,\n"
"\n"
"		 __local float* gradient_genotype\n"
")\n"
"{\n"
"	// Calculate gradient\n"
"\n"
"	// =============================================================\n"
"	gpu_calc_energy(dockpars_rotbondlist_length,\n"
"			dockpars_num_of_atoms,\n"
"			dockpars_gridsize_x,\n"
"			dockpars_gridsize_y,\n"
"			dockpars_gridsize_z,\n"
"			dockpars_fgrids,\n"
"			dockpars_num_of_atypes,\n"
"			dockpars_num_of_intraE_contributors,\n"
"			dockpars_grid_spacing,\n"
"			dockpars_coeff_elec,\n"
"			dockpars_qasp,\n"
"			dockpars_coeff_desolv,\n"
"			genotype,\n"
"			energy,\n"
"			run_id,\n"
"			// Some OpenCL compilers don't allow declaring \n"
"			// local variables within non-kernel functions.\n"
"			// These local variables must be declared in a kernel, \n"
"			// and then passed to non-kernel functions.\n"
"			calc_coords_x,\n"
"			calc_coords_y,\n"
"			calc_coords_z,\n"
"			partial_energies,\n"
"\n"
"	                atom_charges_const,\n"
"		        atom_types_const,\n"
"			intraE_contributors_const,\n"
"			VWpars_AC_const,\n"
"			VWpars_BD_const,\n"
"			dspars_S_const,\n"
"			dspars_V_const,\n"
"			rotlist_const,\n"
"			ref_coords_x_const,\n"
"			ref_coords_y_const,\n"
"			ref_coords_z_const,\n"
"			rotbonds_moving_vectors_const,\n"
"			rotbonds_unit_vectors_const,\n"
"			ref_orientation_quats_const\n"
"\n"
"		 	// -------------------------------------------------------------------\n"
"		 	// L30nardoSV\n"
"		 	// Gradient-related arguments\n"
"		 	// Calculate gradients (forces) for intermolecular energy\n"
"		 	// Derived from autodockdev/maps.py\n"
"		 	// -------------------------------------------------------------------\n"
"			,\n"
"			is_enabled_gradient_calc,\n"
"			gradient_inter_x,\n"
"			gradient_inter_y,\n"
"			gradient_inter_z,\n"
"\n"
"			gradient_genotype\n"
"			);\n"
"			// -------------------------------------------------------------------\n"
"	// =============================================================\n"
"\n"
"\n"
"	// TODO: Transform gradients_inter_{x|y|z} \n"
"	// into local_gradients[i] (with four quaternion genes)\n"
"	// Derived from autodockdev/motions.py/forces_to_delta_genes()\n"
"\n"
"	\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"	// TODO: Transform local_gradients[i] (with four quaternion genes)\n"
"	// into local_gradients[i] (with three Shoemake genes)\n"
"	// Derived from autodockdev/motions.py/_get_cube3_gradient()\n"
"\n"
"\n"
"\n"
"	for(unsigned int i=get_local_id(0); \n"
"			 i<gradMin_inputSize; \n"
"			 i+=NUM_OF_THREADS_PER_BLOCK) {\n"
"     		// Take step\n"
"     		// FIXME: add conditional evaluation of max grad\n"
"     		local_genotype_new[i]  = local_genotype[i] - gradMin_alpha * local_gradient[i];\n"
"\n"
"     		// Update termination metrics\n"
"     		local_genotype_diff[i] = local_genotype_new[i] - local_genotype[i];\n"
"\n"
"     		// Update current solution\n"
"     		local_genotype[i] = local_genotype_new[i];\n"
"   	}\n"
"}\n"
"\n"
"\n"
"float inner_product(__local float*       vector1,\n"
"                    __local float*       vector2,\n"
"                            unsigned int inputSize,\n"
"                    __local float*       init) {\n"
"\n"
"	if(get_local_id(0) == 0) {\n"
"		init[0] = 0.0f;\n"
"  	}\n"
"\n"
"  	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	for(unsigned int i=get_local_id(0); \n"
"			 i<inputSize; \n"
"			 i+=NUM_OF_THREADS_PER_BLOCK) {\n"
"		init[0] += vector1[i] * vector2[i];\n"
"  	}\n"
"\n"
"	return init[0];\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"// Implementation of gradient calculator\n"
"// Originally written in Python by Diogo Martins\n"
"// Initially coded within gpu_calc_energy()\n"
"\n"
"// Implementation of the gradient-based minimizer\n"
"// This will ideally replace the LS\n"
"\n"
"// Original source in https://stackoverflow.com/a/27910756\n"
"\n"
"\n"
"\n"
"\n"
"// FIXME: original call of stepGPU\n"
"// stepGPU<<<iDivUp(M, BLOCK_SIZE), BLOCK_SIZE>>>\n"
"// foo<<<N,1>>> means N blocks and 1thread in each block\n"
"\n"
"__kernel void __attribute__ ((reqd_work_group_size(NUM_OF_THREADS_PER_BLOCK,1,1)))\n"
"gradient_minimizer(	char   dockpars_num_of_atoms,\n"
"			char   dockpars_num_of_atypes,\n"
"			int    dockpars_num_of_intraE_contributors,\n"
"			char   dockpars_gridsize_x,\n"
"			char   dockpars_gridsize_y,\n"
"			char   dockpars_gridsize_z,\n"
"			float  dockpars_grid_spacing,\n"
"\n"
"			#if defined (RESTRICT_ARGS)\n"
"	  __global const float* restrict dockpars_fgrids, // cannot be allocated in __constant (too large)\n"
"			#else\n"
"	  __global const float* dockpars_fgrids,          // cannot be allocated in __constant (too large)\n"
"			#endif\n"
"			\n"
"			int    dockpars_rotbondlist_length,\n"
"			float  dockpars_coeff_elec,\n"
"			float  dockpars_coeff_desolv,\n"
"\n"
"			#if defined (RESTRICT_ARGS)\n"
"	  __global float* restrict dockpars_conformations_next,\n"
"	  __global float* restrict dockpars_energies_next,\n"
"	  //__global int*   restrict dockpars_evals_of_new_entities,\n"
"	  __global unsigned int* restrict dockpars_prng_states,\n"
"			#else\n"
"	  __global float* dockpars_conformations_next,\n"
"	  __global float* dockpars_energies_next,\n"
"	  //__global int*   dockpars_evals_of_new_entities,\n"
"	  __global unsigned int* dockpars_prng_states,\n"
"			#endif\n"
"\n"
"			int    dockpars_pop_size,\n"
"			int    dockpars_num_of_genes,\n"
"			float  dockpars_lsearch_rate,\n"
"			unsigned int dockpars_num_of_lsentities,\n"
"			//float  dockpars_rho_lower_bound,\n"
"			//float  dockpars_base_dmov_mul_sqrt3,\n"
"			//float  dockpars_base_dang_mul_sqrt3,\n"
"			//unsigned int dockpars_cons_limit,\n"
"			//unsigned int dockpars_max_num_of_iters,\n"
"			float  dockpars_qasp,\n"
"\n"
"	     __constant float* atom_charges_const,\n"
"    	     __constant char*  atom_types_const,\n"
"	     __constant char*  intraE_contributors_const,\n"
"    	     __constant float* VWpars_AC_const,\n"
"    	     __constant float* VWpars_BD_const,\n"
"             __constant float* dspars_S_const,\n"
"             __constant float* dspars_V_const,\n"
"             __constant int*   rotlist_const,\n"
"    	     __constant float* ref_coords_x_const,\n"
"    	     __constant float* ref_coords_y_const,\n"
"             __constant float* ref_coords_z_const,\n"
"    	     __constant float* rotbonds_moving_vectors_const,\n"
"             __constant float* rotbonds_unit_vectors_const,\n"
"             __constant float* ref_orientation_quats_const,\n"
"\n"
"    // Specific gradient-minimizer args\n"
"    //  __global float* restrict dockpars_conformations_next,   // initial population\n"
"                                                                // whose (some) entities (genotypes) are to be minimized\n"
"    			float             gradMin_tol,\n"
"		    	unsigned int      gradMin_maxiter,\n"
"	    		float             gradMin_alpha,\n"
"	    		float             gradMin_h,\n"
"    	     __constant float* gradMin_conformation_min_perturbation     // minimal values for gene perturbation, originally as the scalar \"dxmin\"\n"
"    	     //unsigned int      gradMin_M,                              // dimensionality of the input data (=num_of_genes)\n"
"             //  __global float* restrict dockpars_conformations_next,   // optimized genotype are to be store back here, originally as \"d_xopt\"\n"
"             //  __global float* restrict dockpars_energies_next,        // minimized energy, originally as \"fopt\"\n"
"\n"
"    // Following kernel args were used to send counters back to host\n"
"    // Commented here as they are not needed\n"
"    //__global unsigned int* restrict gradMin_nIter,\n"
"    //__global float*        restrict gradMin_gNorm,\n"
"    //__global float*        restrict gradMin_perturbation        // originally as \"dx\"\n"
")\n"
"//The GPU global function performs gradient-based minimization on (some) entities of conformations_next.\n"
"//The number of OpenCL compute units (CU) which should be started equals to num_of_minEntities*num_of_runs.\n"
"//This way the first num_of_lsentities entity of each population will be subjected to local search\n"
"//(and each CU carries out the algorithm for one entity).\n"
"//Since the first entity is always the best one in the current population,\n"
"//it is always tested according to the ls probability, and if it not to be\n"
"//subjected to local search, the entity with ID num_of_lsentities is selected instead of the first one (with ID 0).\n"
"{\n"
"	// -----------------------------------------------------------------------------\n"
"	// Determine entity, and its run and energy\n"
"	__local int   entity_id;\n"
"	__local int   run_id;\n"
"  	__local float local_energy;\n"
"\n"
"	if (get_local_id(0) == 0)\n"
"	{\n"
"		entity_id = get_group_id(0) % dockpars_num_of_lsentities;\n"
"		run_id = get_group_id(0) / dockpars_num_of_lsentities;\n"
"		\n"
"		// Since entity-ID=0 is the best one due to elitism, it should be subjected to random selection\n"
"		if (entity_id == 0)\n"
"			if (100.0f*gpu_randf(dockpars_prng_states) > dockpars_lsearch_rate)\n"
"				entity_id = dockpars_num_of_lsentities;	 // If entity-ID=0 is not selected according to LS-rate,\n"
"									 // then choose another entity\n"
"\n"
"		local_energy = dockpars_energies_next[run_id*dockpars_pop_size+entity_id];\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"  	// -----------------------------------------------------------------------------\n"
"	// Initialize variables for gradient minimizer\n"
"  	__local float        local_gNorm;                                  // gradient norm (shared in the CU), originally as \"gnorm\"\n"
"  	__local unsigned int local_nIter;                                  // iteration counter, originally as \"niter\"\n"
"  	__local float        local_perturbation [ACTUAL_GENOTYPE_LENGTH];  // perturbation, originally as \"dx\"\n"
"  	__local float        local_genotype[ACTUAL_GENOTYPE_LENGTH];       // optimization vector, originally as \"d_x\"\n"
"\n"
"	if (get_local_id(0) == 0) {\n"
"		local_gNorm = FLT_MAX;\n"
"    		local_nIter = 0;\n"
"  	}\n"
"\n"
"  	for(unsigned int i=get_local_id(0); \n"
"			 i<dockpars_num_of_genes; \n"
"			 i+=NUM_OF_THREADS_PER_BLOCK) {\n"
"    		local_perturbation[i] = FLT_MAX;\n"
"  	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"  	async_work_group_copy(local_genotype,\n"
"  			      dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"                              dockpars_num_of_genes,0);\n"
"\n"
"  	// -----------------------------------------------------------------------------\n"
"  	// Allocate space\n"
"	__local float local_gradient      [ACTUAL_GENOTYPE_LENGTH]; // gradient, originally as \"d_g\"\n"
"	__local float local_genotype_new  [ACTUAL_GENOTYPE_LENGTH]; // new actual solution, originally as \"d_xnew\"\n"
"	__local float local_genotype_diff [ACTUAL_GENOTYPE_LENGTH]; // difference between actual and old solution, originally as \"d_xdiff\"\n"
"\n"
"	// Some OpenCL compilers don't allow declaring \n"
"	// local variables within non-kernel functions.\n"
"	// These local variables must be declared in a kernel, \n"
"	// and then passed to non-kernel functions.\n"
"  	__local bool  is_gradDescentEn;                             // used in is_gradDescent_enabled()\n"
"	__local float innerProduct;                                 // used in inner_product()\n"
"\n"
"	// -------------------------------------------------------------------\n"
"	// L30nardoSV\n"
"	// Calculate gradients (forces) for intermolecular energy\n"
"	// Derived from autodockdev/maps.py\n"
"	// -------------------------------------------------------------------\n"
"	// Variables to store gradient of \n"
"	// the intermolecular energy per each ligand atom\n"
"\n"
"	// Some OpenCL compilers don't allow declaring \n"
"	// local variables within non-kernel functions.\n"
"	// These local variables must be declared in a kernel, \n"
"	// and then passed to non-kernel functions.\n"
"	__local float gradient_inter_x[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_inter_y[MAX_NUM_OF_ATOMS];\n"
"	__local float gradient_inter_z[MAX_NUM_OF_ATOMS];\n"
"\n"
"	// Enable gradient calculation for this kernel\n"
"	__local bool  is_enabled_gradient_calc;\n"
"	if (get_local_id(0) == 0) {\n"
"		is_enabled_gradient_calc = true;\n"
"	}\n"
"\n"
"	// Final gradient resulting out of gradient calculation\n"
"	__local float gradient_genotype[GENOTYPE_LENGTH_IN_GLOBMEM];\n"
"	// -------------------------------------------------------------------\n"
"\n"
"	// Variables to store partial energies\n"
"	__local float calc_coords_x[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_y[MAX_NUM_OF_ATOMS];\n"
"	__local float calc_coords_z[MAX_NUM_OF_ATOMS];\n"
"	__local float partial_energies[NUM_OF_THREADS_PER_BLOCK];\n"
"\n"
"	// -----------------------------------------------------------------------------\n"
"	// Perform gradient-descent iterations\n"
"	while (is_gradDescent_enabled(&local_gNorm,\n"
"    				      gradMin_tol,\n"
"    				      &local_nIter,\n"
"    				      gradMin_maxiter,\n"
"    				      local_perturbation,\n"
"    				      gradMin_conformation_min_perturbation,\n"
"    				      &is_gradDescentEn,\n"
"				      dockpars_num_of_genes) == true) {\n"
"\n"
"    		stepGPU(// Args for minimization\n"
"			local_genotype,\n"
"		        local_genotype_new,\n"
"      			local_genotype_diff,\n"
"      			local_gradient,\n"
"      			gradMin_alpha,\n"
"      			gradMin_h,\n"
"      			dockpars_num_of_genes, //gradMin_M\n"
"\n"
"			// Args for energy and gradient calculation\n"
"			dockpars_rotbondlist_length,\n"
"			dockpars_num_of_atoms,\n"
"			dockpars_gridsize_x,\n"
"			dockpars_gridsize_y,\n"
"			dockpars_gridsize_z,\n"
"			dockpars_fgrids,\n"
"			dockpars_num_of_atypes,\n"
"			dockpars_num_of_intraE_contributors,\n"
"			dockpars_grid_spacing,\n"
"			dockpars_coeff_elec,\n"
"			dockpars_qasp,\n"
"			dockpars_coeff_desolv,\n"
"			local_genotype,\n"
"			&local_energy,\n"
"			&run_id,\n"
"			// Some OpenCL compilers don't allow declaring \n"
"			// local variables within non-kernel functions.\n"
"			// These local variables must be declared in a kernel, \n"
"			// and then passed to non-kernel functions.\n"
"			calc_coords_x,\n"
"			calc_coords_y,\n"
"			calc_coords_z,\n"
"			partial_energies,\n"
"\n"
"	                atom_charges_const,\n"
"		        atom_types_const,\n"
"			intraE_contributors_const,\n"
"			VWpars_AC_const,\n"
"			VWpars_BD_const,\n"
"			dspars_S_const,\n"
"			dspars_V_const,\n"
"			rotlist_const,\n"
"			ref_coords_x_const,\n"
"			ref_coords_y_const,\n"
"			ref_coords_z_const,\n"
"			rotbonds_moving_vectors_const,\n"
"			rotbonds_unit_vectors_const,\n"
"			ref_orientation_quats_const\n"
"\n"
"		 	// -------------------------------------------------------------------\n"
"		 	// L30nardoSV\n"
"		 	// Gradient-related arguments\n"
"		 	// Calculate gradients (forces) for intermolecular energy\n"
"		 	// Derived from autodockdev/maps.py\n"
"		 	// -------------------------------------------------------------------\n"
"			,\n"
"			&is_enabled_gradient_calc,\n"
"			gradient_inter_x,\n"
"			gradient_inter_y,\n"
"			gradient_inter_z,\n"
"\n"
"			gradient_genotype\n"
"      			);\n"
"			// -------------------------------------------------------------------\n"
"\n"
"    		// Store the norm of all gradients\n"
"    		local_gNorm = native_sqrt(inner_product(local_gradient, \n"
"						        local_gradient,\n"
"                                                        dockpars_num_of_genes,\n"
"                                                        &innerProduct));\n"
"\n"
"    		// Here it is stored a reduced norm of all perturbations\n"
"	    	local_perturbation[0] = native_sqrt(inner_product(local_genotype_diff,\n"
"                                                                  local_genotype_diff,\n"
"                                                                  dockpars_num_of_genes,\n"
"                                                                  &innerProduct));\n"
"    		local_nIter = local_nIter + 1;\n"
"  	}\n"
"	// -----------------------------------------------------------------------------\n"
"\n"
"  	// Functional calculation\n"
"	// stepGPU () calls gpu_calc_energy ()\n"
"	// the former calculates energy + gradients\n"
"	\n"
"  	// Copy final genotype and energy into global memory\n"
"	if (get_local_id(0) == 0) {\n"
"		  dockpars_energies_next[run_id*dockpars_pop_size+entity_id] = local_energy;\n"
"	}\n"
"\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	async_work_group_copy(dockpars_conformations_next+(run_id*dockpars_pop_size+entity_id)*GENOTYPE_LENGTH_IN_GLOBMEM,\n"
"			      local_genotype,\n"
"			      dockpars_num_of_genes,0);\n"
"\n"
"\n"
"  	// copy final \"local\" results into \"global\" memory\n"
"  	local_nIter = local_nIter - 1;\n"
"}\n"
;
#endif // End of STRINGIFY_H
